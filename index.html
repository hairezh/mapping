<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Web Mania Editor V4 — osu-like layout (4K–7K)</title>
  <style>
    :root{
      --bg:#0b0c0f;
      --panel:#11141a;
      --panel2:#0e1117;
      --fg:#eaeef6;
      --muted:#9aa4b2;
      --border:rgba(255,255,255,.10);
      --border2:rgba(255,255,255,.06);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#86efac;

      --r1:10px;
      --r2:14px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);
      display:flex; flex-direction:column; overflow:hidden;
    }

    /* Faux menu bar */
    .menubar{
      height:28px;
      display:flex; align-items:center; gap:18px;
      padding:0 12px;
      border-bottom:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
      user-select:none;
    }
    .menubar span{cursor:default}

    /* Tabs (Compose / Design / Timing / Song setup) */
    .tabs{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .tab{
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      padding:8px 12px;
      border-radius:999px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .tab.active{
      color:var(--fg);
      border-color:rgba(125,211,252,.30);
      background:rgba(125,211,252,.10);
    }

    /* Main layout */
    .app{
      flex:1;
      display:grid;
      grid-template-columns: 84px 1fr 360px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r2);
      overflow:hidden;
      min-height:0;
    }
    .panel .hd{
      padding:10px 12px;
      border-bottom:1px solid var(--border2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:12px; color:var(--muted);
      user-select:none;
    }
    .panel .bd{ padding:12px; min-height:0; }
    .divider{ height:1px; background:var(--border2); margin:10px 0; }

    /* Left: toolbox + minimap */
    .left{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }
    .toolbox{
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .tool{
      width:100%;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:6px;
      padding:10px 6px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--muted);
      cursor:pointer;
      user-select:none;
      font-size:11px;
      line-height:1;
    }
    .tool.active{
      color:var(--fg);
      border-color:rgba(125,211,252,.35);
      background:rgba(125,211,252,.10);
    }
    .tool svg{width:18px; height:18px; opacity:.9}
    .tool .kbd{
      font-family:var(--mono);
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
    }

    .minimapWrap{
      flex:1;
      display:flex; flex-direction:column;
      min-height:0;
    }
    .minimapCanvas{
      flex:1;
      border-top:1px solid var(--border2);
      background:#07090d;
    }

    /* Center: stage + timeline */
    .center{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    .stageWrap{
      position:relative;
      flex:1;
      border-radius:var(--r2);
      border:1px solid var(--border);
      background:#07090d;
      overflow:hidden;
      min-height:0;
    }
    canvas{display:block; width:100%; height:100%}

    .hud{
      position:absolute;
      top:10px; left:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index:5;
      pointer-events:none;
    }
    .badge{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(0,0,0,.35);
      color:var(--muted);
      backdrop-filter: blur(6px);
    }
    .badge b{color:var(--fg); font-weight:600}

    .timelineWrap{
      height:145px;
      border-radius:var(--r2);
      border:1px solid var(--border);
      overflow:hidden;
      background:#07090d;
      position:relative;
    }
    .timelineHud{
      position:absolute;
      top:10px; left:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index:5;
      pointer-events:none;
    }

    /* Right */
    .right{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    /* Inputs */
    label{
      display:flex; flex-direction:column; gap:6px;
      font-size:12px; color:var(--muted);
    }
    input[type="text"], input[type="number"], select, button{
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--fg);
      border-radius:var(--r1);
      padding:9px 10px;
      font-size:14px;
      outline:none;
    }
    input[type="range"]{ width:100% }
    input[type="file"]{ color:var(--muted); font-size:13px }
    button{ cursor:pointer; user-select:none }
    button.primary{ border-color:rgba(125,211,252,.45) }
    button.ok{ border-color:rgba(134,239,172,.50); color:#d1fae5 }
    button.danger{ border-color:rgba(251,113,133,.55); color:#ffd7df }
    button:disabled{ opacity:.55; cursor:not-allowed }

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}

    .list{
      border:1px solid var(--border2);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      overflow:auto;
      max-height:22vh;
    }
    .item{
      padding:9px 10px;
      border-bottom:1px solid var(--border2);
      display:flex; justify-content:space-between; gap:10px;
      font-size:12px; color:var(--muted);
      cursor:pointer;
    }
    .item:last-child{border-bottom:none}
    .item.sel{background:rgba(125,211,252,.10)}
    .item b{color:var(--fg); font-weight:600}
    .small{font-size:12px; color:var(--muted); line-height:1.45}
    .mono{font-family:var(--mono)}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
    }
    .pill b{color:var(--fg)}
    .toggleRow{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:8px 10px;
    }
    .toggleRow input{transform:scale(1.05)}
    .hint{
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    /* Footer transport */
    .transport{
      height:58px;
      border-top:1px solid var(--border);
      background:rgba(255,255,255,.03);
      display:flex; align-items:center; justify-content:space-between;
      padding:10px 12px;
      gap:10px;
    }
    .transport .leftInfo{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      color:var(--muted); font-size:12px;
    }
    .transport .controls{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .iconBtn{
      width:38px; height:38px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel2);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    .iconBtn svg{width:18px; height:18px}
    .rateBtns{
      display:flex; gap:6px; align-items:center;
    }
    .rateBtns button{
      padding:8px 10px;
      border-radius:10px;
      font-size:12px;
      color:var(--muted);
    }
    .rateBtns button.active{
      color:var(--fg);
      border-color:rgba(125,211,252,.45);
      background:rgba(125,211,252,.10);
    }

    /* Responsive */
    @media (max-width: 1100px){
      .app{ grid-template-columns: 84px 1fr; }
      .right{ display:none; }
    }
  </style>
</head>

<body>
  <div class="menubar">
    <span>File</span><span>Edit</span><span>View</span><span>Compose</span><span>Design</span><span>Timing</span><span>Web</span><span>Help</span>
  </div>

  <div class="tabs">
    <button class="tab active" data-tab="compose">compose</button>
    <button class="tab" data-tab="design">design</button>
    <button class="tab" data-tab="timing">timing</button>
    <button class="tab" data-tab="song">song setup</button>

    <div style="flex:1"></div>

    <div class="pill">
      Keys: <b id="pillKeys">4</b>
    </div>
    <div class="pill">
      Snap: <b id="pillSnap">1/4</b>
    </div>
    <div class="pill">
      Tool: <b id="pillTool">Select</b>
    </div>
  </div>

  <div class="app">
    <!-- LEFT -->
    <section class="left">
      <div class="panel">
        <div class="hd">Tools</div>
        <div class="toolbox">
          <button class="tool active" data-tool="select" title="Select (1)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4l7 17 2-7 7-2L4 4z"/></svg>
            <div>Select</div>
            <div class="kbd">1</div>
          </button>
          <button class="tool" data-tool="tap" title="Tap (2)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20v-8"/><path d="M8 12h8"/><circle cx="12" cy="6" r="3"/></svg>
            <div>Tap</div>
            <div class="kbd">2</div>
          </button>
          <button class="tool" data-tool="hold" title="Hold (3)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="7" y="4" width="10" height="16" rx="2"/><path d="M12 8v8"/></svg>
            <div>Hold</div>
            <div class="kbd">3</div>
          </button>
          <button class="tool" data-tool="erase" title="Erase (4)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H8l-4-4L14 6l6 6-8 8"/><path d="M13 7l6 6"/></svg>
            <div>Erase</div>
            <div class="kbd">4</div>
          </button>

          <div class="divider"></div>

          <div class="toggleRow" title="Key recording (tocar e gravar)">
            <div class="small"><b class="mono">REC</b> Key recording</div>
            <input id="recToggle" type="checkbox" />
          </div>

          <div class="toggleRow" title="Quantize durante gravação">
            <div class="small">Quantize REC</div>
            <input id="recQuantToggle" type="checkbox" checked/>
          </div>
        </div>
      </div>

      <div class="panel minimapWrap">
        <div class="hd">
          Minimap
          <span class="small mono" id="miniLbl">—</span>
        </div>
        <canvas id="miniCanvas" class="minimapCanvas"></canvas>
      </div>
    </section>

    <!-- CENTER -->
    <section class="center">
      <div class="stageWrap" id="stageWrap">
        <div class="hud">
          <span class="badge">Time: <b class="mono" id="hudTime">0</b> ms</span>
          <span class="badge">Notes: <b class="mono" id="hudCount">0</b></span>
          <span class="badge">TP: <b class="mono" id="hudTP">—</b></span>
          <span class="badge">Snap: <b class="mono" id="hudSnap">1/4</b> <span class="mono" id="hudSnapOn">(on)</span></span>
        </div>
        <canvas id="stageCanvas"></canvas>
      </div>

      <div class="timelineWrap" id="timelineWrap">
        <div class="timelineHud">
          <span class="badge">Timeline window: <b class="mono" id="tlWin">8</b>s</span>
          <span class="badge">Waveform: <b class="mono" id="tlWf">—</b></span>
          <span class="badge">Break: <b class="mono" id="brkStatus">—</b></span>
        </div>
        <canvas id="timelineCanvas"></canvas>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="right">
      <!-- Compose / global -->
      <div class="panel" id="panelGlobal">
        <div class="hd">Projeto</div>
        <div class="bd">
          <label>Áudio
            <input id="audioFile" type="file" accept="audio/*">
          </label>

          <div class="grid2" style="margin-top:10px">
            <label>Keys (4–7)
              <select id="keysSel">
                <option>4</option><option>5</option><option>6</option><option>7</option>
              </select>
            </label>
            <label>Snap On/Off
              <select id="snapOnSel">
                <option value="on" selected>On</option>
                <option value="off">Off</option>
              </select>
            </label>
            <label>Scroll speed (px/s)
              <input id="scrollIn" type="number" min="250" max="9000" step="50" value="1700">
            </label>
            <label>Timeline window (s)
              <input id="tlWinIn" type="number" min="3" max="30" step="1" value="8">
            </label>
          </div>

          <div class="grid2" style="margin-top:10px">
            <button id="exportBtn" class="primary" disabled>Exportar .osu</button>
            <button id="undoBtn" disabled>Undo</button>
            <button id="deleteBtn" class="danger" disabled>Delete sel.</button>
            <button id="clearNotesBtn" class="danger" disabled>Clear notes</button>
          </div>

          <div class="hint" style="margin-top:10px">
            <div><b>Atalhos</b>: <span class="mono">Space</span> play/pause • <span class="mono">Wheel</span> scroll tempo • <span class="mono">Ctrl+Z</span> undo • <span class="mono">Delete</span> apagar</div>
            <div>Minimap: clique para seek rápido. Timeline: clique e arraste para navegar.</div>
          </div>
        </div>
      </div>

      <!-- Snap + break -->
      <div class="panel" id="panelSnap">
        <div class="hd">Grid / Snap</div>
        <div class="bd">
          <div class="small" style="margin-bottom:8px">Beat Snap Divisor</div>
          <input id="snapRange" type="range" min="0" max="7" step="1" value="3">
          <div class="small" style="margin-top:8px; display:flex; justify-content:space-between">
            <span class="mono" id="snapLabel">1/4</span>
            <span class="mono" id="snapOpts">1/1 1/2 1/3 1/4 1/6 1/8 1/12 1/16</span>
          </div>

          <div class="divider"></div>

          <button id="breakBtn" class="primary" disabled>Insert Break Time</button>
          <div class="small" style="margin-top:8px">
            Clique 1 = início • Clique 2 = fim (cria break). Breaks aparecem no export.
          </div>

          <div class="divider"></div>

          <div class="small" style="margin-bottom:6px">Break list</div>
          <div class="list" id="breakList" style="max-height:14vh"></div>
        </div>
      </div>

      <!-- Note props -->
      <div class="panel" id="panelProps">
        <div class="hd">Selected note</div>
        <div class="bd">
          <div class="small" id="selLine">—</div>

          <div class="grid2" style="margin-top:10px">
            <label>Time (ms)
              <input id="propTime" type="number" step="1" disabled>
            </label>
            <label>Lane (1..K)
              <input id="propLane" type="number" step="1" min="1" max="7" disabled>
            </label>
            <label>Type
              <select id="propType" disabled>
                <option value="tap">tap</option>
                <option value="hold">hold</option>
              </select>
            </label>
            <label>End (ms)
              <input id="propEnd" type="number" step="1" disabled>
            </label>
          </div>

          <div class="divider"></div>

          <div class="small" style="margin-bottom:8px">Hitsounds</div>
          <div class="grid3">
            <button id="hsWhistle" disabled>Whistle</button>
            <button id="hsFinish" disabled>Finish</button>
            <button id="hsClap" disabled>Clap</button>
          </div>
          <div class="grid2" style="margin-top:10px">
            <label>Volume (0..100)
              <input id="hsVol" type="number" min="0" max="100" step="5" value="0" disabled>
            </label>
            <label>Flags
              <input id="hsFlags" type="number" min="0" max="14" step="1" value="0" disabled>
            </label>
          </div>

          <div class="hint" style="margin-top:10px">
            Dica: hitsound flags típicos: whistle=2, finish=4, clap=8 (combináveis somando).
          </div>
        </div>
      </div>

      <!-- Timing -->
      <div class="panel" id="panelTiming">
        <div class="hd">Timing points</div>
        <div class="bd">
          <div class="grid3">
            <button id="tpAdd" class="ok" disabled>Add TP @ tempo</button>
            <button id="tpSort" disabled>Sort</button>
            <button id="tpReset" class="danger" disabled>Reset</button>
          </div>
          <div class="divider"></div>
          <div class="list" id="tpList" style="max-height:18vh"></div>
        </div>
      </div>

      <!-- Song setup -->
      <div class="panel" id="panelMeta">
        <div class="hd">Song setup</div>
        <div class="bd">
          <div class="grid2">
            <label>Title <input id="mTitle" type="text" value="WebManiaEditor"></label>
            <label>Artist <input id="mArtist" type="text" value="Unknown"></label>
            <label>Creator <input id="mCreator" type="text" value="reze"></label>
            <label>Version <input id="mVersion" type="text" value="Easy"></label>
          </div>

          <div class="divider"></div>

          <label>Background image (opcional)
            <input id="bgFile" type="file" accept="image/*">
          </label>
          <div class="grid2" style="margin-top:10px">
            <label>BG opacity
              <input id="bgOpacity" type="number" min="0" max="1" step="0.05" value="0.35">
            </label>
            <label>Lane opacity
              <input id="laneOpacity" type="number" min="0" max="1" step="0.05" value="0.08">
            </label>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="transport">
    <div class="leftInfo">
      <span class="mono" id="timeStr">00:00:000</span>
      <span class="mono" id="pctStr">0.0%</span>
      <span class="mono" id="noteStr">notes: 0</span>
      <span class="mono" id="selStr">sel: 0</span>
    </div>

    <div class="controls">
      <div class="iconBtn" id="playBtn" title="Play/Pause (Space)">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
      </div>
      <div class="iconBtn" id="stopBtn" title="Stop">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 7h10v10H7z"/></svg>
      </div>

      <div class="rateBtns" title="Playback rate">
        <button data-rate="0.25">25%</button>
        <button data-rate="0.50">50%</button>
        <button data-rate="0.75">75%</button>
        <button data-rate="1.00" class="active">100%</button>
      </div>

      <label class="small" style="gap:6px; min-width:160px">
        Volume
        <input id="volRange" type="range" min="0" max="1" step="0.01" value="1">
      </label>
    </div>
  </div>

<script>
(() => {
  // ---------- DOM ----------
  const $ = (id) => document.getElementById(id);
  const qsa = (sel) => Array.from(document.querySelectorAll(sel));

  const tabs = qsa(".tab");
  const tools = qsa(".tool");

  const pillKeys = $("pillKeys");
  const pillSnap = $("pillSnap");
  const pillTool = $("pillTool");

  const audioFile = $("audioFile");
  const keysSel = $("keysSel");
  const snapOnSel = $("snapOnSel");
  const scrollIn = $("scrollIn");
  const tlWinIn = $("tlWinIn");

  const exportBtn = $("exportBtn");
  const undoBtn = $("undoBtn");
  const deleteBtn = $("deleteBtn");
  const clearNotesBtn = $("clearNotesBtn");

  const snapRange = $("snapRange");
  const snapLabel = $("snapLabel");

  const breakBtn = $("breakBtn");
  const breakList = $("breakList");

  const tpAdd = $("tpAdd");
  const tpSort = $("tpSort");
  const tpReset = $("tpReset");
  const tpList = $("tpList");

  const propTime = $("propTime");
  const propLane = $("propLane");
  const propType = $("propType");
  const propEnd = $("propEnd");
  const hsWhistle = $("hsWhistle");
  const hsFinish = $("hsFinish");
  const hsClap = $("hsClap");
  const hsVol = $("hsVol");
  const hsFlags = $("hsFlags");
  const selLine = $("selLine");

  const mTitle = $("mTitle");
  const mArtist = $("mArtist");
  const mCreator = $("mCreator");
  const mVersion = $("mVersion");

  const bgFile = $("bgFile");
  const bgOpacity = $("bgOpacity");
  const laneOpacity = $("laneOpacity");

  const recToggle = $("recToggle");
  const recQuantToggle = $("recQuantToggle");

  const stageWrap = $("stageWrap");
  const stageCanvas = $("stageCanvas");
  const sctx = stageCanvas.getContext("2d");

  const timelineWrap = $("timelineWrap");
  const timelineCanvas = $("timelineCanvas");
  const tctx = timelineCanvas.getContext("2d");

  const miniCanvas = $("miniCanvas");
  const mctx = miniCanvas.getContext("2d");
  const miniLbl = $("miniLbl");

  const hudTime = $("hudTime");
  const hudCount = $("hudCount");
  const hudTP = $("hudTP");
  const hudSnap = $("hudSnap");
  const hudSnapOn = $("hudSnapOn");
  const tlWin = $("tlWin");
  const tlWf = $("tlWf");
  const brkStatus = $("brkStatus");

  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const volRange = $("volRange");
  const rateBtns = qsa(".rateBtns button");

  const timeStr = $("timeStr");
  const pctStr = $("pctStr");
  const noteStr = $("noteStr");
  const selStr = $("selStr");

  // ---------- State ----------
  const SNAP_OPTS = [1,2,3,4,6,8,12,16];

  const state = {
    tab: "compose",
    tool: "select",

    keys: 4,
    snap: 4,        // divisor value, one of SNAP_OPTS
    snapOn: true,

    scrollPxPerSec: 1700,
    tlWinSec: 8,

    // audio
    ac: null,
    buffer: null,
    source: null,
    gain: null,
    startedAt: 0,
    startOffsetSec: 0,
    isPlaying: false,
    timeMs: 0,
    rate: 1,

    // waveform peaks
    wf: {
      ready:false,
      peaks:null,
      blockSize:2048,
      blockSec:0,
      max:1,
      progress:0
    },

    // minimap helper
    mini: { ready:false },

    // assets
    bgImg: null,
    bgOpacity: 0.35,
    laneOpacity: 0.08,

    // timing points
    timing: [{ id: uid(), t:0, bpm:180, meter:4 }],

    // breaks
    breaks: [], // {id, start, end}
    breakArming: false,
    breakStart: null,

    // notes
    notes: [], // {id, lane, t, type, end, hs, vol}
    selected: new Set(),
    undo: [],

    // drag
    drag: {
      down:false,
      mode:"none", // none | box | move | holdCreate
      x0:0, y0:0,
      box:null,
      moveSnap:null, // Map id -> base
      holdId:null
    },

    // timeline drag
    tlDrag:false,

    // recording
    rec: {
      on:false,
      quantize:true,
      bindsByKeys: {
        4:["d","f","j","k"],
        5:["d","f","space","j","k"],
        6:["s","d","f","j","k","l"],
        7:["s","d","f","space","j","k","l"],
      },
      downMap: new Map(), // key -> {noteId}
    },
  };

  function uid(){ return Math.random().toString(36).slice(2,10); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // ---------- Resize ----------
  function resizeCanvas(canvas, wrap){
    const r = wrap.getBoundingClientRect();
    canvas.width = Math.floor(r.width * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  const roStage = new ResizeObserver(()=> resizeCanvas(stageCanvas, stageWrap));
  const roTl = new ResizeObserver(()=> resizeCanvas(timelineCanvas, timelineWrap));
  const roMini = new ResizeObserver(()=> resizeCanvas(miniCanvas, miniCanvas.parentElement));
  roStage.observe(stageWrap);
  roTl.observe(timelineWrap);
  roMini.observe(miniCanvas.parentElement);
  resizeCanvas(stageCanvas, stageWrap);
  resizeCanvas(timelineCanvas, timelineWrap);
  resizeCanvas(miniCanvas, miniCanvas.parentElement);

  const SW = ()=> stageCanvas.width / devicePixelRatio;
  const SH = ()=> stageCanvas.height / devicePixelRatio;
  const TW = ()=> timelineCanvas.width / devicePixelRatio;
  const TH = ()=> timelineCanvas.height / devicePixelRatio;
  const MW = ()=> miniCanvas.width / devicePixelRatio;
  const MH = ()=> miniCanvas.height / devicePixelRatio;

  const centerY = ()=> Math.floor(SH()*0.55);
  const pxPerMs = ()=> state.scrollPxPerSec / 1000;
  const laneW = ()=> SW() / state.keys;

  const xFromLane = (lane)=> lane * laneW();
  const laneFromX = (x)=> clamp(Math.floor(x / laneW()), 0, state.keys-1);

  const yFromTime = (tMs)=> centerY() - (tMs - state.timeMs) * pxPerMs();
  const timeFromY = (y)=> state.timeMs + (centerY() - y) / pxPerMs();

  // ---------- Timing helpers ----------
  function normalizeTiming(){
    state.timing.sort((a,b)=>a.t-b.t);
    const out=[];
    for(const tp of state.timing){
      if(out.length && out[out.length-1].t === tp.t) out[out.length-1]=tp;
      else out.push(tp);
    }
    state.timing = out;
  }
  function activeTP(ms){
    normalizeTiming();
    let best = state.timing[0];
    for(const tp of state.timing){
      if(tp.t <= ms) best = tp;
      else break;
    }
    return best;
  }
  function snapMsAt(ms){
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    return beatLen / state.snap;
  }
  function quantizeAt(ms){
    if(!state.snapOn) return ms;
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const base = tp.t;
    const n = Math.round((ms - base) / step);
    return base + n*step;
  }

  // ---------- Audio ----------
  async function ensureAC(){
    if(state.ac) return state.ac;
    state.ac = new (window.AudioContext || window.webkitAudioContext)();

    // gain node for volume
    state.gain = state.ac.createGain();
    state.gain.gain.value = parseFloat(volRange.value) || 1;
    state.gain.connect(state.ac.destination);

    return state.ac;
  }

  function cleanupSource(){
    try{ if(state.source) state.source.stop(); }catch(e){}
    state.source = null;
  }

  async function loadAudio(file){
    const ac = await ensureAC();
    const arr = await file.arrayBuffer();
    state.buffer = await ac.decodeAudioData(arr);

    state.timeMs = 0;
    state.startOffsetSec = 0;
    state.isPlaying = false;
    cleanupSource();

    exportBtn.disabled = false;
    undoBtn.disabled = state.undo.length===0;
    deleteBtn.disabled = state.selected.size===0;
    clearNotesBtn.disabled = false;
    breakBtn.disabled = false;
    tpAdd.disabled = false;
    tpSort.disabled = false;
    tpReset.disabled = false;

    // waveform
    state.wf.ready = false;
    state.wf.peaks = null;
    tlWf.textContent = "gerando…";
    buildPeaks();
  }

  async function play(){
    if(!state.buffer) return;
    const ac = await ensureAC();
    if(ac.state === "suspended") await ac.resume();

    cleanupSource();

    const src = ac.createBufferSource();
    src.buffer = state.buffer;
    src.playbackRate.value = state.rate;

    src.connect(state.gain);

    state.startedAt = ac.currentTime;
    src.start(0, state.startOffsetSec);

    state.source = src;
    state.isPlaying = true;

    src.onended = ()=>{
      if(state.isPlaying){
        state.isPlaying=false;
      }
    };
  }

  function pause(){
    if(!state.ac) return;
    const ac = state.ac;
    const playedSec = (ac.currentTime - state.startedAt) * state.rate;
    state.startOffsetSec += playedSec;
    cleanupSource();
    state.isPlaying = false;
  }

  function stop(){
    pause();
    state.startOffsetSec = 0;
    state.timeMs = 0;
  }

  function seekMs(ms){
    if(!state.buffer) return;
    const max = state.buffer.duration * 1000;
    state.timeMs = clamp(ms, 0, max);
    state.startOffsetSec = state.timeMs / 1000;

    if(state.isPlaying){
      pause();
      play();
    }
  }

  function updateTimeFromAudio(){
    if(!state.isPlaying || !state.ac) return;
    const ac = state.ac;

    const playedSec = (ac.currentTime - state.startedAt) * state.rate;
    const tSec = state.startOffsetSec + playedSec;
    state.timeMs = clamp(tSec*1000, 0, state.buffer.duration*1000);
  }

  // ---------- Waveform peaks ----------
  function buildPeaks(){
    const buf = state.buffer;
    if(!buf) return;

    const wf = state.wf;
    const dur = buf.duration;
    wf.blockSize = dur > 240 ? 4096 : (dur > 120 ? 2048 : 1024);

    const channels = buf.numberOfChannels;
    const len = buf.length;
    const block = wf.blockSize;
    const blocks = Math.ceil(len / block);

    wf.peaks = new Float32Array(blocks);
    wf.blockSec = block / buf.sampleRate;

    const ch = [];
    for(let c=0;c<channels;c++) ch.push(buf.getChannelData(c));

    let i=0, max=0;

    function step(){
      const t0 = performance.now();
      const budget = 12;

      while(i < blocks && performance.now() - t0 < budget){
        const start = i * block;
        const end = Math.min(len, start + block);
        let peak=0;

        for(let s=start; s<end; s++){
          let v=0;
          for(let c=0;c<channels;c++) v += ch[c][s];
          v /= channels;
          const a = Math.abs(v);
          if(a > peak) peak = a;
        }
        wf.peaks[i] = peak;
        if(peak > max) max = peak;
        i++;
      }

      wf.progress = i/blocks;
      tlWf.textContent = wf.progress >= 1 ? "ok" : Math.round(wf.progress*100) + "%";
      miniLbl.textContent = tlWf.textContent;

      if(i < blocks) requestAnimationFrame(step);
      else {
        wf.max = max || 1;
        wf.ready = true;
        tlWf.textContent = "ok";
        miniLbl.textContent = "ok";
      }
    }
    requestAnimationFrame(step);
  }

  function ampAtMs(ms){
    const wf = state.wf;
    if(!wf.ready || !wf.peaks) return 0;
    const sec = ms / 1000;
    const idx = Math.floor(sec / wf.blockSec);
    if(idx < 0 || idx >= wf.peaks.length) return 0;
    return wf.peaks[idx] / wf.max;
  }

  // ---------- Undo ----------
  function pushUndo(){
    state.undo.push(JSON.stringify({
      keys: state.keys,
      snap: state.snap,
      snapOn: state.snapOn,
      scrollPxPerSec: state.scrollPxPerSec,
      tlWinSec: state.tlWinSec,
      timing: state.timing,
      breaks: state.breaks,
      notes: state.notes,
      meta: getMeta(),
      bgOpacity: state.bgOpacity,
      laneOpacity: state.laneOpacity
    }));
    if(state.undo.length > 200) state.undo.shift();
    undoBtn.disabled = state.undo.length === 0;
  }

  function doUndo(){
    const raw = state.undo.pop();
    if(!raw) return;
    const s = JSON.parse(raw);

    state.keys = s.keys ?? state.keys;
    state.snap = s.snap ?? state.snap;
    state.snapOn = s.snapOn ?? state.snapOn;
    state.scrollPxPerSec = s.scrollPxPerSec ?? state.scrollPxPerSec;
    state.tlWinSec = s.tlWinSec ?? state.tlWinSec;
    state.timing = s.timing ?? state.timing;
    state.breaks = s.breaks ?? state.breaks;
    state.notes = s.notes ?? state.notes;
    if(s.meta) setMeta(s.meta);
    state.bgOpacity = s.bgOpacity ?? state.bgOpacity;
    state.laneOpacity = s.laneOpacity ?? state.laneOpacity;

    // sync UI
    keysSel.value = String(state.keys);
    scrollIn.value = String(state.scrollPxPerSec);
    tlWinIn.value = String(state.tlWinSec);
    snapOnSel.value = state.snapOn ? "on" : "off";
    bgOpacity.value = String(state.bgOpacity);
    laneOpacity.value = String(state.laneOpacity);

    // snap slider index
    const idx = SNAP_OPTS.indexOf(state.snap);
    snapRange.value = String(Math.max(0, idx));

    state.selected.clear();
    updateSelectionUI();
    renderTPList();
    renderBreakList();
    undoBtn.disabled = state.undo.length===0;
  }

  // ---------- Notes ----------
  function sortNotes(){
    state.notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);
  }

  function addNote(note){
    pushUndo();
    state.notes.push(note);
    sortNotes();
    state.selected.clear();
    state.selected.add(note.id);
    updateSelectionUI();
    deleteBtn.disabled = false;
  }

  function deleteSelection(){
    if(state.selected.size === 0) return;
    pushUndo();
    state.notes = state.notes.filter(n => !state.selected.has(n.id));
    state.selected.clear();
    updateSelectionUI();
    deleteBtn.disabled = true;
  }

  function clearNotes(){
    pushUndo();
    state.notes = [];
    state.selected.clear();
    updateSelectionUI();
  }

  function getSelectedOne(){
    if(state.selected.size !== 1) return null;
    const id = [...state.selected][0];
    return state.notes.find(n => n.id === id) || null;
  }

  function setPropsEnabled(on){
    propTime.disabled = !on;
    propLane.disabled = !on;
    propType.disabled = !on;
    propEnd.disabled = !on;
    hsVol.disabled = !on;
    hsFlags.disabled = !on;
    hsWhistle.disabled = !on;
    hsFinish.disabled = !on;
    hsClap.disabled = !on;
  }

  function updateSelectionUI(){
    const countSel = state.selected.size;
    selStr.textContent = `sel: ${countSel}`;
    deleteBtn.disabled = countSel === 0;

    if(countSel === 0){
      selLine.textContent = "—";
      setPropsEnabled(false);
      return;
    }
    if(countSel > 1){
      selLine.textContent = `${countSel} notas selecionadas`;
      setPropsEnabled(false);
      return;
    }

    const n = getSelectedOne();
    if(!n){
      selLine.textContent = "—";
      setPropsEnabled(false);
      return;
    }
    selLine.textContent = `lane ${n.lane+1} @ ${Math.round(n.t)}ms`;
    setPropsEnabled(true);

    propTime.value = Math.round(n.t);
    propLane.value = n.lane+1;
    propType.value = n.type;
    propEnd.value = Math.round(n.end ?? n.t);
    hsVol.value = String(n.vol ?? 0);
    hsFlags.value = String(n.hs ?? 0);

    // button highlight
    const hs = n.hs ?? 0;
    hsWhistle.classList.toggle("active", (hs & 2) !== 0);
    hsFinish.classList.toggle("active", (hs & 4) !== 0);
    hsClap.classList.toggle("active", (hs & 8) !== 0);
  }

  function applyProps(){
    const n = getSelectedOne();
    if(!n) return;

    pushUndo();

    const tRaw = Number(propTime.value)||0;
    const laneRaw = (Number(propLane.value)||1) - 1;
    const lane = clamp(laneRaw, 0, state.keys-1);
    const type = propType.value === "hold" ? "hold" : "tap";

    n.lane = lane;
    n.t = state.snapOn ? quantizeAt(tRaw) : tRaw;

    if(type === "tap"){
      n.type = "tap";
      n.end = n.t;
    } else {
      const endRaw = Number(propEnd.value)||n.t;
      const endQ = state.snapOn ? quantizeAt(endRaw) : endRaw;
      n.type = "hold";
      n.end = Math.max(n.t + 1, endQ);
    }

    n.vol = clamp(Number(hsVol.value)||0, 0, 100);
    n.hs = clamp(Number(hsFlags.value)||0, 0, 14);

    sortNotes();
    updateSelectionUI();
  }

  function toggleHs(bit){
    const n = getSelectedOne();
    if(!n) return;
    pushUndo();
    n.hs = (n.hs ?? 0) ^ bit;
    hsFlags.value = String(n.hs);
    updateSelectionUI();
  }

  // ---------- Hit testing ----------
  function findNoteAt(mx, my){
    const lw = laneW();
    const lane = laneFromX(mx);
    const x0 = xFromLane(lane);

    for(let i=state.notes.length-1;i>=0;i--){
      const n = state.notes[i];
      if(n.lane !== lane) continue;

      const y = yFromTime(n.t);
      const pad = 7;
      const rectW = lw - pad*2;
      const rectH = 12;

      // head
      const rx = x0+pad, ry = y-rectH/2, rw = rectW, rh=rectH;
      if(mx>=rx && mx<=rx+rw && my>=ry && my<=ry+rh) return n;

      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);
        const barX = x0 + lw/2 - 3;
        if(mx>=barX-7 && mx<=barX+13 && my>=top-7 && my<=bot+7) return n;
      }
    }
    return null;
  }

  // ---------- Breaks ----------
  function setBreakStatus(){
    if(!state.breakArming){
      brkStatus.textContent = "—";
      return;
    }
    if(state.breakStart == null){
      brkStatus.textContent = "click p/ start";
    } else {
      brkStatus.textContent = `start ${Math.round(state.breakStart)}ms`;
    }
  }

  function toggleBreakMode(){
    state.breakArming = !state.breakArming;
    state.breakStart = null;
    breakBtn.classList.toggle("active", state.breakArming);
    setBreakStatus();
  }

  function commitBreakAt(ms){
    if(!state.breakArming) return;

    if(state.breakStart == null){
      state.breakStart = ms;
      setBreakStatus();
      return;
    }
    const a = Math.round(Math.min(state.breakStart, ms));
    const b = Math.round(Math.max(state.breakStart, ms));
    if(b - a < 10){
      // too short -> cancel
      state.breakStart = null;
      setBreakStatus();
      return;
    }
    pushUndo();
    state.breaks.push({ id: uid(), start:a, end:b });
    state.breaks.sort((x,y)=>x.start-y.start);
    state.breakStart = null;
    setBreakStatus();
    renderBreakList();
  }

  function renderBreakList(){
    if(state.breaks.length === 0){
      breakList.innerHTML = `<div class="item"><span>—</span><span class="mono">sem breaks</span></div>`;
      return;
    }
    breakList.innerHTML = state.breaks.map(b => {
      return `<div class="item" data-id="${b.id}">
        <span><b class="mono">${b.start}</b> → <b class="mono">${b.end}</b></span>
        <span class="mono" style="opacity:.9">del</span>
      </div>`;
    }).join("");

    breakList.querySelectorAll(".item").forEach(el => {
      el.addEventListener("click", () => {
        const id = el.getAttribute("data-id");
        pushUndo();
        state.breaks = state.breaks.filter(b => b.id !== id);
        renderBreakList();
      });
    });
  }

  // ---------- Timing list ----------
  function renderTPList(){
    normalizeTiming();
    tpList.innerHTML = state.timing.map(tp => {
      return `<div class="item" data-id="${tp.id}" style="cursor:default">
        <span><b class="mono">${Math.round(tp.t)}ms</b> • <span class="mono">${tp.bpm.toFixed(3)} BPM</span></span>
        <span style="display:flex; gap:8px; align-items:center">
          <input class="mono" data-k="t" type="number" step="1" value="${Math.round(tp.t)}" style="width:110px">
          <input class="mono" data-k="bpm" type="number" step="0.001" value="${tp.bpm}" style="width:110px">
          <span class="mono" style="opacity:.9; cursor:pointer" data-act="del">x</span>
        </span>
      </div>`;
    }).join("");

    tpList.querySelectorAll(".item").forEach(row => {
      const id = row.getAttribute("data-id");
      const tp = state.timing.find(x => x.id === id);
      if(!tp) return;

      const tIn = row.querySelector('input[data-k="t"]');
      const bpmIn = row.querySelector('input[data-k="bpm"]');
      const del = row.querySelector('[data-act="del"]');

      tIn.addEventListener("change", ()=>{
        pushUndo();
        tp.t = Math.max(0, Math.round(Number(tIn.value)||0));
        normalizeTiming();
        renderTPList();
      });
      bpmIn.addEventListener("change", ()=>{
        pushUndo();
        tp.bpm = clamp(Number(bpmIn.value)||180, 30, 400);
        normalizeTiming();
        renderTPList();
      });
      del.addEventListener("click", ()=>{
        if(state.timing.length <= 1) return;
        pushUndo();
        state.timing = state.timing.filter(x => x.id !== id);
        normalizeTiming();
        renderTPList();
      });
    });
  }

  // ---------- Export .osu ----------
  function getMeta(){
    return {
      title: mTitle.value || "WebManiaEditor",
      artist: mArtist.value || "Unknown",
      creator: mCreator.value || "reze",
      version: mVersion.value || "Easy"
    };
  }
  function setMeta(m){
    mTitle.value = m.title ?? mTitle.value;
    mArtist.value = m.artist ?? mArtist.value;
    mCreator.value = m.creator ?? mCreator.value;
    mVersion.value = m.version ?? mVersion.value;
  }

  function laneToOsuX(lane){
    const x = Math.floor((lane + 0.5) * 512 / state.keys);
    return clamp(x, 0, 511);
  }

  function exportOsu(){
    if(!state.buffer) return;
    normalizeTiming();
    sortNotes();

    const meta = getMeta();
    const audioName = (audioFile.files[0]?.name || "audio.mp3").replaceAll("\\","/");
    const keys = state.keys;

    const header =
`osu file format v14

[General]
AudioFilename: ${audioName}
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
SpecialStyle: 0
WidescreenStoryboard: 0

[Editor]
BeatDivisor: ${state.snap}
GridSize: 4
TimelineZoom: 1.0

[Metadata]
Title:${meta.title}
Artist:${meta.artist}
Creator:${meta.creator}
Version:${keys}K ${meta.version}
Source:
Tags:

[Difficulty]
HPDrainRate:5
CircleSize:${keys}
OverallDifficulty:8
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events
`;

    const events = state.breaks
      .slice()
      .sort((a,b)=>a.start-b.start)
      .map(b => `2,${Math.round(b.start)},${Math.round(b.end)}`)
      .join("\n");

    const timingHeader = `

[TimingPoints]
`;
    const tps = state.timing
      .slice()
      .sort((a,b)=>a.t-b.t)
      .map(tp => {
        const beatLen = (60000 / tp.bpm);
        return `${Math.round(tp.t)},${beatLen.toFixed(15)},${tp.meter||4},2,0,100,1,0`;
      }).join("\n");

    const hitHeader = `

[HitObjects]
`;

    const hitLines = state.notes.map(n => {
      const x = laneToOsuX(n.lane);
      const y = 192;
      const t = Math.round(n.t);
      const hs = n.hs ?? 0;
      const vol = clamp(n.vol ?? 0, 0, 100);
      const sample = `0:0:0:${vol}:`;

      if(n.type === "tap"){
        return `${x},${y},${t},1,${hs},${sample}`;
      } else {
        const end = Math.max(t+1, Math.round(n.end));
        return `${x},${y},${t},128,${hs},${end}:${sample}`;
      }
    }).join("\n");

    const out = header + (events ? events + "\n" : "") + timingHeader + tps + hitHeader + hitLines + "\n";
    const blob = new Blob([out], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${meta.title} - ${meta.artist} (${meta.creator}) [${keys}K ${meta.version}].osu`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // ---------- Rendering ----------
  function fmtTime(ms){
    ms = Math.max(0, Math.floor(ms));
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const t = ms % 1000;
    const mm = String(m).padStart(2,"0");
    const ss = String(s).padStart(2,"0");
    const tt = String(t).padStart(3,"0");
    return `${mm}:${ss}:${tt}`;
  }

  function drawStage(){
    const w = SW(), h = SH();
    sctx.clearRect(0,0,w,h);

    // bg image
    if(state.bgImg){
      sctx.globalAlpha = state.bgOpacity;
      const img = state.bgImg;
      // cover
      const scale = Math.max(w/img.width, h/img.height);
      const iw = img.width*scale, ih = img.height*scale;
      const ix = (w-iw)/2, iy=(h-ih)/2;
      sctx.drawImage(img, ix, iy, iw, ih);
      sctx.globalAlpha = 1;
    } else {
      sctx.fillStyle = "#07090d";
      sctx.fillRect(0,0,w,h);
    }

    // lanes background
    const lw = laneW();
    for(let i=0;i<state.keys;i++){
      sctx.fillStyle = `rgba(255,255,255,${state.laneOpacity})`;
      sctx.fillRect(i*lw, 0, lw-1, h);
      sctx.fillStyle = "rgba(255,255,255,.08)";
      sctx.fillRect(i*lw, 0, 1, h);
    }
    sctx.fillStyle = "rgba(255,255,255,.12)";
    sctx.fillRect(w-1,0,1,h);

    // grid lines (per timing segments)
    const viewMs = h / pxPerMs();
    const tMin = state.timeMs - viewMs*0.65;
    const tMax = state.timeMs + viewMs*0.45;

    normalizeTiming();
    const tps = state.timing.slice();

    for(let i=0;i<tps.length;i++){
      const tp = tps[i];
      const next = tps[i+1];
      const segStart = Math.max(tMin, tp.t);
      const segEnd = Math.min(tMax, next ? next.t : Infinity);
      if(segEnd <= segStart) continue;

      const beatLen = 60000 / tp.bpm;
      const meter = tp.meter || 4;
      const step = beatLen / state.snap;

      // first tick
      const base = tp.t;
      const n0 = Math.ceil((segStart - base) / step);
      for(let t = base + n0*step; t <= segEnd; t += step){
        const y = yFromTime(t);
        if(y < -50 || y > h+50) continue;

        const rel = t - base;
        const beatIndex = Math.round(rel / beatLen);
        const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
        const isBar = isBeat && (beatIndex % meter === 0);

        const a = isBar ? 0.22 : isBeat ? 0.14 : 0.08;
        sctx.strokeStyle = `rgba(255,255,255,${a})`;
        sctx.lineWidth = isBar ? 1.8 : isBeat ? 1.2 : 1;
        sctx.beginPath();
        sctx.moveTo(0,y);
        sctx.lineTo(w,y);
        sctx.stroke();
      }
    }

    // playhead
    sctx.strokeStyle = "rgba(125,211,252,.92)";
    sctx.lineWidth = 2;
    sctx.beginPath();
    sctx.moveTo(0, centerY());
    sctx.lineTo(w, centerY());
    sctx.stroke();

    // draw breaks region overlay (optional subtle)
    if(state.breaks.length){
      sctx.globalAlpha = 0.10;
      sctx.fillStyle = "rgba(134,239,172,1)";
      for(const b of state.breaks){
        const y1 = yFromTime(b.start);
        const y2 = yFromTime(b.end);
        const top = Math.min(y1,y2);
        const bot = Math.max(y1,y2);
        if(bot < -50 || top > h+50) continue;
        sctx.fillRect(0, top, w, bot-top);
      }
      sctx.globalAlpha = 1;
    }

    // notes
    for(const n of state.notes){
      const y = yFromTime(n.t);
      if(y < -140 || y > h+140) continue;

      const x0 = xFromLane(n.lane);
      const pad = 7;
      const rectW = lw - pad*2;
      const rectH = 12;
      const isSel = state.selected.has(n.id);

      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);
        sctx.fillStyle = isSel ? "rgba(167,139,250,.40)" : "rgba(255,255,255,.16)";
        sctx.fillRect(x0 + lw/2 - 3, top, 6, bot-top);

        sctx.fillStyle = isSel ? "rgba(167,139,250,.92)" : "rgba(255,255,255,.72)";
        sctx.fillRect(x0 + pad, y2 - rectH/2, rectW, rectH);
      }

      sctx.fillStyle = isSel ? "rgba(125,211,252,.95)" : "rgba(255,255,255,.78)";
      sctx.fillRect(x0 + pad, y - rectH/2, rectW, rectH);

      if(isSel){
        sctx.strokeStyle = "rgba(125,211,252,.95)";
        sctx.lineWidth = 1.2;
        sctx.strokeRect(x0 + pad, y - rectH/2, rectW, rectH);
      }
    }

    // box select overlay
    if(state.drag.mode === "box" && state.drag.box){
      const b = rectNorm(state.drag.box);
      sctx.fillStyle = "rgba(125,211,252,.12)";
      sctx.strokeStyle = "rgba(125,211,252,.72)";
      sctx.lineWidth = 1.4;
      sctx.fillRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
      sctx.strokeRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
    }
  }

  function rectNorm(box){
    return {
      x0: Math.min(box.x0, box.x1),
      y0: Math.min(box.y0, box.y1),
      x1: Math.max(box.x0, box.x1),
      y1: Math.max(box.y0, box.y1),
    };
  }

  // Timeline window around playhead
  function tlRange(){
    const half = (state.tlWinSec*1000)/2;
    return { start: state.timeMs - half, end: state.timeMs + half };
  }
  function xFromTime(ms){
    const {start,end} = tlRange();
    const w = TW();
    const t = (ms - start) / (end - start);
    return t * w;
  }
  function timeFromX(x){
    const {start,end} = tlRange();
    const w = TW();
    const t = x / w;
    return start + t*(end-start);
  }

  function drawTimeline(){
    const w = TW(), h = TH();
    tctx.clearRect(0,0,w,h);
    tctx.fillStyle = "#07090d";
    tctx.fillRect(0,0,w,h);

    const {start,end} = tlRange();

    // waveform
    if(state.wf.ready){
      tctx.globalAlpha = 0.35;
      tctx.strokeStyle = "rgba(125,211,252,.85)";
      tctx.lineWidth = 1;
      tctx.beginPath();
      const mid = h*0.5;
      for(let x=0; x<=w; x+=2){
        const ms = timeFromX(x);
        const a = ampAtMs(ms);
        const amp = a*(h*0.42);
        tctx.moveTo(x, mid-amp);
        tctx.lineTo(x, mid+amp);
      }
      tctx.stroke();
      tctx.globalAlpha = 1;
    }

    // breaks overlay
    if(state.breaks.length){
      tctx.globalAlpha = 0.10;
      tctx.fillStyle = "rgba(134,239,172,1)";
      for(const b of state.breaks){
        if(b.end < start || b.start > end) continue;
        const x1 = xFromTime(b.start);
        const x2 = xFromTime(b.end);
        tctx.fillRect(Math.min(x1,x2), 0, Math.abs(x2-x1), h);
      }
      tctx.globalAlpha = 1;
    }

    // beat lines (active TP only for simplicity here)
    const tp = activeTP(state.timeMs);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const base = tp.t;

    const n0 = Math.ceil((start - base) / step);
    for(let t = base + n0*step; t <= end; t += step){
      const x = xFromTime(t);
      const rel = t - base;
      const beatIndex = Math.round(rel / beatLen);
      const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
      const isBar = isBeat && (beatIndex % (tp.meter||4) === 0);
      const a = isBar ? .22 : isBeat ? .14 : .08;

      tctx.strokeStyle = `rgba(255,255,255,${a})`;
      tctx.lineWidth = isBar ? 1.6 : isBeat ? 1.1 : 1;
      tctx.beginPath();
      tctx.moveTo(x,0);
      tctx.lineTo(x,h);
      tctx.stroke();
    }

    // notes markers per lane
    const laneH = h / state.keys;
    for(const n of state.notes){
      if(n.t < start || n.t > end) continue;
      const x = xFromTime(n.t);
      const y = (n.lane + 0.5)*laneH;

      tctx.fillStyle = state.selected.has(n.id) ? "rgba(167,139,250,.90)" : "rgba(255,255,255,.75)";
      tctx.fillRect(x-2, y-6, 4, 12);

      if(n.type === "hold"){
        const x2 = xFromTime(n.end);
        tctx.fillStyle = state.selected.has(n.id) ? "rgba(167,139,250,.35)" : "rgba(255,255,255,.18)";
        tctx.fillRect(Math.min(x,x2), y-2, Math.abs(x2-x), 4);
      }
    }

    // playhead
    const xPH = xFromTime(state.timeMs);
    tctx.strokeStyle = "rgba(125,211,252,.95)";
    tctx.lineWidth = 2;
    tctx.beginPath();
    tctx.moveTo(xPH,0);
    tctx.lineTo(xPH,h);
    tctx.stroke();
  }

  // Minimap: whole song waveform + note density + playhead
  function drawMinimap(){
    const w = MW(), h = MH();
    mctx.clearRect(0,0,w,h);
    mctx.fillStyle = "#07090d";
    mctx.fillRect(0,0,w,h);

    if(!state.buffer || !state.wf.ready){
      mctx.fillStyle = "rgba(255,255,255,.10)";
      mctx.fillRect(0,0,w,h);
      return;
    }

    const durMs = state.buffer.duration*1000;

    // waveform vertical strip
    mctx.globalAlpha = 0.35;
    mctx.strokeStyle = "rgba(125,211,252,.85)";
    mctx.lineWidth = 1;
    mctx.beginPath();

    for(let y=0; y<=h; y+=2){
      const ms = (y/h)*durMs;
      const a = ampAtMs(ms);
      const x = (w*0.5) + a*(w*0.45);
      if(y===0) mctx.moveTo(x,y);
      else mctx.lineTo(x,y);
    }
    mctx.stroke();
    mctx.globalAlpha = 1;

    // breaks overlay
    if(state.breaks.length){
      mctx.globalAlpha = 0.10;
      mctx.fillStyle = "rgba(134,239,172,1)";
      for(const b of state.breaks){
        const y1 = (b.start/durMs)*h;
        const y2 = (b.end/durMs)*h;
        mctx.fillRect(0, Math.min(y1,y2), w, Math.abs(y2-y1));
      }
      mctx.globalAlpha = 1;
    }

    // density of notes (simple)
    mctx.globalAlpha = 0.18;
    mctx.fillStyle = "rgba(255,255,255,1)";
    const bins = 140;
    const binMs = durMs / bins;
    const counts = new Array(bins).fill(0);
    for(const n of state.notes){
      const idx = clamp(Math.floor(n.t / binMs), 0, bins-1);
      counts[idx]++;
    }
    const maxC = Math.max(1, ...counts);
    for(let i=0;i<bins;i++){
      const y0 = (i/bins)*h;
      const y1 = ((i+1)/bins)*h;
      const ww = (counts[i]/maxC) * (w*0.35);
      mctx.fillRect(0, y0, ww, y1-y0);
    }
    mctx.globalAlpha = 1;

    // playhead
    const py = (state.timeMs/durMs)*h;
    mctx.strokeStyle = "rgba(125,211,252,.95)";
    mctx.lineWidth = 2;
    mctx.beginPath();
    mctx.moveTo(0, py);
    mctx.lineTo(w, py);
    mctx.stroke();
  }

  // ---------- Input handling ----------
  function setTool(tool){
    state.tool = tool;
    tools.forEach(b => b.classList.toggle("active", b.getAttribute("data-tool") === tool));
    pillTool.textContent = tool[0].toUpperCase()+tool.slice(1);
  }

  function setTab(tab){
    state.tab = tab;
    tabs.forEach(t => t.classList.toggle("active", t.getAttribute("data-tab")===tab));

    // (layout já está sempre visível; tab é mais “estado” por enquanto)
    // Você pode depois esconder/mostrar painéis por tab se quiser.
  }

  function setKeys(k){
    state.keys = clamp(k,4,7);
    pillKeys.textContent = String(state.keys);
    // clamp lanes
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);
    updateSelectionUI();
  }

  function setSnapByIndex(idx){
    idx = clamp(idx,0,SNAP_OPTS.length-1);
    state.snap = SNAP_OPTS[idx];
    const label = `1/${state.snap}`;
    snapLabel.textContent = label;
    pillSnap.textContent = label;
    hudSnap.textContent = label;
    state.snapOn = (snapOnSel.value === "on");
  }

  function setSnapOn(on){
    state.snapOn = on;
    hudSnapOn.textContent = on ? "(on)" : "(off)";
  }

  function mousePos(e, wrap){
    const r = wrap.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function selectByBox(box, additive=false){
    const b = rectNorm(box);
    const tA = state.snapOn ? quantizeAt(timeFromY(b.y1)) : timeFromY(b.y1);
    const tB = state.snapOn ? quantizeAt(timeFromY(b.y0)) : timeFromY(b.y0);
    const tMin = Math.min(tA,tB), tMax = Math.max(tA,tB);

    const laneMin = laneFromX(b.x0);
    const laneMax = laneFromX(b.x1);

    if(!additive) state.selected.clear();

    for(const n of state.notes){
      if(n.lane < laneMin || n.lane > laneMax) continue;
      if(n.type === "tap"){
        if(n.t >= tMin && n.t <= tMax) state.selected.add(n.id);
      } else {
        if(!(n.end < tMin || n.t > tMax)) state.selected.add(n.id);
      }
    }
    updateSelectionUI();
  }

  function beginMoveSelection(){
    const snap = new Map();
    for(const n of state.notes){
      if(state.selected.has(n.id)){
        snap.set(n.id, { t:n.t, end:n.end, lane:n.lane });
      }
    }
    state.drag.moveSnap = snap;
  }

  function applyMoveSelection(deltaLane, deltaMs){
    const snap = state.drag.moveSnap;
    if(!snap) return;

    for(const n of state.notes){
      if(!state.selected.has(n.id)) continue;
      const base = snap.get(n.id);
      if(!base) continue;

      const lane = clamp(base.lane + deltaLane, 0, state.keys-1);
      let t = base.t + deltaMs;
      t = state.snapOn ? quantizeAt(t) : t;

      n.lane = lane;
      n.t = t;

      if(n.type === "hold"){
        let end = base.end + deltaMs;
        end = state.snapOn ? quantizeAt(end) : end;
        n.end = Math.max(n.t + 1, end);
      } else {
        n.end = n.t;
      }
    }
    sortNotes();
    updateSelectionUI();
  }

  // Stage interactions
  stageWrap.addEventListener("wheel", (e)=>{
    e.preventDefault();
    if(!state.buffer) return;
    seekMs(state.timeMs + e.deltaY * 2.2);
  }, {passive:false});

  stageWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    const m = mousePos(e, stageWrap);
    state.drag.down = true;
    state.drag.x0 = m.x; state.drag.y0 = m.y;

    // if break mode armed: clicking stage commits break start/end at current playhead
    if(state.breakArming){
      commitBreakAt(state.timeMs);
      return;
    }

    const hit = findNoteAt(m.x, m.y);
    const additive = e.ctrlKey || e.metaKey;

    if(state.tool === "select"){
      if(hit){
        if(additive){
          if(state.selected.has(hit.id)) state.selected.delete(hit.id);
          else state.selected.add(hit.id);
        } else {
          if(!state.selected.has(hit.id)){
            state.selected.clear();
            state.selected.add(hit.id);
          }
        }
        updateSelectionUI();

        // start move
        state.drag.mode = "move";
        beginMoveSelection();
      } else {
        // start box
        state.drag.mode = "box";
        state.drag.box = { x0:m.x, y0:m.y, x1:m.x, y1:m.y };
        if(!additive) state.selected.clear();
        updateSelectionUI();
      }
      return;
    }

    if(state.tool === "erase"){
      if(hit){
        pushUndo();
        state.notes = state.notes.filter(n => n.id !== hit.id);
        state.selected.delete(hit.id);
        updateSelectionUI();
      }
      return;
    }

    if(state.tool === "tap"){
      const lane = laneFromX(m.x);
      const tRaw = timeFromY(m.y);
      const t = state.snapOn ? quantizeAt(tRaw) : tRaw;
      addNote({ id: uid(), lane, t, type:"tap", end:t, hs:0, vol:0 });
      return;
    }

    if(state.tool === "hold"){
      const lane = laneFromX(m.x);
      const t0Raw = timeFromY(m.y);
      const t0 = state.snapOn ? quantizeAt(t0Raw) : t0Raw;
      const id = uid();
      addNote({ id, lane, t:t0, type:"hold", end:t0 + snapMsAt(t0), hs:0, vol:0 });
      state.drag.mode = "holdCreate";
      state.drag.holdId = id;
      return;
    }
  });

  stageWrap.addEventListener("mousemove", (e)=>{
    if(!state.drag.down) return;
    const m = mousePos(e, stageWrap);

    if(state.tool === "select" && state.drag.mode === "box" && state.drag.box){
      state.drag.box.x1 = m.x;
      state.drag.box.y1 = m.y;
      selectByBox(state.drag.box, e.ctrlKey || e.metaKey);
      return;
    }

    if(state.tool === "select" && state.drag.mode === "move"){
      const dxLane = laneFromX(m.x) - laneFromX(state.drag.x0);
      const dMsRaw = (state.snapOn ? quantizeAt(timeFromY(m.y)) : timeFromY(m.y))
                   - (state.snapOn ? quantizeAt(timeFromY(state.drag.y0)) : timeFromY(state.drag.y0));
      applyMoveSelection(dxLane, dMsRaw);
      return;
    }

    if(state.tool === "hold" && state.drag.mode === "holdCreate"){
      const id = state.drag.holdId;
      const n = state.notes.find(x => x.id === id);
      if(!n) return;
      const endRaw = timeFromY(m.y);
      const end = state.snapOn ? quantizeAt(endRaw) : endRaw;
      n.end = Math.max(n.t + 1, end);
      updateSelectionUI();
      return;
    }
  });

  window.addEventListener("mouseup", ()=>{
    if(state.drag.down){
      if(state.drag.mode === "move" || state.drag.mode === "holdCreate" || state.drag.mode === "box"){
        // commit drag
        pushUndo();
      }
    }
    state.drag.down=false;
    state.drag.mode="none";
    state.drag.box=null;
    state.drag.moveSnap=null;
    state.drag.holdId=null;
  });

  // Timeline interactions
  function timelineSeekAtX(x){
    seekMs(timeFromX(x));
  }

  timelineWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    state.tlDrag = true;
    const m = mousePos(e, timelineWrap);
    timelineSeekAtX(m.x);
  });
  window.addEventListener("mousemove", (e)=>{
    if(!state.tlDrag) return;
    const m = mousePos(e, timelineWrap);
    timelineSeekAtX(m.x);
  });
  window.addEventListener("mouseup", ()=> state.tlDrag=false);

  // Minimap click seek
  miniCanvas.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    const r = miniCanvas.getBoundingClientRect();
    const y = e.clientY - r.top;
    const durMs = state.buffer.duration*1000;
    seekMs((y / r.height) * durMs);
  });

  // ---------- Recording ----------
  function normalizeKey(e){
    if(e.code === "Space") return "space";
    return (e.key || "").toLowerCase();
  }

  function recKeyDown(e){
    if(!state.rec.on) return;
    if(!state.isPlaying) return;
    if(e.repeat) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;

    const key = normalizeKey(e);
    const binds = state.rec.bindsByKeys[state.keys];
    const lane = binds.indexOf(key);
    if(lane < 0) return;

    if(state.rec.downMap.has(key)) return;

    pushUndo();

    const ms = state.timeMs;
    const t = state.rec.quantize ? quantizeAt(ms) : ms;

    const id = uid();
    const note = { id, lane, t, type:"hold", end: t + snapMsAt(t), hs:0, vol:0 };
    state.notes.push(note);
    sortNotes();

    state.rec.downMap.set(key, { noteId:id });
    state.selected.clear();
    state.selected.add(id);
    updateSelectionUI();

    e.preventDefault();
  }

  function recKeyUp(e){
    if(!state.rec.on) return;
    const key = normalizeKey(e);
    const info = state.rec.downMap.get(key);
    if(!info) return;

    const n = state.notes.find(x => x.id === info.noteId);
    state.rec.downMap.delete(key);
    if(!n) return;

    const ms = state.timeMs;
    const end = state.rec.quantize ? quantizeAt(ms) : ms;
    const minHold = snapMsAt(n.t) * 0.6;

    if(end - n.t < minHold){
      n.type = "tap";
      n.end = n.t;
    } else {
      n.type = "hold";
      n.end = Math.max(n.t + 1, end);
    }
    sortNotes();
    updateSelectionUI();
    e.preventDefault();
  }

  window.addEventListener("keydown", (e)=>{
    // shortcuts
    if(e.code === "Space"){
      e.preventDefault();
      if(state.isPlaying) pause(); else play();
      return;
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="z"){
      e.preventDefault();
      doUndo();
      return;
    }
    if(e.code === "Delete"){
      deleteSelection();
      return;
    }
    if(e.key === "1") setTool("select");
    if(e.key === "2") setTool("tap");
    if(e.key === "3") setTool("hold");
    if(e.key === "4") setTool("erase");

    // record
    recKeyDown(e);
  });
  window.addEventListener("keyup", (e)=> recKeyUp(e));

  // ---------- UI wiring ----------
  tabs.forEach(t => t.addEventListener("click", ()=> setTab(t.getAttribute("data-tab"))));
  tools.forEach(b => b.addEventListener("click", ()=> setTool(b.getAttribute("data-tool"))));

  audioFile.addEventListener("change", async ()=>{
    const f = audioFile.files[0];
    if(!f) return;
    await loadAudio(f);
  });

  keysSel.addEventListener("change", ()=>{
    pushUndo();
    setKeys(parseInt(keysSel.value,10));
  });

  snapOnSel.addEventListener("change", ()=>{
    pushUndo();
    setSnapOn(snapOnSel.value === "on");
  });

  scrollIn.addEventListener("change", ()=>{
    state.scrollPxPerSec = clamp(parseInt(scrollIn.value,10)||1700, 250, 9000);
  });

  tlWinIn.addEventListener("change", ()=>{
    state.tlWinSec = clamp(parseInt(tlWinIn.value,10)||8, 3, 30);
  });

  snapRange.addEventListener("input", ()=>{
    const idx = parseInt(snapRange.value,10);
    setSnapByIndex(idx);
  });

  breakBtn.addEventListener("click", ()=>{
    toggleBreakMode();
  });

  tpAdd.addEventListener("click", ()=>{
    pushUndo();
    const ms = Math.round(state.timeMs);
    const cur = activeTP(ms);
    state.timing.push({ id: uid(), t: ms, bpm: cur.bpm, meter: cur.meter||4 });
    normalizeTiming();
    renderTPList();
  });

  tpSort.addEventListener("click", ()=>{
    pushUndo();
    normalizeTiming();
    renderTPList();
  });

  tpReset.addEventListener("click", ()=>{
    pushUndo();
    state.timing = [{ id: uid(), t:0, bpm:180, meter:4 }];
    renderTPList();
  });

  exportBtn.addEventListener("click", exportOsu);
  undoBtn.addEventListener("click", doUndo);
  deleteBtn.addEventListener("click", deleteSelection);
  clearNotesBtn.addEventListener("click", clearNotes);

  // props
  [propTime, propLane, propType, propEnd, hsVol, hsFlags].forEach(el=>{
    el.addEventListener("change", applyProps);
  });
  hsWhistle.addEventListener("click", ()=> toggleHs(2));
  hsFinish.addEventListener("click", ()=> toggleHs(4));
  hsClap.addEventListener("click", ()=> toggleHs(8));

  // bg
  bgFile.addEventListener("change", async ()=>{
    const f = bgFile.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{
      state.bgImg = img;
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });
  bgOpacity.addEventListener("change", ()=> state.bgOpacity = clamp(parseFloat(bgOpacity.value)||0.35, 0, 1));
  laneOpacity.addEventListener("change", ()=> state.laneOpacity = clamp(parseFloat(laneOpacity.value)||0.08, 0, 1));

  // rec
  recToggle.addEventListener("change", ()=>{
    state.rec.on = !!recToggle.checked;
  });
  recQuantToggle.addEventListener("change", ()=>{
    state.rec.quantize = !!recQuantToggle.checked;
  });

  // transport
  playBtn.addEventListener("click", ()=> { if(state.isPlaying) pause(); else play(); });
  stopBtn.addEventListener("click", stop);
  volRange.addEventListener("input", ()=>{
    if(state.gain) state.gain.gain.value = parseFloat(volRange.value)||1;
  });
  rateBtns.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      rateBtns.forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      state.rate = parseFloat(btn.getAttribute("data-rate"));
      if(state.isPlaying){
        pause();
        play();
      }
    });
  });

  // ---------- Loop ----------
  function renderHUD(){
    const tp = activeTP(state.timeMs);
    hudTime.textContent = String(Math.round(state.timeMs));
    hudCount.textContent = String(state.notes.length);
    hudTP.textContent = `${tp.bpm.toFixed(3)} @ ${Math.round(tp.t)}ms`;
    hudSnap.textContent = `1/${state.snap}`;
    hudSnapOn.textContent = state.snapOn ? "(on)" : "(off)";

    pillKeys.textContent = String(state.keys);
    pillSnap.textContent = `1/${state.snap}`;

    tlWin.textContent = String(state.tlWinSec);

    noteStr.textContent = `notes: ${state.notes.length}`;
    timeStr.textContent = fmtTime(state.timeMs);

    if(state.buffer){
      const pct = (state.timeMs / (state.buffer.duration*1000)) * 100;
      pctStr.textContent = `${pct.toFixed(1)}%`;
    } else {
      pctStr.textContent = "0.0%";
    }
  }

  function loop(){
    updateTimeFromAudio();
    renderHUD();

    drawStage();
    drawTimeline();
    drawMinimap();

    requestAnimationFrame(loop);
  }

  // ---------- Init ----------
  setTab("compose");
  setTool("select");
  setKeys(4);

  // snap default index for 1/4
  snapRange.value = String(SNAP_OPTS.indexOf(4));
  setSnapByIndex(SNAP_OPTS.indexOf(4));

  setSnapOn(true);
  renderTPList();
  renderBreakList();
  setBreakStatus();
  updateSelectionUI();

  // disable buttons until audio loaded
  exportBtn.disabled = true;
  undoBtn.disabled = true;
  deleteBtn.disabled = true;
  clearNotesBtn.disabled = true;
  breakBtn.disabled = true;
  tpAdd.disabled = true;
  tpSort.disabled = true;
  tpReset.disabled = true;

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mania Mapper (Quaver-like)</title>
  <style>
    :root{
      --bg:#0b0d12;
      --panel:#101522;
      --panel2:#0e1320;
      --fg:#e9eefc;
      --muted:#97a3c2;
      --accent:#7aa2ff;
      --accent2:#7affc7;
      --danger:#ff5d7a;
      --border:rgba(255,255,255,.08);
      --shadow:rgba(0,0,0,.45);
      --r:12px;
      --gap:12px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 70% -10%, rgba(122,162,255,.18), transparent 55%),
                  radial-gradient(900px 700px at 10% 10%, rgba(122,255,199,.12), transparent 55%),
                  var(--bg);
      color:var(--fg);
      font-family:var(--font);
      overflow:hidden;
    }

    .app{
      display:grid;
      grid-template-columns: 360px 1fr 420px;
      gap:var(--gap);
      padding:var(--gap);
      height:100vh;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border:1px solid var(--border);
      border-radius:var(--r);
      box-shadow: 0 12px 40px var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }

    .card h2{
      margin:0;
      padding:14px 16px;
      font-size:14px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color:var(--muted);
      border-bottom:1px solid var(--border);
      background: rgba(255,255,255,.02);
    }

    .pad{ padding:14px 16px; }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row > *{ flex: 1; min-width: 0; }

    label{
      font-size:12px;
      color:var(--muted);
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    input[type="text"], input[type="number"], select{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.25);
      color:var(--fg);
      outline:none;
    }

    input[type="range"]{
      width:100%;
    }

    button{
      border:1px solid var(--border);
      background: rgba(255,255,255,.05);
      color:var(--fg);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease;
      font-weight:600;
    }
    button:hover{ background: rgba(255,255,255,.08); }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: linear-gradient(180deg, rgba(122,162,255,.22), rgba(122,162,255,.10));
      border-color: rgba(122,162,255,.35);
    }
    button.danger{
      background: linear-gradient(180deg, rgba(255,93,122,.22), rgba(255,93,122,.10));
      border-color: rgba(255,93,122,.35);
    }

    .tiny{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    .split{
      display:grid;
      grid-template-rows: 1fr auto;
      min-height:0;
    }

    .canvasWrap{
      position:relative;
      min-height:0;
      height:100%;
      background: rgba(0,0,0,.22);
      border-top:1px solid var(--border);
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .hud{
      position:absolute;
      left:10px;
      top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      pointer-events:none;
    }
    .pill{
      pointer-events:none;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.35);
      color:var(--fg);
      backdrop-filter: blur(8px);
    }
    .pill b{ color:var(--accent2); font-weight:800; }

    .timelineInfo{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:12px;
      color:var(--muted);
      margin-top:8px;
    }

    .kbd{
      font-size:12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,.06);
      padding:2px 7px;
      border-radius:8px;
      color:var(--fg);
      display:inline-block;
    }

    .list{
      border-top:1px solid var(--border);
      max-height: 220px;
      overflow:auto;
    }
    .noteItem{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:12px;
      color:var(--muted);
    }
    .noteItem b{ color:var(--fg); }
    .noteItem button{
      padding:6px 8px;
      border-radius:9px;
      font-size:12px;
    }

    textarea{
      width:100%;
      min-height: 160px;
      resize:vertical;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.22);
      color:var(--fg);
      outline:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px;
    }

    .divider{
      height:1px;
      background: var(--border);
      margin:12px 0;
    }
  </style>
</head>
<body>
  <div class="app">

    <!-- LEFT: SETTINGS -->
    <section class="card">
      <h2>Config</h2>
      <div class="pad" style="display:flex; flex-direction:column; gap:12px; min-height:0;">
        <div class="row">
          <label>
            Keymode
            <select id="keymode">
              <option value="4">4K</option>
              <option value="6">6K</option>
              <option value="7">7K</option>
            </select>
          </label>
          <label>
            Snap
            <select id="snap">
              <option value="0">Livre</option>
              <option value="1">1/1</option>
              <option value="2">1/2</option>
              <option value="4" selected>1/4</option>
              <option value="8">1/8</option>
              <option value="16">1/16</option>
            </select>
          </label>
        </div>

        <div class="row">
          <label>
            BPM
            <input id="bpm" type="number" value="180" min="1" step="1" />
          </label>
          <label>
            Offset (ms)
            <input id="offset" type="number" value="0" step="1" />
          </label>
        </div>

        <div class="row">
          <label>
            Scroll speed
            <input id="scroll" type="range" min="200" max="2400" value="900" />
            <div class="tiny"><span id="scrollVal">900</span> px/s</div>
          </label>
        </div>

        <div class="row">
          <label>
            Volume
            <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9" />
            <div class="tiny"><span id="volVal">0.90</span></div>
          </label>
          <label>
            Playback
            <input id="rate" type="range" min="0.5" max="1.5" step="0.01" value="1" />
            <div class="tiny"><span id="rateVal">1.00</span>x</div>
          </label>
        </div>

        <div class="row">
          <label>
            Carregar áudio
            <input id="audioFile" type="file" accept="audio/*" />
          </label>
        </div>

        <div class="row">
          <button class="primary" id="playBtn">Play</button>
          <button id="stopBtn">Stop</button>
          <button class="danger" id="clearBtn">Limpar notas</button>
        </div>

        <label>
          Seek (ms)
          <input id="seek" type="range" min="0" max="1000" value="0" />
          <div class="timelineInfo">
            <span>t = <b id="timeNow">0</b> ms</span>
            <span>len = <b id="timeLen">0</b> ms</span>
          </div>
        </label>

        <div class="tiny">
          Teclas (padrão):
          <div style="margin-top:6px; display:flex; gap:6px; flex-wrap:wrap;">
            <span class="kbd">D</span><span class="kbd">F</span><span class="kbd">J</span><span class="kbd">K</span>
            <span class="kbd">S</span><span class="kbd">L</span><span class="kbd">;</span>
          </div>
          <div style="margin-top:8px;">
            <span class="kbd">Space</span> Play/Pause • <span class="kbd">Backspace</span> Deletar nota mais próxima •
            <span class="kbd">Ctrl</span> + clique = deletar nota
          </div>
        </div>
      </div>
    </section>

    <!-- CENTER: EDITOR TIMELINE -->
    <section class="card split">
      <h2>Editor (timeline)</h2>
      <div class="canvasWrap">
        <canvas id="editor"></canvas>
        <div class="hud">
          <div class="pill">Modo: <b id="hudMode">Edit</b></div>
          <div class="pill">Notas: <b id="hudNotes">0</b></div>
          <div class="pill">Snap: <b id="hudSnap">1/4</b></div>
        </div>
      </div>

      <div class="pad" style="border-top:1px solid var(--border); display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
        <button id="zoomOut">- Zoom</button>
        <button id="zoomIn">+ Zoom</button>
        <div class="tiny" style="flex:1;">
          Clique para posicionar nota no tempo. Use o mouse para mirar a coluna.
        </div>
      </div>
    </section>

    <!-- RIGHT: GAMEPLAY PREVIEW + IO -->
    <section class="card">
      <h2>Preview + Import/Export</h2>
      <div class="canvasWrap" style="flex:1; min-height:240px;">
        <canvas id="game"></canvas>
        <div class="hud">
          <div class="pill">Hitline</div>
          <div class="pill">Tempo: <b id="hudTime">0</b> ms</div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="pad" style="display:flex; flex-direction:column; gap:10px;">
        <div class="row">
          <button id="exportBtn" class="primary">Export .osu (mania)</button>
          <button id="importBtn">Import .osu</button>
        </div>
        <textarea id="io" spellcheck="false" placeholder="Aqui aparece o .osu exportado (ou cole um .osu para importar)."></textarea>

        <div class="list" id="noteList"></div>
      </div>
    </section>

  </div>

<script>
(() => {
  // --------------------------
  // State
  // --------------------------
  const state = {
    keymode: 4,
    bpm: 180,
    offset: 0,
    snap: 4, // 0 = free
    scroll: 900, // px/s
    rate: 1,
    vol: 0.9,
    playing: false,

    // timeline scaling
    msPerPixel: 2.5, // zoom (smaller => zoom in)
    editorCenterMs: 0, // where center line points
    durationMs: 0,

    // audio
    audioEl: new Audio(),
    audioReady: false,

    // notes: {t, lane} with t in ms (absolute in song time)
    notes: [],
  };

  // key bindings per keymode (simple + comfy)
  const keymaps = {
    4: ["d","f","j","k"],
    6: ["s","d","f","j","k","l"],
    7: ["s","d","f","space","j","k","l"], // center = space (common-ish)
  };

  // --------------------------
  // DOM
  // --------------------------
  const $ = (id) => document.getElementById(id);

  const editor = $("editor");
  const game = $("game");
  const ectx = editor.getContext("2d");
  const gctx = game.getContext("2d");

  const keymodeSel = $("keymode");
  const snapSel = $("snap");
  const bpmInp = $("bpm");
  const offsetInp = $("offset");
  const scrollR = $("scroll");
  const scrollVal = $("scrollVal");
  const volR = $("vol");
  const volVal = $("volVal");
  const rateR = $("rate");
  const rateVal = $("rateVal");

  const audioFile = $("audioFile");
  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const clearBtn = $("clearBtn");

  const seekR = $("seek");
  const timeNow = $("timeNow");
  const timeLen = $("timeLen");

  const hudMode = $("hudMode");
  const hudNotes = $("hudNotes");
  const hudSnap = $("hudSnap");
  const hudTime = $("hudTime");

  const zoomOut = $("zoomOut");
  const zoomIn = $("zoomIn");

  const exportBtn = $("exportBtn");
  const importBtn = $("importBtn");
  const io = $("io");
  const noteList = $("noteList");

  // --------------------------
  // Helpers
  // --------------------------
  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function resizeCanvasToDisplaySize(c){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const rect = c.getBoundingClientRect();
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    if (c.width !== w || c.height !== h){
      c.width = w; c.height = h;
      return true;
    }
    return false;
  }

  function songTimeMs(){
    if (!state.audioReady) return state.editorCenterMs;
    return Math.floor(state.audioEl.currentTime * 1000);
  }

  function setSongTimeMs(ms){
    ms = clamp(ms, 0, state.durationMs || ms);
    state.editorCenterMs = ms;
    if (state.audioReady){
      state.audioEl.currentTime = ms / 1000;
    }
    syncSeekUI();
  }

  function syncSeekUI(){
    const now = songTimeMs();
    timeNow.textContent = now;
    hudTime.textContent = now;
    seekR.value = String(clamp(now, 0, Number(seekR.max || 0)));
  }

  function beatMs(){
    return 60000 / Math.max(1, state.bpm);
  }

  function snapMs(){
    if (state.snap === 0) return 0;
    return beatMs() / state.snap;
  }

  function quantizeMs(ms){
    const s = snapMs();
    if (!s) return ms;
    // apply offset as grid origin (like common mapping)
    const origin = state.offset;
    const rel = ms - origin;
    const q = Math.round(rel / s) * s + origin;
    return Math.max(0, Math.floor(q));
  }

  function laneFromX(x, width){
    const k = state.keymode;
    const laneW = width / k;
    return clamp(Math.floor(x / laneW), 0, k-1);
  }

  function sortNotes(){
    state.notes.sort((a,b) => a.t - b.t || a.lane - b.lane);
  }

  function addNote(t, lane){
    t = Math.floor(t);
    if (state.snap !== 0) t = quantizeMs(t);
    // avoid duplicates same time+lane
    if (state.notes.some(n => n.t === t && n.lane === lane)) return;
    state.notes.push({t, lane});
    sortNotes();
    refreshNoteList();
  }

  function deleteNearestNote(t, laneOrNull = null){
    if (!state.notes.length) return;
    let bestI = -1;
    let bestD = Infinity;
    for (let i=0; i<state.notes.length; i++){
      const n = state.notes[i];
      if (laneOrNull !== null && n.lane !== laneOrNull) continue;
      const d = Math.abs(n.t - t);
      if (d < bestD){
        bestD = d; bestI = i;
      }
    }
    if (bestI >= 0){
      state.notes.splice(bestI, 1);
      refreshNoteList();
    }
  }

  function refreshNoteList(){
    hudNotes.textContent = String(state.notes.length);
    noteList.innerHTML = "";
    const maxShow = 120;
    const slice = state.notes.slice(0, maxShow);
    for (const n of slice){
      const row = document.createElement("div");
      row.className = "noteItem";
      row.innerHTML = `
        <div>t=<b>${n.t}</b> ms • lane=<b>${n.lane+1}</b></div>
        <button data-jump="1">Ir</button>
        <button data-del="1" class="danger">Del</button>
      `;
      row.querySelector("[data-jump]").onclick = () => setSongTimeMs(n.t);
      row.querySelector("[data-del]").onclick = () => { 
        const idx = state.notes.findIndex(x => x.t===n.t && x.lane===n.lane);
        if (idx>=0) state.notes.splice(idx,1);
        refreshNoteList();
      };
      noteList.appendChild(row);
    }
    if (state.notes.length > maxShow){
      const more = document.createElement("div");
      more.className = "noteItem";
      more.innerHTML = `<div>... mostrando ${maxShow} de ${state.notes.length}</div><div></div><div></div>`;
      noteList.appendChild(more);
    }
  }

  function updateHudSnap(){
    hudSnap.textContent = state.snap === 0 ? "Livre" : `1/${state.snap}`;
  }

  // --------------------------
  // Rendering: Editor timeline
  // --------------------------
  function drawEditor(){
    resizeCanvasToDisplaySize(editor);
    const w = editor.width, h = editor.height;

    ectx.clearRect(0,0,w,h);

    // background
    ectx.fillStyle = "rgba(0,0,0,.18)";
    ectx.fillRect(0,0,w,h);

    const k = state.keymode;
    const laneW = w / k;

    // lanes
    for (let i=0;i<k;i++){
      const x = i*laneW;
      ectx.fillStyle = i%2===0 ? "rgba(255,255,255,.03)" : "rgba(255,255,255,.02)";
      ectx.fillRect(x,0,laneW,h);
      ectx.strokeStyle = "rgba(255,255,255,.08)";
      ectx.beginPath();
      ectx.moveTo(x,0);
      ectx.lineTo(x,h);
      ectx.stroke();
    }
    // right border
    ectx.strokeStyle="rgba(255,255,255,.10)";
    ectx.beginPath(); ectx.moveTo(w,0); ectx.lineTo(w,h); ectx.stroke();

    // time mapping: center line at h*0.55 (more space ahead)
    const centerY = h * 0.55;
    const centerT = songTimeMs();

    // grid lines (beats)
    const bms = beatMs();
    const s = snapMs();
    const gridStep = state.snap === 0 ? bms : s;

    // pick a reasonable step for rendering density
    let renderStep = gridStep;
    while (renderStep / state.msPerPixel < 16) renderStep *= 2;

    const visibleMs = h * state.msPerPixel;
    const tTop = centerT - centerY*state.msPerPixel;
    const tBot = centerT + (h-centerY)*state.msPerPixel;

    // grid origin
    const origin = state.offset;
    const first = Math.floor((tTop - origin)/renderStep)*renderStep + origin;

    for (let t = first; t <= tBot + renderStep; t += renderStep){
      const y = centerY + (t - centerT) / state.msPerPixel;
      const isBeat = Math.abs(((t - origin) / bms) - Math.round((t - origin) / bms)) < 1e-6;

      ectx.strokeStyle = isBeat ? "rgba(122,162,255,.30)" : "rgba(255,255,255,.08)";
      ectx.lineWidth = isBeat ? 2 : 1;
      ectx.beginPath();
      ectx.moveTo(0, y);
      ectx.lineTo(w, y);
      ectx.stroke();

      // time label occasionally
      if (isBeat){
        ectx.fillStyle = "rgba(151,163,194,.9)";
        ectx.font = `${Math.floor(11*(w/900+0.6))}px ${getComputedStyle(document.body).fontFamily}`;
        ectx.fillText(`${Math.round(t)}ms`, 10, y - 6);
      }
    }

    // notes as rectangles
    const noteH = 10 * (w/900 + 0.7);
    for (const n of state.notes){
      if (n.t < tTop-1000 || n.t > tBot+1000) continue;
      const y = centerY + (n.t - centerT) / state.msPerPixel;
      const x = n.lane * laneW;
      ectx.fillStyle = "rgba(122,255,199,.75)";
      ectx.fillRect(x+3, y - noteH/2, laneW-6, noteH);
      ectx.strokeStyle = "rgba(0,0,0,.35)";
      ectx.strokeRect(x+3, y - noteH/2, laneW-6, noteH);
    }

    // center playhead
    ectx.strokeStyle = "rgba(255,255,255,.55)";
    ectx.lineWidth = 2;
    ectx.beginPath();
    ectx.moveTo(0, centerY);
    ectx.lineTo(w, centerY);
    ectx.stroke();

    // hint text
    ectx.fillStyle = "rgba(233,238,252,.75)";
    ectx.font = `${Math.floor(12*(w/900+0.6))}px ${getComputedStyle(document.body).fontFamily}`;
    ectx.fillText("PLAYHEAD", 10, centerY - 10);
  }

  // --------------------------
  // Rendering: Gameplay preview
  // --------------------------
  function drawGame(){
    resizeCanvasToDisplaySize(game);
    const w = game.width, h = game.height;

    gctx.clearRect(0,0,w,h);
    gctx.fillStyle = "rgba(0,0,0,.18)";
    gctx.fillRect(0,0,w,h);

    const k = state.keymode;
    const laneW = w / k;

    // lanes + borders
    for (let i=0;i<k;i++){
      const x = i*laneW;
      gctx.fillStyle = i%2===0 ? "rgba(255,255,255,.035)" : "rgba(255,255,255,.02)";
      gctx.fillRect(x,0,laneW,h);

      gctx.strokeStyle = "rgba(255,255,255,.09)";
      gctx.beginPath();
      gctx.moveTo(x,0);
      gctx.lineTo(x,h);
      gctx.stroke();
    }
    gctx.strokeStyle="rgba(255,255,255,.12)";
    gctx.beginPath(); gctx.moveTo(w,0); gctx.lineTo(w,h); gctx.stroke();

    // hitline at 80% height
    const hitY = h * 0.82;
    gctx.strokeStyle = "rgba(122,162,255,.55)";
    gctx.lineWidth = 3;
    gctx.beginPath();
    gctx.moveTo(0, hitY);
    gctx.lineTo(w, hitY);
    gctx.stroke();

    // draw notes that are within a window based on scroll speed
    // scroll: px/s => px/ms = scroll/1000
    const pxPerMs = state.scroll / 1000;
    const now = songTimeMs();

    // show ~2s ahead and 1s behind
    const tMin = now - 1200;
    const tMax = now + 2600;

    const noteH = 12 * (w/900 + 0.7);
    for (const n of state.notes){
      if (n.t < tMin || n.t > tMax) continue;

      const dt = n.t - now; // positive => future => above hitline
      const y = hitY - dt * pxPerMs;
      const x = n.lane * laneW;

      // color based on dt
      const a = clamp(1 - Math.abs(dt)/2600, 0.25, 1);
      gctx.fillStyle = `rgba(122,255,199,${0.75*a})`;
      gctx.fillRect(x+4, y - noteH/2, laneW-8, noteH);
      gctx.strokeStyle = `rgba(0,0,0,${0.35*a})`;
      gctx.strokeRect(x+4, y - noteH/2, laneW-8, noteH);
    }

    // receptors
    gctx.fillStyle = "rgba(255,255,255,.10)";
    for (let i=0;i<k;i++){
      const x = i*laneW;
      gctx.fillRect(x+6, hitY+10, laneW-12, 10);
    }
  }

  // --------------------------
  // Main loop
  // --------------------------
  function tick(){
    // If playing, center follows audio
    if (state.playing && state.audioReady){
      state.editorCenterMs = songTimeMs();
      syncSeekUI();
    }
    drawEditor();
    drawGame();
    requestAnimationFrame(tick);
  }

  // --------------------------
  // Controls wiring
  // --------------------------
  function setPlaying(on){
    if (!state.audioReady) on = false;
    state.playing = on;
    hudMode.textContent = on ? "Play" : "Edit";
    playBtn.textContent = on ? "Pause" : "Play";
    if (state.audioReady){
      if (on) state.audioEl.play().catch(()=>{});
      else state.audioEl.pause();
    }
  }

  keymodeSel.onchange = () => {
    state.keymode = Number(keymodeSel.value);
  };

  snapSel.onchange = () => {
    state.snap = Number(snapSel.value);
    updateHudSnap();
  };

  bpmInp.oninput = () => state.bpm = Number(bpmInp.value || 180);
  offsetInp.oninput = () => state.offset = Number(offsetInp.value || 0);

  scrollR.oninput = () => {
    state.scroll = Number(scrollR.value);
    scrollVal.textContent = String(state.scroll);
  };

  volR.oninput = () => {
    state.vol = Number(volR.value);
    volVal.textContent = state.vol.toFixed(2);
    state.audioEl.volume = state.vol;
  };

  rateR.oninput = () => {
    state.rate = Number(rateR.value);
    rateVal.textContent = state.rate.toFixed(2);
    state.audioEl.playbackRate = state.rate;
  };

  playBtn.onclick = () => setPlaying(!state.playing);

  stopBtn.onclick = () => {
    setPlaying(false);
    setSongTimeMs(0);
  };

  clearBtn.onclick = () => {
    setPlaying(false);
    state.notes = [];
    refreshNoteList();
  };

  zoomIn.onclick = () => {
    state.msPerPixel = clamp(state.msPerPixel * 0.80, 0.25, 20);
  };
  zoomOut.onclick = () => {
    state.msPerPixel = clamp(state.msPerPixel * 1.25, 0.25, 20);
  };

  seekR.oninput = () => {
    setPlaying(false);
    setSongTimeMs(Number(seekR.value));
  };

  audioFile.onchange = async () => {
    const f = audioFile.files && audioFile.files[0];
    if (!f) return;

    setPlaying(false);
    state.audioReady = false;
    state.durationMs = 0;

    const url = URL.createObjectURL(f);
    state.audioEl.src = url;
    state.audioEl.volume = state.vol;
    state.audioEl.playbackRate = state.rate;

    await new Promise((res) => {
      state.audioEl.onloadedmetadata = () => res();
      state.audioEl.onerror = () => res();
    });

    if (isFinite(state.audioEl.duration) && state.audioEl.duration > 0){
      state.audioReady = true;
      state.durationMs = Math.floor(state.audioEl.duration * 1000);
      seekR.max = String(state.durationMs);
      timeLen.textContent = state.durationMs;
      setSongTimeMs(0);
    } else {
      state.audioReady = false;
      timeLen.textContent = "0";
      seekR.max = "1000";
      alert("Não consegui ler a duração do áudio. Tenta outro formato (mp3/ogg/wav).");
    }
  };

  // --------------------------
  // Editor interactions (click to place/delete)
  // --------------------------
  function editorPosToTimeAndLane(ev){
    const rect = editor.getBoundingClientRect();
    const dpr = editor.width / rect.width;
    const x = (ev.clientX - rect.left) * dpr;
    const y = (ev.clientY - rect.top) * dpr;

    const w = editor.width, h = editor.height;
    const centerY = h * 0.55;
    const now = songTimeMs();
    const t = now + (y - centerY) * state.msPerPixel;
    const lane = laneFromX(x, w);
    return {t: clamp(Math.floor(t), 0, state.durationMs || Math.floor(t)), lane};
  }

  editor.addEventListener("mousedown", (ev) => {
    const {t, lane} = editorPosToTimeAndLane(ev);
    if (ev.ctrlKey || ev.metaKey){
      deleteNearestNote(t, lane);
    } else {
      addNote(t, lane);
      // optional: snap editor center to that spot when paused
      if (!state.playing) setSongTimeMs(t);
    }
  });

  // wheel = scrub time
  editor.addEventListener("wheel", (ev) => {
    ev.preventDefault();
    const delta = Math.sign(ev.deltaY);
    setPlaying(false);
    setSongTimeMs(songTimeMs() + delta * 60); // 60ms steps
  }, {passive:false});

  // --------------------------
  // Keyboard mapping (place notes at playhead)
  // --------------------------
  window.addEventListener("keydown", (ev) => {
    if (ev.repeat) return;

    // avoid typing into inputs
    const tag = (document.activeElement && document.activeElement.tagName || "").toLowerCase();
    if (tag === "input" || tag === "textarea" || tag === "select") return;

    if (ev.code === "Space"){
      ev.preventDefault();
      // In 7K we also use space as a lane key, but play/pause is more important.
      // If you want space to place a note for 7K center, change this behavior.
      setPlaying(!state.playing);
      return;
    }

    if (ev.code === "Backspace"){
      ev.preventDefault();
      deleteNearestNote(songTimeMs(), null);
      return;
    }

    const km = keymaps[state.keymode] || keymaps[4];
    const key = ev.key.toLowerCase();

    // 7K: we avoid using actual space here because Space is play/pause
    // We'll interpret "g" as center-lane placement for 7K to keep a full mapping option.
    if (state.keymode === 7 && key === "g"){
      addNote(songTimeMs(), 3);
      return;
    }

    const idx = km.indexOf(key);
    if (idx >= 0){
      addNote(songTimeMs(), idx);
    }
  });

  // --------------------------
  // Import/Export .osu (mania) basic
  // --------------------------
  function exportOsu(){
    // Minimal mania format:
    // HitObjects: x,y,time,type,hitSound,objectParams,hitSample
    // For normal notes: type=1
    // x mapped by lane: (lane + 0.5) * (512/keymode)
    const k = state.keymode;
    const laneW = 512 / k;

    const hitObjects = state.notes.map(n => {
      const x = Math.floor((n.lane + 0.5) * laneW);
      const y = 192; // mania uses fixed y often
      const time = Math.max(0, Math.floor(n.t));
      const type = 1; // normal hitcircle
      const hitSound = 0;
      const objectParams = "0:0:0:0:";
      const hitSample = "0:0:0:0:";
      return `${x},${y},${time},${type},${hitSound},${objectParams},${hitSample}`;
    });

    const content =
`osu file format v14

[General]
AudioFilename: audio.mp3
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
WidescreenStoryboard: 0

[Editor]
DistanceSpacing: 1.0
BeatDivisor: ${state.snap === 0 ? 4 : state.snap}
GridSize: 4
TimelineZoom: 1

[Metadata]
Title: Untitled
Artist: Unknown
Creator: ManiaMapper
Version: Edit
Source:
Tags:

[Difficulty]
HPDrainRate: 5
CircleSize: ${k}
OverallDifficulty: 5
ApproachRate: 5
SliderMultiplier: 1.4
SliderTickRate: 1

[TimingPoints]
${state.offset},${(60000/Math.max(1,state.bpm)).toFixed(6)},4,2,0,100,1,0

[HitObjects]
${hitObjects.join("\n")}
`;
    io.value = content;
  }

  function parseOsu(text){
    const lines = text.split(/\r?\n/);
    let mode = 0;
    let cs = 4;
    let timingOffset = 0;
    let bpm = state.bpm;
    let inTiming = false;
    let inHit = false;

    const notes = [];

    for (const raw of lines){
      const line = raw.trim();
      if (!line || line.startsWith("//")) continue;

      if (line.startsWith("[")){
        inTiming = (line.toLowerCase() === "[timingpoints]");
        inHit = (line.toLowerCase() === "[hitobjects]");
        continue;
      }

      if (!inTiming && !inHit){
        if (line.toLowerCase().startsWith("mode:")){
          mode = Number(line.split(":")[1].trim());
        }
        if (line.toLowerCase().startsWith("circlesize:")){
          cs = Number(line.split(":")[1].trim());
        }
      }

      if (inTiming){
        // first uninherited timing point
        // format: offset,msPerBeat,...
        const parts = line.split(",");
        if (parts.length >= 2){
          const off = Number(parts[0]);
          const mpb = Number(parts[1]);
          if (isFinite(off) && isFinite(mpb) && mpb > 0){
            timingOffset = off;
            bpm = 60000 / mpb;
            inTiming = false; // take first
          }
        }
      }

      if (inHit){
        // mania x,y,time,type,...
        const parts = line.split(",");
        if (parts.length >= 5){
          const x = Number(parts[0]);
          const t = Number(parts[2]);
          const type = Number(parts[3]);

          if (!isFinite(x) || !isFinite(t) || !isFinite(type)) continue;

          // ignore holds for now (type 128). You can extend later.
          const isHold = (type & 128) === 128;
          if (isHold) continue;

          // infer lane
          const k = cs || state.keymode;
          const lane = clamp(Math.floor((x / 512) * k), 0, k-1);
          notes.push({t: Math.floor(t), lane});
        }
      }
    }

    // only accept mania
    if (mode !== 3){
      alert("Esse .osu não parece ser osu!mania (Mode:3).");
      return null;
    }
    return {cs: cs || 4, bpm, offset: timingOffset, notes};
  }

  exportBtn.onclick = exportOsu;

  importBtn.onclick = () => {
    const parsed = parseOsu(io.value || "");
    if (!parsed) return;

    setPlaying(false);
    state.keymode = clamp(parsed.cs, 4, 10);
    if (![4,6,7].includes(state.keymode)) state.keymode = 4; // keep supported modes
    keymodeSel.value = String(state.keymode);

    state.bpm = Math.max(1, Math.round(parsed.bpm));
    bpmInp.value = String(state.bpm);

    state.offset = Math.floor(parsed.offset || 0);
    offsetInp.value = String(state.offset);

    state.notes = parsed.notes || [];
    sortNotes();
    refreshNoteList();
    updateHudSnap();
    setSongTimeMs(0);
  };

  // --------------------------
  // Init
  // --------------------------
  function init(){
    state.audioEl.preload = "metadata";
    scrollVal.textContent = String(state.scroll);
    volVal.textContent = state.vol.toFixed(2);
    rateVal.textContent = state.rate.toFixed(2);
    updateHudSnap();
    refreshNoteList();

    // set seek defaults
    seekR.max = "1000";
    timeLen.textContent = "0";

    // stop audio when ended
    state.audioEl.onended = () => setPlaying(false);

    window.addEventListener("resize", () => {
      resizeCanvasToDisplaySize(editor);
      resizeCanvasToDisplaySize(game);
    });

    tick();
  }

  init();
})();
</script>
</body>
</html>

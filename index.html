<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Mania Editor (4K–7K) — MVP</title>
  <style>
    :root{
      --bg:#0b0c0f; --panel:#11141a; --fg:#eaeef6; --muted:#9aa4b2;
      --border:rgba(255,255,255,.10);
      --lane:rgba(255,255,255,.06);
      --grid:rgba(255,255,255,.07);
      --gridStrong:rgba(255,255,255,.14);
      --accent:#7dd3fc;
      --danger:#fb7185;
      --ok:#86efac;
      --r:12px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);
      display:flex; flex-direction:column;
    }
    header{
      padding:14px 16px; border-bottom:1px solid var(--border);
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .group{display:flex; gap:10px; align-items:center; background:var(--panel); border:1px solid var(--border); padding:10px; border-radius:var(--r)}
    label{font-size:12px; color:var(--muted); display:flex; flex-direction:column; gap:6px}
    input[type="number"], select, button, input[type="text"]{
      background:#0e1117; color:var(--fg); border:1px solid var(--border);
      border-radius:10px; padding:9px 10px; font-size:14px;
      outline:none;
    }
    input[type="file"]{color:var(--muted); font-size:13px}
    button{cursor:pointer}
    button.primary{border-color:rgba(125,211,252,.45)}
    button.danger{border-color:rgba(251,113,133,.5); color:#ffd7df}
    button:disabled{opacity:.55; cursor:not-allowed}
    main{flex:1; display:flex; gap:14px; padding:14px}
    .left{flex:1; min-width:320px; display:flex; flex-direction:column; gap:12px}
    .canvasWrap{
      position:relative; flex:1; border:1px solid var(--border); border-radius:16px;
      overflow:hidden; background:#07090d;
    }
    canvas{display:block; width:100%; height:100%}
    .hint{
      padding:10px 12px; border:1px solid var(--border); border-radius:14px;
      color:var(--muted); background:rgba(255,255,255,.03); font-size:13px; line-height:1.45;
    }
    .right{
      width:340px; max-width:40vw;
      display:flex; flex-direction:column; gap:12px;
    }
    .panel{
      background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:12px;
    }
    .panel h3{margin:0 0 8px 0; font-size:14px; color:#dbe5f5}
    .list{
      max-height:38vh; overflow:auto; border:1px solid var(--border);
      border-radius:12px; background:#0e1117;
    }
    .row{
      display:flex; justify-content:space-between; gap:10px;
      padding:10px 10px; border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px; color:var(--muted);
    }
    .row b{color:var(--fg); font-weight:600}
    .row:last-child{border-bottom:none}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10);
      padding:2px 6px; border-radius:8px; color:#dbe5f5}
    .badge{font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid var(--border); color:var(--muted)}
  </style>
</head>
<body>
<header>
  <div class="group">
    <label>
      Áudio
      <input id="audioFile" type="file" accept="audio/*">
    </label>
    <button id="playBtn" class="primary" disabled>Play</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="exportBtn" class="primary" disabled>Exportar .osu</button>
  </div>

  <div class="group">
    <label>Keys
      <select id="keys">
        <option>4</option><option>5</option><option>6</option><option>7</option>
      </select>
    </label>
    <label>BPM
      <input id="bpm" type="number" min="30" max="400" step="0.001" value="180">
    </label>
    <label>Offset (ms)
      <input id="offset" type="number" step="1" value="0">
    </label>
    <label>Snap
      <select id="snap">
        <option value="1">1/1</option>
        <option value="2">1/2</option>
        <option value="3">1/3</option>
        <option value="4" selected>1/4</option>
        <option value="6">1/6</option>
        <option value="8">1/8</option>
        <option value="12">1/12</option>
        <option value="16">1/16</option>
      </select>
    </label>
    <label>Zoom (px/s)
      <input id="zoom" type="number" min="200" max="6000" step="50" value="1400">
    </label>
  </div>

  <div class="group">
    <button id="undoBtn" disabled>Undo</button>
    <button id="delBtn" class="danger" disabled>Deletar selecionada</button>
    <span class="badge">Seleção: <span id="selInfo">—</span></span>
  </div>
</header>

<main>
  <section class="left">
    <div class="canvasWrap" id="wrap">
      <canvas id="cv"></canvas>
    </div>
    <div class="hint">
      <div><b>Controles</b>:
        <span class="kbd">Espaço</span> play/pausa,
        <span class="kbd">Clique</span> cria tap,
        <span class="kbd">Shift + arrastar</span> cria hold,
        <span class="kbd">Clique na nota</span> seleciona,
        <span class="kbd">Delete</span> apaga,
        <span class="kbd">Ctrl+Z</span> undo,
        <span class="kbd">Mouse wheel</span> scroll (tempo).
      </div>
      <div style="margin-top:6px">
        <b>Obs:</b> Esse MVP exporta um .osu de mania com 1 timing point (BPM/Offset).
        Dá pra evoluir pra múltiplos BPM, SV, metronome, etc.
      </div>
    </div>
  </section>

  <aside class="right">
    <div class="panel">
      <h3>Status</h3>
      <div class="row"><span>Tempo</span><b><span id="timeLbl">0</span> ms</b></div>
      <div class="row"><span>Notas</span><b><span id="countLbl">0</span></b></div>
      <div class="row"><span>Modo</span><b><span id="modeLbl">tap</span></b></div>
    </div>

    <div class="panel">
      <h3>Lista de notas (mais recente em cima)</h3>
      <div class="list" id="list"></div>
    </div>
  </aside>
</main>

<script>
(() => {
  // ---------- State ----------
  const state = {
    keys: 4,
    bpm: 180,
    offset: 0, // ms
    snap: 4, // denominator
    zoomPxPerSec: 1400,
    timeMs: 0,
    isPlaying: false,

    // audio
    ac: null,
    buffer: null,
    source: null,
    startedAt: 0, // ac.currentTime
    startOffsetSec: 0,

    // editor
    notes: [], // {id, lane, t, type:'tap'|'hold', end}
    undo: [],
    selectedId: null,

    // drag
    isHoldDrag: false,
    holdLane: 0,
    holdStartMs: 0,
  };

  const $ = (id) => document.getElementById(id);
  const cv = $("cv");
  const wrap = $("wrap");
  const ctx = cv.getContext("2d");

  const audioFile = $("audioFile");
  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const exportBtn = $("exportBtn");
  const keysSel = $("keys");
  const bpmIn = $("bpm");
  const offsetIn = $("offset");
  const snapSel = $("snap");
  const zoomIn = $("zoom");
  const undoBtn = $("undoBtn");
  const delBtn = $("delBtn");

  const timeLbl = $("timeLbl");
  const countLbl = $("countLbl");
  const listEl = $("list");
  const selInfo = $("selInfo");
  const modeLbl = $("modeLbl");

  // ---------- Helpers ----------
  const uid = () => Math.random().toString(36).slice(2, 10);

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function beatLenMs(){
    return 60000 / state.bpm;
  }

  function snapMs(){
    // 1/snap of a beat
    return beatLenMs() / state.snap;
  }

  function quantize(ms){
    const s = snapMs();
    return Math.round(ms / s) * s;
  }

  function laneFromX(x){
    const w = cv.width;
    const laneW = w / state.keys;
    return clamp(Math.floor(x / laneW), 0, state.keys - 1);
  }

  function xFromLane(lane){
    const laneW = cv.width / state.keys;
    return lane * laneW;
  }

  function yFromTime(tMs){
    // playhead centered
    const h = cv.height;
    const centerY = Math.floor(h * 0.55);
    const pxPerMs = state.zoomPxPerSec / 1000;
    return centerY - (tMs - state.timeMs) * pxPerMs;
  }

  function timeFromY(y){
    const h = cv.height;
    const centerY = Math.floor(h * 0.55);
    const pxPerMs = state.zoomPxPerSec / 1000;
    return state.timeMs + (centerY - y) / pxPerMs;
  }

  function setSelected(id){
    state.selectedId = id;
    const n = state.notes.find(n => n.id === id);
    selInfo.textContent = n ? `lane ${n.lane+1} @ ${Math.round(n.t)}ms` : "—";
    delBtn.disabled = !n;
    renderList();
  }

  function pushUndo(){
    state.undo.push(JSON.stringify(state.notes));
    if(state.undo.length > 200) state.undo.shift();
    undoBtn.disabled = state.undo.length === 0;
  }

  function doUndo(){
    const prev = state.undo.pop();
    if(!prev) return;
    state.notes = JSON.parse(prev);
    state.selectedId = null;
    undoBtn.disabled = state.undo.length === 0;
    delBtn.disabled = true;
    renderList();
  }

  function deleteSelected(){
    const id = state.selectedId;
    if(!id) return;
    pushUndo();
    state.notes = state.notes.filter(n => n.id !== id);
    setSelected(null);
  }

  function addNote(note){
    pushUndo();
    state.notes.push(note);
    state.notes.sort((a,b)=>a.t-b.t);
    setSelected(note.id);
  }

  function findNoteAt(mx, my){
    const lane = laneFromX(mx);
    const laneW = cv.width / state.keys;
    const x0 = xFromLane(lane);
    // hitbox: near note rects
    for(let i=state.notes.length-1;i>=0;i--){
      const n = state.notes[i];
      if(n.lane !== lane) continue;
      const y = yFromTime(n.t);
      const w = laneW;
      const h = 10;
      const rx = x0 + 6, ry = y - 6, rw = w - 12, rh = h + 6;
      if(mx >= rx && mx <= rx+rw && my >= ry && my <= ry+rh) return n;

      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y, y2);
        const bot = Math.max(y, y2);
        const barX = x0 + w/2 - 3;
        if(mx >= barX-6 && mx <= barX+12 && my >= top-6 && my <= bot+6) return n;
      }
    }
    return null;
  }

  // ---------- Audio ----------
  async function ensureAC(){
    if(state.ac) return state.ac;
    state.ac = new (window.AudioContext || window.webkitAudioContext)();
    return state.ac;
  }

  async function loadAudio(file){
    const ac = await ensureAC();
    const arr = await file.arrayBuffer();
    state.buffer = await ac.decodeAudioData(arr);
    state.timeMs = 0;
    state.startOffsetSec = 0;
    state.isPlaying = false;
    cleanupSource();
    playBtn.disabled = false;
    stopBtn.disabled = false;
    exportBtn.disabled = false;
  }

  function cleanupSource(){
    try{ if(state.source) state.source.stop(); }catch(e){}
    state.source = null;
  }

  function play(){
    if(!state.buffer) return;
    ensureAC().then(ac => {
      cleanupSource();
      const src = ac.createBufferSource();
      src.buffer = state.buffer;
      src.connect(ac.destination);
      state.startedAt = ac.currentTime;
      src.start(0, state.startOffsetSec);
      state.source = src;
      state.isPlaying = true;

      src.onended = () => {
        // If ended naturally
        if(state.isPlaying){
          state.isPlaying = false;
          playBtn.textContent = "Play";
        }
      };

      playBtn.textContent = "Pause";
    });
  }

  function pause(){
    if(!state.ac) return;
    // compute current offset
    const ac = state.ac;
    const playedSec = ac.currentTime - state.startedAt;
    state.startOffsetSec = state.startOffsetSec + playedSec;
    cleanupSource();
    state.isPlaying = false;
    playBtn.textContent = "Play";
  }

  function stop(){
    pause();
    state.startOffsetSec = 0;
    state.timeMs = 0;
  }

  function updateTimeFromAudio(){
    if(!state.isPlaying || !state.ac) return;
    const ac = state.ac;
    const playedSec = ac.currentTime - state.startedAt;
    const tSec = state.startOffsetSec + playedSec;
    state.timeMs = clamp(tSec * 1000, 0, state.buffer.duration * 1000);
  }

  // ---------- Export .osu (mania) ----------
  function laneToOsuX(lane){
    // 0..511
    const keys = state.keys;
    const x = Math.floor((lane + 0.5) * 512 / keys);
    return clamp(x, 0, 511);
  }

  function exportOsu(){
    const keys = state.keys;
    const audioName = (audioFile.files[0]?.name || "audio.mp3").replaceAll("\\", "/");
    const title = "WebManiaEditor";
    const artist = "Unknown";
    const creator = "reze";
    const version = `${keys}K`;

    const beatLen = 60000 / state.bpm;
    const offset = Math.round(state.offset);

    const header =
`osu file format v14

[General]
AudioFilename: ${audioName}
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
SpecialStyle: 0
WidescreenStoryboard: 0

[Editor]
DistanceSpacing: 1.0
BeatDivisor: ${state.snap}
GridSize: 4
TimelineZoom: 1.0

[Metadata]
Title:${title}
Artist:${artist}
Creator:${creator}
Version:${version}
Source:
Tags:

[Difficulty]
HPDrainRate:5
CircleSize:${keys}
OverallDifficulty:8
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events
//Break Periods
//Storyboard Layer 0 (Background)
//Storyboard Layer 1 (Fail)
//Storyboard Layer 2 (Pass)
//Storyboard Layer 3 (Foreground)
//Storyboard Layer 4 (Overlay)
//Storyboard Sound Samples

[TimingPoints]
${offset},${beatLen.toFixed(15)},4,2,0,100,1,0

[HitObjects]
`;

    const lines = state.notes
      .slice()
      .sort((a,b)=>a.t-b.t)
      .map(n => {
        const x = laneToOsuX(n.lane);
        const y = 192;
        const t = Math.round(n.t);
        if(n.type === "tap"){
          const type = 1;
          return `${x},${y},${t},${type},0,0:0:0:0:`;
        } else {
          const type = 128;
          const end = Math.max(t+1, Math.round(n.end));
          return `${x},${y},${t},${type},0,${end}:0:0:0:0:`;
        }
      });

    const out = header + lines.join("\n") + "\n";
    const blob = new Blob([out], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${title} - ${artist} (${creator}) [${version}].osu`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // ---------- Rendering ----------
  function resize(){
    const r = wrap.getBoundingClientRect();
    cv.width = Math.floor(r.width * devicePixelRatio);
    cv.height = Math.floor(r.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }

  function draw(){
    updateTimeFromAudio();

    const w = cv.width / devicePixelRatio;
    const h = cv.height / devicePixelRatio;

    // background
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#07090d";
    ctx.fillRect(0,0,w,h);

    // lanes
    const laneW = w / state.keys;
    for(let i=0;i<state.keys;i++){
      ctx.fillStyle = "rgba(255,255,255,.04)";
      ctx.fillRect(i*laneW, 0, laneW-1, h);
      ctx.fillStyle = "rgba(255,255,255,.08)";
      ctx.fillRect(i*laneW, 0, 1, h);
    }
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fillRect(w-1,0,1,h);

    // grid lines
    const pxPerMs = state.zoomPxPerSec / 1000;
    const s = snapMs();
    const viewMs = h / pxPerMs;
    const tMin = state.timeMs - viewMs * 0.6;
    const tMax = state.timeMs + viewMs * 0.4;

    const start = Math.floor(tMin / s) * s;
    for(let t = start; t <= tMax; t += s){
      const y = yFromTime(t);
      if(y < -50 || y > h+50) continue;

      const isBeat = Math.abs((t - state.offset) % beatLenMs()) < 1e-6 || Math.abs(((t - state.offset) % beatLenMs()) - beatLenMs()) < 1e-6;
      ctx.strokeStyle = isBeat ? "rgba(255,255,255,.16)" : "rgba(255,255,255,.08)";
      ctx.lineWidth = isBeat ? 1.5 : 1;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(w, y);
      ctx.stroke();
    }

    // playhead
    const centerY = Math.floor(h * 0.55);
    ctx.strokeStyle = "rgba(125,211,252,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(w, centerY);
    ctx.stroke();

    // notes
    for(const n of state.notes){
      const x0 = xFromLane(n.lane);
      const y = yFromTime(n.t);

      if(y < -80 || y > h+80) continue;

      const pad = 8;
      const rectW = laneW - pad*2;
      const rectH = 12;

      // hold body
      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);
        ctx.fillStyle = (n.id === state.selectedId) ? "rgba(125,211,252,.45)" : "rgba(255,255,255,.18)";
        ctx.fillRect(x0 + laneW/2 - 3, top, 6, bot-top);
        // end cap
        ctx.fillStyle = (n.id === state.selectedId) ? "rgba(125,211,252,.90)" : "rgba(255,255,255,.70)";
        ctx.fillRect(x0 + pad, y2 - rectH/2, rectW, rectH);
      }

      // head
      ctx.fillStyle = (n.id === state.selectedId) ? "rgba(125,211,252,.90)" : "rgba(255,255,255,.70)";
      ctx.fillRect(x0 + pad, y - rectH/2, rectW, rectH);
    }

    // HUD text
    timeLbl.textContent = Math.round(state.timeMs);
    countLbl.textContent = state.notes.length;

    requestAnimationFrame(draw);
  }

  function renderList(){
    const items = state.notes.slice().sort((a,b)=>b.t-a.t).slice(0, 80);
    listEl.innerHTML = items.map(n => {
      const sel = (n.id === state.selectedId);
      const t = Math.round(n.t);
      const extra = n.type === "hold" ? ` → ${Math.round(n.end)}ms` : "";
      return `<div class="row" style="background:${sel ? "rgba(125,211,252,.10)" : "transparent"}">
        <span><b>${n.type.toUpperCase()}</b> lane ${n.lane+1}</span>
        <span>${t}ms${extra}</span>
      </div>`;
    }).join("") || `<div class="row"><span>—</span><span>Sem notas ainda</span></div>`;
  }

  // ---------- Input / Events ----------
  audioFile.addEventListener("change", async () => {
    const f = audioFile.files[0];
    if(!f) return;
    await loadAudio(f);
  });

  playBtn.addEventListener("click", async () => {
    if(!state.buffer) return;
    if(!state.ac) await ensureAC();
    if(state.ac.state === "suspended") await state.ac.resume();
    if(state.isPlaying) pause(); else play();
  });

  stopBtn.addEventListener("click", stop);

  exportBtn.addEventListener("click", exportOsu);

  keysSel.addEventListener("change", () => {
    state.keys = parseInt(keysSel.value, 10);
    // clamp notes lanes
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);
    setSelected(null);
  });

  bpmIn.addEventListener("change", () => state.bpm = parseFloat(bpmIn.value));
  offsetIn.addEventListener("change", () => state.offset = parseInt(offsetIn.value, 10) || 0);
  snapSel.addEventListener("change", () => state.snap = parseInt(snapSel.value, 10));
  zoomIn.addEventListener("change", () => state.zoomPxPerSec = parseInt(zoomIn.value, 10));

  undoBtn.addEventListener("click", doUndo);
  delBtn.addEventListener("click", deleteSelected);

  // Mouse wheel = scroll time
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = e.deltaY;
    state.timeMs = clamp(state.timeMs + delta * 2.2, 0, state.buffer ? state.buffer.duration*1000 : 1e12);
    state.startOffsetSec = state.timeMs / 1000;
    if(state.isPlaying){
      // keep playing with new seek
      pause();
      play();
    }
  }, {passive:false});

  // Place notes
  let isMouseDown = false;

  wrap.addEventListener("mousedown", (e) => {
    const r = wrap.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    isMouseDown = true;

    // check hit existing note first
    const hit = findNoteAt(mx, my);
    if(hit){
      setSelected(hit.id);
      return;
    }

    const lane = laneFromX(mx);
    const t = quantize(timeFromY(my));
    if(e.shiftKey){
      state.isHoldDrag = true;
      state.holdLane = lane;
      state.holdStartMs = t;
      modeLbl.textContent = "hold";
      const id = uid();
      addNote({id, lane, t, type:"hold", end: t + snapMs()});
      // select it
      setSelected(id);
    } else {
      modeLbl.textContent = "tap";
      addNote({id: uid(), lane, t, type:"tap", end: t});
    }
  });

  wrap.addEventListener("mousemove", (e) => {
    if(!isMouseDown) return;
    if(!state.isHoldDrag) return;
    const id = state.selectedId;
    const n = state.notes.find(x => x.id === id);
    if(!n || n.type !== "hold") return;

    const r = wrap.getBoundingClientRect();
    const my = e.clientY - r.top;
    const tNow = quantize(timeFromY(my));
    n.end = Math.max(n.t + 1, tNow);
    renderList();
  });

  window.addEventListener("mouseup", () => {
    isMouseDown = false;
    state.isHoldDrag = false;
    modeLbl.textContent = "tap";
  });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.code === "Space"){
      e.preventDefault();
      playBtn.click();
    }
    if(e.code === "Delete"){
      deleteSelected();
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z"){
      e.preventDefault();
      doUndo();
    }
  });

  function updateUI(){
    renderList();
    exportBtn.disabled = !state.buffer;
    stopBtn.disabled = !state.buffer;
    undoBtn.disabled = state.undo.length === 0;
  }

  // ---------- Init ----------
  const ro = new ResizeObserver(() => { resize(); });
  ro.observe(wrap);
  resize();
  updateUI();
  requestAnimationFrame(draw);
})();
</script>
</body>
</html>

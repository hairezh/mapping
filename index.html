<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Web Mania Editor — V7 (layout antigo, editor in-game + waveform)</title>
  <style>
    :root{
      --bg:#0b0c0f;
      --panel:#11141a;
      --panel2:#0e1117;
      --fg:#eaeef6;
      --muted:#9aa4b2;
      --border:rgba(255,255,255,.10);
      --border2:rgba(255,255,255,.06);

      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#86efac;

      --r1:10px;
      --r2:14px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);
      display:flex; flex-direction:column; overflow:hidden;
    }

    /* ===== Top bar (sem File/Edit/etc) ===== */
    .topbar{
      height:52px;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--border2);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,0));
      user-select:none;
    }
    .topbar .leftBtns, .topbar .rightBtns{ display:flex; gap:10px; align-items:center; }
    .topbar .spacer{ flex:1; }

    .pillBtn{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      color:var(--fg);
      cursor:pointer;
      font-size:13px;
      line-height:1;
    }
    .pillBtn.secondary{ color:var(--muted); }
    .pillBtn.primary{ border-color:rgba(125,211,252,.45); background:rgba(125,211,252,.10); }
    .pillBtn:disabled{ opacity:.55; cursor:not-allowed; }

    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:9px 12px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .chip b{ color:var(--fg); font-weight:650; }
    .chip .mono{ font-family:var(--mono); }

    .iconBtn{
      width:40px; height:40px;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    .iconBtn svg{ width:18px; height:18px; opacity:.95; }

    input[type="range"]{ width:140px; }

    /* ===== App layout (antigo) ===== */
    .app{
      flex:1;
      display:grid;
      grid-template-columns: 90px 1fr 360px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r2);
      overflow:hidden;
      min-height:0;
    }
    .panel .hd{
      padding:10px 12px;
      border-bottom:1px solid var(--border2);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-size:12px; color:var(--muted);
    }
    .panel .bd{ padding:12px; min-height:0; }
    .divider{ height:1px; background:var(--border2); margin:10px 0; }

    /* Left */
    .left{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }
    .toolbox{
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .tool{
      width:100%;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      gap:6px;
      padding:10px 6px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--muted);
      cursor:pointer;
      font-size:11px;
      line-height:1;
    }
    .tool.active{
      color:var(--fg);
      border-color:rgba(125,211,252,.35);
      background:rgba(125,211,252,.10);
    }
    .tool svg{width:18px; height:18px; opacity:.9}
    .tool .kbd{
      font-family:var(--mono);
      font-size:10px;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      color:var(--muted);
    }

    .minimapWrap{
      flex:1;
      display:flex; flex-direction:column;
      min-height:0;
    }
    .minimapCanvas{
      flex:1;
      border-top:1px solid var(--border2);
      background:#07090d;
      cursor:pointer;
    }

    /* Center stage */
    .center{
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .stageWrap{
      flex:1;
      border-radius:var(--r2);
      border:1px solid var(--border);
      background:#07090d;
      overflow:hidden;
      min-height:0;
      position:relative;
    }
    .stageInner{
      position:absolute; inset:0;
      padding:12px;
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:12px;
      min-height:0;
    }

    .pane{
      position:relative;
      border-radius:var(--r2);
      border:1px solid var(--border);
      overflow:hidden;
      background:#07090d;
      min-height:0;
    }
    canvas{display:block; width:100%; height:100%}

    /* Timeline controls (+/-) */
    .tlBtns{
      position:absolute;
      right:10px; top:54px;
      display:flex; flex-direction:column; gap:8px;
      z-index:6;
      pointer-events:auto;
    }
    .tlBtn{
      width:34px; height:34px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.35);
      color:var(--fg);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      backdrop-filter: blur(6px);
      font-size:18px;
      line-height:1;
      user-select:none;
    }

    /* HUD chips inside editor */
    .hudRow{
      position:absolute;
      top:10px; left:10px; right:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index:6;
      pointer-events:none;
    }
    .hudRow .chip{ pointer-events:none; }
    .hudRight{
      margin-left:auto;
      display:flex; gap:8px; flex-wrap:wrap;
    }

    /* Combo overlay (center) */
    .comboOverlay{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:5;
      pointer-events:none;
      font-family:var(--mono);
      font-weight:800;
      font-size:72px;
      color:rgba(255,255,255,.22);
      text-shadow: 0 10px 40px rgba(0,0,0,.65);
    }

    /* Right */
    .right{
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }

    label{
      display:flex; flex-direction:column; gap:6px;
      font-size:12px; color:var(--muted);
    }
    input[type="text"], input[type="number"], select, button{
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--fg);
      border-radius:var(--r1);
      padding:9px 10px;
      font-size:14px;
      outline:none;
    }
    input[type="file"]{ color:var(--muted); font-size:13px }
    button{ cursor:pointer; user-select:none }
    button.primary{ border-color:rgba(125,211,252,.45) }
    button.ok{ border-color:rgba(134,239,172,.50); color:#d1fae5 }
    button.danger{ border-color:rgba(251,113,133,.55); color:#ffd7df }
    button:disabled{ opacity:.55; cursor:not-allowed }

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}

    .list{
      border:1px solid var(--border2);
      border-radius:12px;
      background:rgba(255,255,255,.03);
      overflow:auto;
      max-height:18vh;
    }
    .item{
      padding:9px 10px;
      border-bottom:1px solid var(--border2);
      display:flex; justify-content:space-between; gap:10px;
      font-size:12px; color:var(--muted);
      cursor:pointer;
      align-items:center;
    }
    .item:last-child{border-bottom:none}
    .item.sel{background:rgba(125,211,252,.10)}
    .item b{color:var(--fg); font-weight:650}
    .small{font-size:12px; color:var(--muted); line-height:1.45}
    .mono{font-family:var(--mono)}
    .toggleRow{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:8px 10px;
    }
    .toggleRow input{transform:scale(1.05)}
    .hint{
      border:1px solid var(--border2);
      background:rgba(255,255,255,.03);
      border-radius:12px;
      padding:10px;
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    .collapsed{ display:none !important; }

    @media (max-width: 1100px){
      .app{ grid-template-columns: 90px 1fr; }
      .right{ display:none; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="leftBtns">
      <button class="pillBtn secondary" id="exitBtn">← EXIT</button>
      <button class="pillBtn" id="optionsBtn">⚙ OPTIONS</button>
      <button class="pillBtn primary" id="bookmarkBtn">＋ ADD BOOKMARK</button>
    </div>

    <div class="spacer"></div>

    <div class="rightBtns">
      <div class="chip"><span class="mono">Time:</span> <b class="mono" id="chipTime">0</b> <span class="mono">ms</span></div>
      <div class="chip">Keys: <b class="mono" id="chipKeys">4</b></div>
      <div class="chip">Snap: <b class="mono" id="chipSnap">1/4</b></div>
      <div class="chip">Tool: <b class="mono" id="chipTool">Select</b></div>

      <div class="iconBtn" id="playBtn" title="Play/Pause (Space)">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
      </div>
      <div class="iconBtn" id="stopBtn" title="Stop">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 7h10v10H7z"/></svg>
      </div>

      <label class="small" style="gap:6px; min-width:160px">
        Volume
        <input id="volRange" type="range" min="0" max="1" step="0.01" value="1">
      </label>
    </div>
  </div>

  <div class="app">
    <!-- LEFT -->
    <section class="left">
      <div class="panel">
        <div class="hd">Tools</div>
        <div class="toolbox">
          <button class="tool active" data-tool="select" title="Select (1)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4l7 17 2-7 7-2L4 4z"/></svg>
            <div>Select</div>
            <div class="kbd">1</div>
          </button>
          <button class="tool" data-tool="tap" title="Tap (2)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 20v-8"/><path d="M8 12h8"/><circle cx="12" cy="6" r="3"/></svg>
            <div>Note</div>
            <div class="kbd">2</div>
          </button>
          <button class="tool" data-tool="hold" title="Hold (3)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="7" y="4" width="10" height="16" rx="2"/><path d="M12 8v8"/></svg>
            <div>Long</div>
            <div class="kbd">3</div>
          </button>
          <button class="tool" data-tool="erase" title="Erase (4)">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 20H8l-4-4L14 6l6 6-8 8"/><path d="M13 7l6 6"/></svg>
            <div>Erase</div>
            <div class="kbd">4</div>
          </button>

          <div class="divider"></div>

          <div class="toggleRow" title="Realtime preview (auto-play, notas não passam da linha)">
            <div class="small"><b class="mono">AT</b> Realtime preview</div>
            <input id="rtToggle" type="checkbox" checked/>
          </div>

          <div class="toggleRow" title="Snap On/Off (quantize)">
            <div class="small">Snap</div>
            <input id="snapOnToggle" type="checkbox" checked/>
          </div>

          <div class="toggleRow" title="Key recording (tocar e gravar)">
            <div class="small"><b class="mono">REC</b> Key recording</div>
            <input id="recToggle" type="checkbox" />
          </div>

          <div class="toggleRow" title="Quantize durante gravação">
            <div class="small">Quantize REC</div>
            <input id="recQuantToggle" type="checkbox" checked/>
          </div>
        </div>
      </div>

      <div class="panel minimapWrap">
        <div class="hd">
          Minimap
          <span class="small mono" id="miniLbl">—</span>
        </div>
        <canvas id="miniCanvas" class="minimapCanvas"></canvas>
      </div>
    </section>

    <!-- CENTER -->
    <section class="center">
      <div class="stageWrap" id="stageWrap">
        <div class="stageInner">
          <!-- TIMELINE -->
          <div class="pane timeline" id="timelineWrap">
            <div class="hudRow" style="pointer-events:none;">
              <div class="chip"><span class="mono">Win:</span> <b class="mono" id="tlWinLbl">8</b><span class="mono">s</span></div>
              <div class="chip"><span class="mono">Wf:</span> <b class="mono" id="tlWfLbl">—</b></div>
            </div>
            <div class="tlBtns">
              <div class="tlBtn" id="tlZoomIn" title="Zoom in (+)">+</div>
              <div class="tlBtn" id="tlZoomOut" title="Zoom out (-)">−</div>
            </div>
            <canvas id="timelineCanvas"></canvas>
          </div>

          <!-- MAP EDITOR (mania in-game + waveform) -->
          <div class="pane edit" id="editWrap">
            <div class="hudRow">
              <div class="chip"><span class="mono">Ctrl+Wheel</span> <span class="mono">Snap</span></div>
              <div class="chip"><span class="mono">Wheel</span> <span class="mono">Seek</span></div>
              <div class="chip"><span class="mono">Space</span> <span class="mono">Play</span></div>
              <div class="hudRight">
                <div class="chip"><span class="mono">Offset:</span> <b class="mono" id="hudOffset">0</b><span class="mono">ms</span></div>
                <div class="chip"><span class="mono">Notes:</span> <b class="mono" id="hudNotes">0</b></div>
              </div>
            </div>

            <div class="comboOverlay" id="comboOverlay">0</div>
            <canvas id="stageCanvas"></canvas>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="right" id="rightPanel">
      <div class="panel">
        <div class="hd">Projeto</div>
        <div class="bd">
          <label>Áudio
            <input id="audioFile" type="file" accept="audio/*">
          </label>

          <div class="grid2" style="margin-top:10px">
            <label>Keys
              <select id="keysSel">
                <option>4</option><option>5</option><option>6</option><option>7</option>
              </select>
            </label>

            <label>Scroll (px/s)
              <input id="scrollIn" type="number" min="250" max="9000" step="50" value="1700">
            </label>

            <label>Timeline window (s)
              <input id="tlWinIn" type="number" min="3" max="30" step="1" value="8">
            </label>

            <label>Offset áudio (ms)
              <input id="audioOffsetIn" type="number" step="1" value="0" placeholder="-220">
            </label>
          </div>

          <div class="grid2" style="margin-top:10px">
            <button id="exportBtn" class="primary" disabled>Exportar .osu</button>
            <button id="undoBtn" disabled>Undo</button>
            <button id="deleteBtn" class="danger" disabled>Delete sel.</button>
            <button id="clearNotesBtn" class="danger" disabled>Clear notes</button>
          </div>

          <div class="hint" style="margin-top:10px">
            <div><b>LN</b>: tool Long (3) → clique e arraste o tamanho.</div>
            <div><b>Resize LN</b>: Select (1) → pegue a “ponta” de baixo da LN e arraste.</div>
            <div><b>Snap</b>: Ctrl+Wheel em qualquer hora.</div>
            <div><b>Offset</b> afeta só o som (não mexe no mapa).</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="hd">Beat Snap</div>
        <div class="bd">
          <div class="small" style="margin-bottom:8px">Divisor</div>
          <input id="snapRange" type="range" min="0" max="7" step="1" value="3">
          <div class="small" style="margin-top:8px; display:flex; justify-content:space-between">
            <span class="mono" id="snapLabel">1/4</span>
            <span class="mono" style="opacity:.85">1/1 1/2 1/3 1/4 1/6 1/8 1/12 1/16</span>
          </div>
          <div class="divider"></div>
          <div class="toggleRow" title="Autoplay / não deixar passar">
            <div class="small">Autoplay (preview)</div>
            <input id="autoplayToggle" type="checkbox" checked/>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="hd">Timing</div>
        <div class="bd">
          <div class="grid2">
            <button id="tpAdd" class="ok" disabled>Add TP @ tempo</button>
            <button id="tpSort" disabled>Sort</button>
            <button id="tpReset" class="danger" disabled>Reset</button>
            <button id="autoBpmBtn" class="primary" disabled>Auto BPM (beta)</button>
          </div>
          <div class="divider"></div>
          <div class="list" id="tpList"></div>
          <div class="divider"></div>
          <div class="small" id="autoBpmOut">—</div>
        </div>
      </div>

      <div class="panel">
        <div class="hd">Bookmarks</div>
        <div class="bd">
          <div class="list" id="bmList" style="max-height:16vh"></div>
          <div class="hint" style="margin-top:10px">
            “ADD BOOKMARK” adiciona um marcador no tempo atual (aparece na timeline + minimap + editor).
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="hd">Meta (.osu)</div>
        <div class="bd">
          <div class="grid2">
            <label>Title <input id="mTitle" type="text" value="WebManiaEditor"></label>
            <label>Artist <input id="mArtist" type="text" value="Unknown"></label>
            <label>Creator <input id="mCreator" type="text" value="reze"></label>
            <label>Version <input id="mVersion" type="text" value="Easy"></label>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const qsa = (sel) => Array.from(document.querySelectorAll(sel));

  // Top controls
  const exitBtn = $("exitBtn");
  const optionsBtn = $("optionsBtn");
  const bookmarkBtn = $("bookmarkBtn");

  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const volRange = $("volRange");

  // Chips
  const chipTime = $("chipTime");
  const chipKeys = $("chipKeys");
  const chipSnap = $("chipSnap");
  const chipTool = $("chipTool");

  // Left tools
  const tools = qsa(".tool");
  const rtToggle = $("rtToggle");
  const snapOnToggle = $("snapOnToggle");
  const recToggle = $("recToggle");
  const recQuantToggle = $("recQuantToggle");

  // Canvases
  const editWrap = $("editWrap");
  const stageCanvas = $("stageCanvas");
  const sctx = stageCanvas.getContext("2d", { alpha:false });

  const timelineWrap = $("timelineWrap");
  const timelineCanvas = $("timelineCanvas");
  const tctx = timelineCanvas.getContext("2d", { alpha:false });

  const miniCanvas = $("miniCanvas");
  const mctx = miniCanvas.getContext("2d", { alpha:false });
  const miniLbl = $("miniLbl");

  // Timeline labels + zoom
  const tlWinLbl = $("tlWinLbl");
  const tlWfLbl = $("tlWfLbl");
  const tlZoomIn = $("tlZoomIn");
  const tlZoomOut = $("tlZoomOut");

  // Right panel
  const rightPanel = $("rightPanel");
  const audioFile = $("audioFile");
  const keysSel = $("keysSel");
  const scrollIn = $("scrollIn");
  const tlWinIn = $("tlWinIn");
  const audioOffsetIn = $("audioOffsetIn");

  const exportBtn = $("exportBtn");
  const undoBtn = $("undoBtn");
  const deleteBtn = $("deleteBtn");
  const clearNotesBtn = $("clearNotesBtn");

  const snapRange = $("snapRange");
  const snapLabel = $("snapLabel");
  const autoplayToggle = $("autoplayToggle");

  const tpAdd = $("tpAdd");
  const tpSort = $("tpSort");
  const tpReset = $("tpReset");
  const tpList = $("tpList");
  const autoBpmBtn = $("autoBpmBtn");
  const autoBpmOut = $("autoBpmOut");

  const bmList = $("bmList");

  const mTitle = $("mTitle");
  const mArtist = $("mArtist");
  const mCreator = $("mCreator");
  const mVersion = $("mVersion");

  const comboOverlay = $("comboOverlay");
  const hudOffset = $("hudOffset");
  const hudNotes = $("hudNotes");

  const SNAP_OPTS = [1,2,3,4,6,8,12,16];

  function uid(){ return Math.random().toString(36).slice(2,10); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  const state = {
    tool: "select",
    keys: 4,
    snap: 4,
    snapOn: true,
    scrollPxPerSec: 1700,
    tlWinSec: 8,

    // audio
    ac: null,
    buffer: null,
    source: null,
    gain: null,
    startedAt: 0,
    startMapMs: 0,
    isPlaying: false,
    rate: 1,
    timeMs: 0,
    audioOffsetMs: 0,

    // waveform
    wf: { ready:false, peaks:null, blockSec:0, max:1, progress:0, gamma:0.62 },

    // mapping
    timing: [{ id: uid(), t:0, bpm:180, meter:4 }],

    notes: [],
    selected: new Set(),
    undo: [],

    // preview / autoplay
    realtimePreview: true,
    autoplay: true,
    combo: 0,

    // bookmarks
    bookmarks: [],

    drag: {
      down:false,
      mode:"none",
      x0:0,y0:0,
      box:null,
      moveSnap:null,
      holdId:null,
      resizeId:null,
      resizeWhich:null, // "end"
      scrubWasPlaying:false,
    },

    tlDrag:false,
    miniDrag:false,

    rec: {
      on:false,
      quantize:true,
      bindsByKeys: {
        4:["d","f","j","k"],
        5:["d","f","space","j","k"],
        6:["s","d","f","j","k","l"],
        7:["s","d","f","space","j","k","l"],
      },
      downMap: new Map(),
    }
  };

  /* ===== Canvas resize (retina safe) ===== */
  function resizeCanvas(canvas, wrap){
    const r = wrap.getBoundingClientRect();
    const dpr = devicePixelRatio || 1;
    canvas.width = Math.max(1, Math.floor(r.width * dpr));
    canvas.height = Math.max(1, Math.floor(r.height * dpr));
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  const roStage = new ResizeObserver(()=> resizeCanvas(stageCanvas, editWrap));
  const roTl    = new ResizeObserver(()=> resizeCanvas(timelineCanvas, timelineWrap));
  const roMini  = new ResizeObserver(()=> resizeCanvas(miniCanvas, miniCanvas.parentElement));
  roStage.observe(editWrap);
  roTl.observe(timelineWrap);
  roMini.observe(miniCanvas.parentElement);

  resizeCanvas(stageCanvas, editWrap);
  resizeCanvas(timelineCanvas, timelineWrap);
  resizeCanvas(miniCanvas, miniCanvas.parentElement);

  const SW = ()=> stageCanvas.width / (devicePixelRatio||1);
  const SH = ()=> stageCanvas.height / (devicePixelRatio||1);
  const TW = ()=> timelineCanvas.width / (devicePixelRatio||1);
  const TH = ()=> timelineCanvas.height / (devicePixelRatio||1);
  const MW = ()=> miniCanvas.width / (devicePixelRatio||1);
  const MH = ()=> miniCanvas.height / (devicePixelRatio||1);

  /* ===== Timing helpers ===== */
  function normalizeTiming(){
    state.timing.sort((a,b)=>a.t-b.t);
    const out=[];
    for(const tp of state.timing){
      if(out.length && out[out.length-1].t === tp.t) out[out.length-1]=tp;
      else out.push(tp);
    }
    state.timing = out;
  }
  function activeTP(ms){
    normalizeTiming();
    let best = state.timing[0];
    for(const tp of state.timing){
      if(tp.t <= ms) best = tp;
      else break;
    }
    return best;
  }
  function snapMsAt(ms){
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    return beatLen / state.snap;
  }
  function quantizeAt(ms){
    if(!state.snapOn) return ms;
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const base = tp.t;
    const n = Math.round((ms - base) / step);
    return base + n*step;
  }

  /* ===== Geometry (mania in-game style) ===== */
  function laneW(){ return SW() / state.keys; }
  function laneFromX(x){ return clamp(Math.floor(x / laneW()), 0, state.keys-1); }
  function xLaneCenter(lane){ return (lane + 0.5) * laneW(); }

  // hitline near bottom
  function hitY(){ return SH() - 120; }
  function pxPerMs(){ return state.scrollPxPerSec / 1000; }
  function yFromTimeInGame(tMs){ return hitY() - (tMs - state.timeMs) * pxPerMs(); }
  function timeFromYInGame(y){ return state.timeMs + (hitY() - y) / pxPerMs(); }

  /* ===== Audio engine (pause/seek consertado + offset só do áudio) ===== */
  async function ensureAC(){
    if(state.ac) return state.ac;
    state.ac = new (window.AudioContext || window.webkitAudioContext)();
    state.gain = state.ac.createGain();
    state.gain.gain.value = parseFloat(volRange.value) || 1;
    state.gain.connect(state.ac.destination);
    return state.ac;
  }
  function cleanupSource(){
    try{
      if(state.source){
        state.source.onended = null;
        state.source.stop(0);
      }
    }catch(e){}
    state.source = null;
  }
  function getDurMs(){
    return state.buffer ? state.buffer.duration * 1000 : 0;
  }
  function clampTimeMs(ms){
    const max = getDurMs();
    return clamp(ms, 0, max);
  }

  function audioPosSecForMapMs(mapMs){
    // áudio toca em mapMs + offset
    const aMs = mapMs + state.audioOffsetMs;
    return clamp(aMs/1000, 0, state.buffer ? state.buffer.duration : 0);
  }

  async function play(){
    if(!state.buffer) return;
    const ac = await ensureAC();
    if(ac.state === "suspended") await ac.resume();

    cleanupSource();

    const src = ac.createBufferSource();
    src.buffer = state.buffer;
    src.playbackRate.value = state.rate;
    src.connect(state.gain);

    state.startedAt = ac.currentTime;
    state.startMapMs = state.timeMs;

    const off = audioPosSecForMapMs(state.timeMs);
    // se offset empurra além do fim, não toca
    if(off >= state.buffer.duration){
      state.isPlaying = false;
      return;
    }
    src.start(0, off);

    state.source = src;
    state.isPlaying = true;

    src.onended = () => {
      // acabou natural
      if(state.isPlaying){
        state.isPlaying = false;
      }
    };
  }

  function pause(){
    if(!state.ac || !state.isPlaying) return;
    // atualiza timeMs antes de parar
    updateTimeFromAudio(true);
    cleanupSource();
    state.isPlaying = false;
  }

  function stop(){
    pause();
    state.timeMs = 0;
    state.combo = 0;
    updateComboOverlay();
  }

  function seekMs(ms, {restartIfPlaying=true} = {}){
    if(!state.buffer){
      state.timeMs = Math.max(0, ms);
      return;
    }
    state.timeMs = clampTimeMs(ms);

    if(state.isPlaying && restartIfPlaying){
      pause();
      play();
    }
  }

  function updateTimeFromAudio(force=false){
    if(!state.isPlaying || !state.ac) return;
    const ac = state.ac;
    const dt = (ac.currentTime - state.startedAt) * state.rate;
    const newMap = state.startMapMs + dt*1000;
    const clamped = clampTimeMs(newMap);
    state.timeMs = clamped;

    // se bateu no fim, pausa limpinho
    if(force || clamped >= getDurMs()-0.5){
      if(clamped >= getDurMs()-0.5){
        state.isPlaying = false;
        cleanupSource();
      }
    }
  }

  async function loadAudio(file){
    const ac = await ensureAC();
    const arr = await file.arrayBuffer();
    state.buffer = await ac.decodeAudioData(arr);

    state.timeMs = 0;
    state.combo = 0;
    updateComboOverlay();

    cleanupSource();
    state.isPlaying = false;

    exportBtn.disabled = false;
    clearNotesBtn.disabled = false;
    tpAdd.disabled = false;
    tpSort.disabled = false;
    tpReset.disabled = false;
    autoBpmBtn.disabled = false;
    bookmarkBtn.disabled = false;

    // waveform
    state.wf.ready = false;
    state.wf.peaks = null;
    state.wf.progress = 0;
    tlWfLbl.textContent = "gerando…";
    miniLbl.textContent = "gerando…";
    buildPeaks();
  }

  /* ===== Waveform peaks (mais leve + menos estourado) ===== */
  function buildPeaks(){
    const buf = state.buffer;
    if(!buf) return;

    const wf = state.wf;
    const dur = buf.duration;

    // blocos maiores = mais leve
    const sr = buf.sampleRate;
    const baseBlock = dur > 240 ? 4096 : (dur > 120 ? 2048 : 1024);
    const block = baseBlock;
    const len = buf.length;
    const blocks = Math.ceil(len / block);

    wf.peaks = new Float32Array(blocks);
    wf.blockSec = block / sr;

    const channels = buf.numberOfChannels;
    const ch = [];
    for(let c=0;c<channels;c++) ch.push(buf.getChannelData(c));

    let i=0, max=1e-9;

    function step(){
      const t0 = performance.now();
      const budget = 10; // ms por frame

      while(i < blocks && performance.now() - t0 < budget){
        const start = i * block;
        const end = Math.min(len, start + block);

        // RMS simples (fica mais “justo” que peak puro)
        let sum = 0;
        const n = end - start;

        for(let s=start; s<end; s++){
          let v=0;
          for(let c=0;c<channels;c++) v += ch[c][s];
          v /= channels;
          sum += v*v;
        }
        const rms = Math.sqrt(sum / Math.max(1,n));
        wf.peaks[i] = rms;
        if(rms > max) max = rms;
        i++;
      }

      wf.progress = i/blocks;
      const pct = Math.round(wf.progress*100);
      tlWfLbl.textContent = wf.progress >= 1 ? "ok" : (pct + "%");
      miniLbl.textContent = tlWfLbl.textContent;

      if(i < blocks) requestAnimationFrame(step);
      else {
        wf.max = max || 1;
        wf.ready = true;
        tlWfLbl.textContent = "ok";
        miniLbl.textContent = "ok";
      }
    }
    requestAnimationFrame(step);
  }

  function ampAtMs(ms){
    const wf = state.wf;
    if(!wf.ready || !wf.peaks) return 0;
    const sec = ms / 1000;
    const idx = Math.floor(sec / wf.blockSec);
    if(idx < 0 || idx >= wf.peaks.length) return 0;
    let a = wf.peaks[idx] / wf.max;            // 0..1
    a = clamp(a, 0, 1);
    // compressão (menos estourado)
    a = Math.pow(a, wf.gamma);
    return a;
  }

  /* ===== Undo ===== */
  function pushUndo(){
    state.undo.push(JSON.stringify({
      keys: state.keys,
      snap: state.snap,
      snapOn: state.snapOn,
      scrollPxPerSec: state.scrollPxPerSec,
      tlWinSec: state.tlWinSec,
      timing: state.timing,
      notes: state.notes,
      bookmarks: state.bookmarks,
      meta: getMeta(),
      audioOffsetMs: state.audioOffsetMs,
    }));
    if(state.undo.length > 250) state.undo.shift();
    undoBtn.disabled = state.undo.length === 0;
  }

  function doUndo(){
    const raw = state.undo.pop();
    if(!raw) return;
    const s = JSON.parse(raw);

    state.keys = s.keys ?? state.keys;
    state.snap = s.snap ?? state.snap;
    state.snapOn = s.snapOn ?? state.snapOn;
    state.scrollPxPerSec = s.scrollPxPerSec ?? state.scrollPxPerSec;
    state.tlWinSec = s.tlWinSec ?? state.tlWinSec;
    state.timing = s.timing ?? state.timing;
    state.notes = s.notes ?? state.notes;
    state.bookmarks = s.bookmarks ?? state.bookmarks;
    if(s.meta) setMeta(s.meta);
    state.audioOffsetMs = s.audioOffsetMs ?? state.audioOffsetMs;

    keysSel.value = String(state.keys);
    scrollIn.value = String(state.scrollPxPerSec);
    tlWinIn.value = String(state.tlWinSec);
    audioOffsetIn.value = String(state.audioOffsetMs);

    const idx = SNAP_OPTS.indexOf(state.snap);
    snapRange.value = String(Math.max(0, idx));

    state.selected.clear();
    updateSelectionUI();
    renderTPList();
    renderBookmarks();
    undoBtn.disabled = state.undo.length === 0;
  }

  /* ===== Notes ===== */
  function sortNotes(){ state.notes.sort((a,b)=>a.t-b.t || a.lane-b.lane); }

  function addNote(note){
    state.notes.push(note);
    sortNotes();
    state.selected.clear();
    state.selected.add(note.id);
    updateSelectionUI();
  }

  function deleteSelection(){
    if(state.selected.size === 0) return;
    pushUndo();
    state.notes = state.notes.filter(n => !state.selected.has(n.id));
    state.selected.clear();
    updateSelectionUI();
  }

  function clearNotes(){
    pushUndo();
    state.notes = [];
    state.selected.clear();
    state.combo = 0;
    updateComboOverlay();
    updateSelectionUI();
  }

  function getSelectedOne(){
    if(state.selected.size !== 1) return null;
    const id = [...state.selected][0];
    return state.notes.find(n => n.id === id) || null;
  }

  function updateSelectionUI(){
    deleteBtn.disabled = state.selected.size === 0;
  }

  /* ===== Bookmarks ===== */
  function addBookmark(){
    if(!state.buffer) return;
    pushUndo();
    state.bookmarks.push({ id: uid(), t: Math.round(state.timeMs) });
    state.bookmarks.sort((a,b)=>a.t-b.t);
    renderBookmarks();
  }

  function renderBookmarks(){
    const arr = state.bookmarks;
    if(arr.length === 0){
      bmList.innerHTML = `<div class="item"><span>—</span><span class="mono">sem bookmarks</span></div>`;
      return;
    }
    bmList.innerHTML = arr.map(b => `
      <div class="item" data-id="${b.id}">
        <span><b class="mono">${b.t}</b><span class="mono"> ms</span></span>
        <span class="mono" style="opacity:.85">del</span>
      </div>
    `).join("");

    bmList.querySelectorAll(".item").forEach(el=>{
      el.addEventListener("click", ()=>{
        const id = el.getAttribute("data-id");
        const b = state.bookmarks.find(x=>x.id===id);
        if(!b) return;
        // clique -> seek; shift+clique -> delete
        if(event.shiftKey){
          pushUndo();
          state.bookmarks = state.bookmarks.filter(x=>x.id!==id);
          renderBookmarks();
        }else{
          seekMs(b.t);
        }
      });
    });
  }

  /* ===== Meta / Export ===== */
  function getMeta(){
    return {
      title: mTitle.value || "WebManiaEditor",
      artist: mArtist.value || "Unknown",
      creator: mCreator.value || "reze",
      version: mVersion.value || "Easy"
    };
  }
  function setMeta(m){
    mTitle.value = m.title ?? mTitle.value;
    mArtist.value = m.artist ?? mArtist.value;
    mCreator.value = m.creator ?? mCreator.value;
    mVersion.value = m.version ?? mVersion.value;
  }
  function laneToOsuX(lane){
    const x = Math.floor((lane + 0.5) * 512 / state.keys);
    return clamp(x, 0, 511);
  }
  function exportOsu(){
    if(!state.buffer) return;
    normalizeTiming();
    sortNotes();

    const meta = getMeta();
    const audioName = (audioFile.files[0]?.name || "audio.mp3").replaceAll("\\","/");
    const keys = state.keys;

    const header =
`osu file format v14

[General]
AudioFilename: ${audioName}
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
SpecialStyle: 0
WidescreenStoryboard: 0

[Editor]
BeatDivisor: ${state.snap}
GridSize: 4
TimelineZoom: 1.0

[Metadata]
Title:${meta.title}
Artist:${meta.artist}
Creator:${meta.creator}
Version:${keys}K ${meta.version}
Source:
Tags:

[Difficulty]
HPDrainRate:5
CircleSize:${keys}
OverallDifficulty:8
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events

[TimingPoints]
`;

    const tps = state.timing
      .slice()
      .sort((a,b)=>a.t-b.t)
      .map(tp => {
        const beatLen = (60000 / tp.bpm);
        return `${Math.round(tp.t)},${beatLen.toFixed(15)},${tp.meter||4},2,0,100,1,0`;
      }).join("\n");

    const hitHeader = `

[HitObjects]
`;

    const hitLines = state.notes.map(n => {
      const x = laneToOsuX(n.lane);
      const y = 192;
      const t = Math.round(n.t);
      const hs = n.hs ?? 0;
      const vol = clamp(n.vol ?? 0, 0, 100);
      const sample = `0:0:0:${vol}:`;

      if(n.type === "tap"){
        return `${x},${y},${t},1,${hs},${sample}`;
      } else {
        const end = Math.max(t+1, Math.round(n.end));
        return `${x},${y},${t},128,${hs},${end}:${sample}`;
      }
    }).join("\n");

    const out = header + tps + hitHeader + hitLines + "\n";
    const blob = new Blob([out], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${meta.title} - ${meta.artist} (${meta.creator}) [${keys}K ${meta.version}].osu`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  /* ===== Hit test (circles + LN) ===== */
  function findNoteAt(mx, my){
    const lw = laneW();
    const lane = laneFromX(mx);
    const cx = xLaneCenter(lane);

    const radius = Math.min(26, lw*0.32);
    const r2 = radius*radius;

    for(let i=state.notes.length-1;i>=0;i--){
      const n = state.notes[i];
      if(n.lane !== lane) continue;

      const y = yFromTimeInGame(n.t);

      // head circle
      const dx = mx - cx;
      const dy = my - y;
      if(dx*dx + dy*dy <= r2) return { note:n, part:"head" };

      if(n.type === "hold"){
        const yEnd = yFromTimeInGame(n.end);
        const dy2 = my - yEnd;
        if(dx*dx + dy2*dy2 <= r2) return { note:n, part:"end" };

        // body (hit area) - capsule
        const top = Math.min(y, yEnd);
        const bot = Math.max(y, yEnd);
        const bodyW = Math.max(10, radius*0.44);
        if(mx >= cx - bodyW && mx <= cx + bodyW && my >= top && my <= bot){
          return { note:n, part:"body" };
        }
      }
    }
    return null;
  }

  /* ===== Tools & snap setters ===== */
  function setTool(tool){
    state.tool = tool;
    tools.forEach(b => b.classList.toggle("active", b.getAttribute("data-tool") === tool));
    chipTool.textContent = tool[0].toUpperCase()+tool.slice(1);
  }

  function setKeys(k){
    pushUndo();
    state.keys = clamp(k,4,7);
    chipKeys.textContent = String(state.keys);
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);
    state.selected.clear();
    updateSelectionUI();
  }

  function setSnapByIndex(idx){
    idx = clamp(idx,0,SNAP_OPTS.length-1);
    state.snap = SNAP_OPTS[idx];
    const label = `1/${state.snap}`;
    snapLabel.textContent = label;
    chipSnap.textContent = label;
  }

  /* ===== Timeline mapping (mais firme) ===== */
  function tlRange(){
    const half = (state.tlWinSec*1000)/2;
    return { start: state.timeMs - half, end: state.timeMs + half };
  }
  function yFromTimeTL(ms){
    const {start,end} = tlRange();
    const h = TH();
    return ((ms - start) / (end - start)) * h;
  }
  function timeFromYTL(y){
    const {start,end} = tlRange();
    const h = TH();
    return start + (y / h) * (end - start);
  }

  /* ===== Drawing (otimizado) ===== */
  function drawLaneBG(ctx, w, h){
    const lw = laneW();

    // lanes
    for(let i=0;i<state.keys;i++){
      const x0 = i*lw;
      ctx.fillStyle = "rgba(255,255,255,.03)";
      ctx.fillRect(x0, 0, lw-1, h);
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.fillRect(x0, 0, 1, h);
    }
    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(w-1,0,1,h);
  }

  function drawWaveformInEditor(ctx, w, h){
    if(!state.wf.ready || !state.buffer) return;

    // desenha “pilar” no centro tipo osu-editor (mas dentro do playfield)
    const centerX = w * 0.5;
    const maxHalf = w * 0.18;

    // desenha só a cada 4px (bem mais leve)
    ctx.globalAlpha = 0.65;
    ctx.strokeStyle = "rgba(125,211,252,.85)";
    ctx.lineWidth = 1;

    const stepY = 4;
    for(let y=0; y<=h; y+=stepY){
      const ms = timeFromYInGame(y);
      const a = ampAtMs(ms);
      const amp = a * maxHalf;

      ctx.beginPath();
      ctx.moveTo(centerX - amp, y);
      ctx.lineTo(centerX + amp, y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawGridLines(ctx, w, h){
    // linhas de snap horizontais (discretas, “firmes”)
    const tp = activeTP(state.timeMs);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const meter = tp.meter || 4;
    const base = tp.t;

    const tMin = timeFromYInGame(h+40);
    const tMax = timeFromYInGame(-40);

    const n0 = Math.ceil((tMin - base) / step);
    for(let t = base + n0*step; t <= tMax; t += step){
      const y = yFromTimeInGame(t);
      if(y < -60 || y > h+60) continue;

      const rel = t - base;
      const beatIndex = Math.round(rel / beatLen);
      const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
      const isBar = isBeat && (beatIndex % meter === 0);

      const a = isBar ? 0.16 : isBeat ? 0.11 : 0.06;
      ctx.strokeStyle = `rgba(255,255,255,${a})`;
      ctx.lineWidth = isBar ? 1.6 : isBeat ? 1.2 : 1;
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }
  }

  function drawBookmarksInEditor(ctx, w, h){
    if(!state.bookmarks.length) return;
    ctx.globalAlpha = 0.7;
    for(const b of state.bookmarks){
      const y = yFromTimeInGame(b.t);
      if(y < -50 || y > h+50) continue;
      ctx.strokeStyle = "rgba(167,139,250,.65)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawNotesInGame(ctx, w, h){
    const lw = laneW();
    const radius = Math.min(28, lw*0.32);

    // receptor circles
    const ry = hitY() + 52;
    for(let i=0;i<state.keys;i++){
      const cx = xLaneCenter(i);
      ctx.strokeStyle = "rgba(255,255,255,.90)";
      ctx.lineWidth = 2.6;
      ctx.beginPath();
      ctx.arc(cx, ry, radius, 0, Math.PI*2);
      ctx.stroke();
    }

    // hit line (igual vibe osu)
    ctx.strokeStyle = "rgba(255,80,80,.85)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, hitY());
    ctx.lineTo(w, hitY());
    ctx.stroke();

    // draw notes
    const now = state.timeMs;
    const lookAhead = 2400;
    const lookBack  = 350;

    for(const n of state.notes){
      // realtime preview: não desenhar “passando”
      if(state.realtimePreview){
        if(n.type === "tap"){
          if(n.t < now - lookBack || n.t > now + lookAhead) continue;
          if(state.autoplay && n._hit) continue;
        }else{
          if(n.end < now - lookBack || n.t > now + lookAhead) continue;
          if(state.autoplay && n._hit && now > n.end + 60) continue;
        }
      }else{
        // modo edição: desenhar um pouco mais
        if(n.t < now - 5000 && n.end < now - 5000) continue;
        if(n.t > now + 8000) continue;
      }

      const cx = xLaneCenter(n.lane);
      const y = yFromTimeInGame(n.t);

      // LN body
      if(n.type === "hold"){
        const y2 = yFromTimeInGame(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);

        // body (capsule-ish)
        const bodyW = Math.max(10, radius*0.44);
        ctx.fillStyle = state.selected.has(n.id) ? "rgba(167,139,250,.28)" : "rgba(180,210,255,.18)";
        ctx.fillRect(cx-bodyW, top, bodyW*2, bot-top);

        // tail circle
        ctx.fillStyle = "rgba(180,210,255,.92)";
        ctx.strokeStyle = "rgba(255,255,255,.92)";
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.arc(cx, y2, radius, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }

      // head circle
      ctx.fillStyle = "rgba(180,210,255,.92)";
      ctx.strokeStyle = "rgba(255,255,255,.92)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.arc(cx, y, radius, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();

      // selection ring
      if(state.selected.has(n.id)){
        ctx.strokeStyle = "rgba(125,211,252,.95)";
        ctx.lineWidth = 2.4;
        ctx.beginPath();
        ctx.arc(cx, y, radius+4, 0, Math.PI*2);
        ctx.stroke();

        if(n.type === "hold"){
          const y2 = yFromTimeInGame(n.end);
          ctx.beginPath();
          ctx.arc(cx, y2, radius+4, 0, Math.PI*2);
          ctx.stroke();
        }
      }
    }
  }

  function updateComboOverlay(){
    comboOverlay.textContent = String(state.combo|0);
  }

  function runAutoplay(){
    if(!state.realtimePreview || !state.autoplay) return;
    // marca hits quando cruzam hitline (janela simples)
    const now = state.timeMs;
    const win = 38;

    for(const n of state.notes){
      if(n._hit) continue;
      if(n.type === "tap"){
        if(n.t <= now + win){
          n._hit = true;
          state.combo++;
        }
      }else{
        if(n.t <= now + win){
          n._hit = true;
          state.combo++;
        }
      }
    }
    updateComboOverlay();
  }

  // timeline waveform + markers (throttle)
  function drawTimeline(){
    const w = TW(), h = TH();
    tctx.fillStyle = "#07090d";
    tctx.fillRect(0,0,w,h);

    const {start,end} = tlRange();

    // waveform (mais leve)
    if(state.wf.ready){
      tctx.globalAlpha = 0.45;
      tctx.strokeStyle = "rgba(125,211,252,.85)";
      tctx.lineWidth = 1;
      const mid = w*0.52;
      const stepY = 3;
      const maxHalf = w*0.40;

      for(let y=0; y<=h; y+=stepY){
        const ms = timeFromYTL(y);
        const a = ampAtMs(ms);
        const amp = a*maxHalf;
        tctx.beginPath();
        tctx.moveTo(mid-amp, y);
        tctx.lineTo(mid+amp, y);
        tctx.stroke();
      }
      tctx.globalAlpha = 1;
    }

    // bookmarks
    if(state.bookmarks.length){
      tctx.globalAlpha = 0.9;
      for(const b of state.bookmarks){
        if(b.t < start || b.t > end) continue;
        const y = yFromTimeTL(b.t);
        tctx.strokeStyle = "rgba(167,139,250,.75)";
        tctx.lineWidth = 1.2;
        tctx.beginPath();
        tctx.moveTo(0,y);
        tctx.lineTo(w,y);
        tctx.stroke();
      }
      tctx.globalAlpha = 1;
    }

    // playhead
    const yPH = yFromTimeTL(state.timeMs);
    tctx.strokeStyle = "rgba(255,80,80,.90)";
    tctx.lineWidth = 2;
    tctx.beginPath();
    tctx.moveTo(0,yPH);
    tctx.lineTo(w,yPH);
    tctx.stroke();

    // border
    tctx.strokeStyle = "rgba(255,255,255,.08)";
    tctx.lineWidth = 1;
    tctx.beginPath();
    tctx.moveTo(w-0.5,0);
    tctx.lineTo(w-0.5,h);
    tctx.stroke();
  }

  function drawMinimap(){
    const w = MW(), h = MH();
    mctx.fillStyle = "#07090d";
    mctx.fillRect(0,0,w,h);

    if(!state.buffer || !state.wf.ready){
      mctx.fillStyle = "rgba(255,255,255,.06)";
      mctx.fillRect(0,0,w,h);
      return;
    }

    const durMs = getDurMs();

    // waveform vertical
    mctx.globalAlpha = 0.45;
    mctx.strokeStyle = "rgba(125,211,252,.85)";
    mctx.lineWidth = 1;

    const mid = w*0.55;
    const maxHalf = w*0.40;
    const stepY = 3;

    for(let y=0; y<=h; y+=stepY){
      const ms = (y/h)*durMs;
      const a = ampAtMs(ms);
      const amp = a*maxHalf;
      mctx.beginPath();
      mctx.moveTo(mid-amp, y);
      mctx.lineTo(mid+amp, y);
      mctx.stroke();
    }
    mctx.globalAlpha = 1;

    // bookmarks tiny ticks
    if(state.bookmarks.length){
      mctx.globalAlpha = 0.9;
      for(const b of state.bookmarks){
        const y = (b.t/durMs)*h;
        mctx.strokeStyle = "rgba(167,139,250,.75)";
        mctx.lineWidth = 1.2;
        mctx.beginPath();
        mctx.moveTo(0,y);
        mctx.lineTo(w,y);
        mctx.stroke();
      }
      mctx.globalAlpha = 1;
    }

    // playhead
    const py = (state.timeMs/durMs)*h;
    mctx.strokeStyle = "rgba(255,80,80,.90)";
    mctx.lineWidth = 2;
    mctx.beginPath();
    mctx.moveTo(0, py);
    mctx.lineTo(w, py);
    mctx.stroke();
  }

  function drawEditor(){
    const w = SW(), h = SH();
    sctx.fillStyle = "#07090d";
    sctx.fillRect(0,0,w,h);

    // background vignette
    const g = sctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, "rgba(0,0,0,.55)");
    g.addColorStop(0.2, "rgba(0,0,0,.10)");
    g.addColorStop(0.8, "rgba(0,0,0,.10)");
    g.addColorStop(1, "rgba(0,0,0,.55)");
    sctx.fillStyle = g;
    sctx.fillRect(0,0,w,h);

    drawLaneBG(sctx, w, h);

    // grid + waveform
    drawGridLines(sctx, w, h);
    drawWaveformInEditor(sctx, w, h);

    // bookmarks (linhas roxas discretas)
    drawBookmarksInEditor(sctx, w, h);

    // notes + receptors
    drawNotesInGame(sctx, w, h);

    // selection box (se usar)
    if(state.drag.mode === "box" && state.drag.box){
      const b = rectNorm(state.drag.box);
      sctx.fillStyle = "rgba(125,211,252,.10)";
      sctx.strokeStyle = "rgba(125,211,252,.55)";
      sctx.lineWidth = 1.5;
      sctx.fillRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
      sctx.strokeRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
    }
  }

  function rectNorm(box){
    return {
      x0: Math.min(box.x0, box.x1),
      y0: Math.min(box.y0, box.y1),
      x1: Math.max(box.x0, box.x1),
      y1: Math.max(box.y0, box.y1),
    };
  }

  /* ===== Mouse utils ===== */
  function mousePos(e, wrap){
    const r = wrap.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  /* ===== Interactions ===== */
  function beginMoveSelection(){
    const snap = new Map();
    for(const n of state.notes){
      if(state.selected.has(n.id)){
        snap.set(n.id, { t:n.t, end:n.end, lane:n.lane });
      }
    }
    state.drag.moveSnap = snap;
  }
  function applyMoveSelection(deltaLane, deltaMs){
    const snap = state.drag.moveSnap;
    if(!snap) return;

    for(const n of state.notes){
      if(!state.selected.has(n.id)) continue;
      const base = snap.get(n.id);
      if(!base) continue;

      const lane = clamp(base.lane + deltaLane, 0, state.keys-1);
      let t = base.t + deltaMs;
      t = state.snapOn ? quantizeAt(t) : t;

      n.lane = lane;
      n.t = t;

      if(n.type === "hold"){
        let end = base.end + deltaMs;
        end = state.snapOn ? quantizeAt(end) : end;
        n.end = Math.max(n.t + 1, end);
      } else {
        n.end = n.t;
      }
    }
    sortNotes();
  }

  function applyResizeHold(ms){
    const id = state.drag.resizeId;
    if(!id) return;
    const n = state.notes.find(x=>x.id===id);
    if(!n || n.type!=="hold") return;

    let end = ms;
    end = state.snapOn ? quantizeAt(end) : end;
    n.end = Math.max(n.t + 1, end);
    sortNotes();
  }

  // Wheel: seek OR ctrl+wheel snap
  editWrap.addEventListener("wheel", (e)=>{
    e.preventDefault();
    if(!state.buffer) return;

    if(e.ctrlKey){
      const dir = e.deltaY > 0 ? 1 : -1;
      const idx = SNAP_OPTS.indexOf(state.snap);
      setSnapByIndex(idx + dir);
      snapRange.value = String(clamp(idx+dir, 0, SNAP_OPTS.length-1));
      return;
    }

    // seek (mais “osu-feel”: passos menores)
    const step = e.shiftKey ? 6.0 : 2.2;
    seekMs(state.timeMs + e.deltaY * step, { restartIfPlaying:true });
  }, { passive:false });

  // Stage mouse down
  editWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    const m = mousePos(e, editWrap);
    state.drag.down = true;
    state.drag.x0 = m.x;
    state.drag.y0 = m.y;

    const additive = e.ctrlKey || e.metaKey;

    const hit = findNoteAt(m.x, m.y);

    if(state.tool === "select"){
      if(hit){
        const n = hit.note;

        // selection
        if(additive){
          if(state.selected.has(n.id)) state.selected.delete(n.id);
          else state.selected.add(n.id);
        }else{
          if(!state.selected.has(n.id)){
            state.selected.clear();
            state.selected.add(n.id);
          }
        }

        // se clicou no "end" de LN => resize
        if(n.type==="hold" && hit.part==="end"){
          pushUndo();
          state.drag.mode = "resizeHold";
          state.drag.resizeId = n.id;
          return;
        }

        // move selection
        pushUndo();
        state.drag.mode = "move";
        beginMoveSelection();
        return;
      }

      // box select
      state.drag.mode = "box";
      state.drag.box = { x0:m.x, y0:m.y, x1:m.x, y1:m.y };
      if(!additive) state.selected.clear();
      return;
    }

    if(state.tool === "erase"){
      if(hit){
        pushUndo();
        state.notes = state.notes.filter(x => x.id !== hit.note.id);
        state.selected.delete(hit.note.id);
      }
      return;
    }

    if(state.tool === "tap"){
      pushUndo();
      const lane = laneFromX(m.x);
      const tRaw = timeFromYInGame(m.y);
      const t = state.snapOn ? quantizeAt(tRaw) : tRaw;
      addNote({ id: uid(), lane, t, type:"tap", end:t, hs:0, vol:0, _hit:false });
      return;
    }

    if(state.tool === "hold"){
      pushUndo();
      const lane = laneFromX(m.x);
      const t0Raw = timeFromYInGame(m.y);
      const t0 = state.snapOn ? quantizeAt(t0Raw) : t0Raw;
      const id = uid();
      addNote({ id, lane, t:t0, type:"hold", end:t0 + snapMsAt(t0), hs:0, vol:0, _hit:false });
      state.drag.mode = "holdCreate";
      state.drag.holdId = id;
      return;
    }
  });

  editWrap.addEventListener("mousemove", (e)=>{
    if(!state.drag.down) return;
    const m = mousePos(e, editWrap);

    if(state.tool === "select" && state.drag.mode === "box" && state.drag.box){
      state.drag.box.x1 = m.x;
      state.drag.box.y1 = m.y;

      // select by box
      const b = rectNorm(state.drag.box);
      const laneMin = laneFromX(b.x0);
      const laneMax = laneFromX(b.x1);

      const tA = state.snapOn ? quantizeAt(timeFromYInGame(b.y1)) : timeFromYInGame(b.y1);
      const tB = state.snapOn ? quantizeAt(timeFromYInGame(b.y0)) : timeFromYInGame(b.y0);
      const tMin = Math.min(tA,tB), tMax = Math.max(tA,tB);

      for(const n of state.notes){
        if(n.lane < laneMin || n.lane > laneMax) continue;
        if(n.type === "tap"){
          if(n.t >= tMin && n.t <= tMax) state.selected.add(n.id);
        } else {
          if(!(n.end < tMin || n.t > tMax)) state.selected.add(n.id);
        }
      }
      return;
    }

    if(state.tool === "select" && state.drag.mode === "move"){
      const dxLane = laneFromX(m.x) - laneFromX(state.drag.x0);
      const dMsRaw = (state.snapOn ? quantizeAt(timeFromYInGame(m.y)) : timeFromYInGame(m.y))
                   - (state.snapOn ? quantizeAt(timeFromYInGame(state.drag.y0)) : timeFromYInGame(state.drag.y0));
      applyMoveSelection(dxLane, dMsRaw);
      return;
    }

    if(state.tool === "select" && state.drag.mode === "resizeHold"){
      const ms = timeFromYInGame(m.y);
      applyResizeHold(ms);
      return;
    }

    if(state.tool === "hold" && state.drag.mode === "holdCreate"){
      const id = state.drag.holdId;
      const n = state.notes.find(x => x.id === id);
      if(!n) return;
      const endRaw = timeFromYInGame(m.y);
      const end = state.snapOn ? quantizeAt(endRaw) : endRaw;
      n.end = Math.max(n.t + 1, end);
      sortNotes();
      return;
    }
  });

  window.addEventListener("mouseup", ()=>{
    state.drag.down = false;
    state.drag.mode = "none";
    state.drag.box = null;
    state.drag.moveSnap = null;
    state.drag.holdId = null;
    state.drag.resizeId = null;
    state.drag.resizeWhich = null;
  });

  /* ===== Timeline drag seek (firme) ===== */
  function beginScrub(){
    if(state.isPlaying){
      state.drag.scrubWasPlaying = true;
      pause();
    } else {
      state.drag.scrubWasPlaying = false;
    }
  }
  function endScrub(){
    if(state.drag.scrubWasPlaying){
      state.drag.scrubWasPlaying = false;
      play();
    }
  }
  function timelineSeekAtY(y){
    const ms = timeFromYTL(y);
    seekMs(ms, { restartIfPlaying:false });
  }

  timelineWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    state.tlDrag = true;
    beginScrub();
    const m = mousePos(e, timelineWrap);
    timelineSeekAtY(m.y);
  });
  window.addEventListener("mousemove", (e)=>{
    if(!state.tlDrag) return;
    const m = mousePos(e, timelineWrap);
    timelineSeekAtY(m.y);
  });
  window.addEventListener("mouseup", ()=>{
    if(state.tlDrag){
      state.tlDrag = false;
      endScrub();
    }
  });

  /* ===== Minimap drag seek ===== */
  function minimapSeek(clientY){
    const r = miniCanvas.getBoundingClientRect();
    const y = clientY - r.top;
    const durMs = getDurMs();
    seekMs((y / r.height) * durMs, { restartIfPlaying:false });
  }

  miniCanvas.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    state.miniDrag = true;
    beginScrub();
    minimapSeek(e.clientY);
  });
  window.addEventListener("mousemove", (e)=>{
    if(!state.miniDrag) return;
    minimapSeek(e.clientY);
  });
  window.addEventListener("mouseup", ()=>{
    if(state.miniDrag){
      state.miniDrag = false;
      endScrub();
    }
  });

  /* ===== Recording ===== */
  function normalizeKey(e){
    if(e.code === "Space") return "space";
    return (e.key || "").toLowerCase();
  }
  function recKeyDown(e){
    if(!state.rec.on) return;
    if(!state.isPlaying) return;
    if(e.repeat) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;

    const key = normalizeKey(e);
    const binds = state.rec.bindsByKeys[state.keys];
    const lane = binds.indexOf(key);
    if(lane < 0) return;
    if(state.rec.downMap.has(key)) return;

    pushUndo();

    const ms = state.timeMs;
    const t = state.rec.quantize ? quantizeAt(ms) : ms;

    const id = uid();
    const note = { id, lane, t, type:"hold", end: t + snapMsAt(t), hs:0, vol:0, _hit:false };
    state.notes.push(note);
    sortNotes();

    state.rec.downMap.set(key, { noteId:id });
    state.selected.clear();
    state.selected.add(id);

    e.preventDefault();
  }
  function recKeyUp(e){
    if(!state.rec.on) return;
    const key = normalizeKey(e);
    const info = state.rec.downMap.get(key);
    if(!info) return;

    const n = state.notes.find(x => x.id === info.noteId);
    state.rec.downMap.delete(key);
    if(!n) return;

    const ms = state.timeMs;
    const end = state.rec.quantize ? quantizeAt(ms) : ms;
    const minHold = snapMsAt(n.t) * 0.6;

    if(end - n.t < minHold){
      n.type = "tap";
      n.end = n.t;
    } else {
      n.type = "hold";
      n.end = Math.max(n.t + 1, end);
    }
    sortNotes();
    e.preventDefault();
  }

  window.addEventListener("keydown", (e)=>{
    if(e.code === "Space"){
      e.preventDefault();
      if(state.isPlaying) pause(); else play();
      return;
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="z"){
      e.preventDefault();
      doUndo();
      return;
    }
    if(e.code === "Delete"){
      deleteSelection();
      return;
    }
    if(e.key === "1") setTool("select");
    if(e.key === "2") setTool("tap");
    if(e.key === "3") setTool("hold");
    if(e.key === "4") setTool("erase");

    recKeyDown(e);
  });
  window.addEventListener("keyup", (e)=> recKeyUp(e));

  /* ===== Timing list ===== */
  function renderTPList(){
    normalizeTiming();
    tpList.innerHTML = state.timing.map(tp => `
      <div class="item" data-id="${tp.id}" style="cursor:default">
        <span><b class="mono">${Math.round(tp.t)}ms</b> • <span class="mono">${tp.bpm.toFixed(3)} BPM</span></span>
        <span style="display:flex; gap:8px; align-items:center">
          <input class="mono" data-k="t" type="number" step="1" value="${Math.round(tp.t)}" style="width:110px">
          <input class="mono" data-k="bpm" type="number" step="0.001" value="${tp.bpm}" style="width:110px">
          <span class="mono" style="opacity:.9; cursor:pointer" data-act="del">x</span>
        </span>
      </div>
    `).join("");

    tpList.querySelectorAll(".item").forEach(row => {
      const id = row.getAttribute("data-id");
      const tp = state.timing.find(x => x.id === id);
      if(!tp) return;

      const tIn = row.querySelector('input[data-k="t"]');
      const bpmIn = row.querySelector('input[data-k="bpm"]');
      const del = row.querySelector('[data-act="del"]');

      tIn.addEventListener("change", ()=>{
        pushUndo();
        tp.t = Math.max(0, Math.round(Number(tIn.value)||0));
        normalizeTiming();
        renderTPList();
      });
      bpmIn.addEventListener("change", ()=>{
        pushUndo();
        tp.bpm = clamp(Number(bpmIn.value)||180, 30, 400);
        normalizeTiming();
        renderTPList();
      });
      del.addEventListener("click", ()=>{
        if(state.timing.length <= 1) return;
        pushUndo();
        state.timing = state.timing.filter(x => x.id !== id);
        normalizeTiming();
        renderTPList();
      });
    });
  }

  /* ===== Auto BPM (beta, global + segmentos simples) ===== */
  function estimateBpmSegment(startSec, endSec){
    const buf = state.buffer;
    if(!buf) return null;

    const sr = buf.sampleRate;
    const chN = buf.numberOfChannels;
    const start = Math.floor(startSec * sr);
    const end = Math.min(buf.length, Math.floor(endSec * sr));
    const len = end - start;
    if(len < sr * 4) return null;

    // envelope a ~200Hz
    const envSR = 200;
    const hop = Math.max(1, Math.floor(sr / envSR));
    const envLen = Math.floor(len / hop);
    const env = new Float32Array(envLen);

    const ch = [];
    for(let c=0;c<chN;c++) ch.push(buf.getChannelData(c));

    // energia curta
    for(let i=0;i<envLen;i++){
      const s0 = start + i*hop;
      const s1 = Math.min(end, s0 + hop);
      let sum = 0;
      const n = s1 - s0;
      for(let s=s0; s<s1; s++){
        let v=0;
        for(let c=0;c<chN;c++) v += ch[c][s];
        v /= chN;
        sum += v*v;
      }
      env[i] = Math.sqrt(sum / Math.max(1,n));
    }

    // remove DC + enfatiza transientes
    let mean = 0;
    for(let i=0;i<envLen;i++) mean += env[i];
    mean /= envLen;
    for(let i=0;i<envLen;i++) env[i] = Math.max(0, env[i]-mean);

    // derivada (onset-ish)
    for(let i=envLen-1;i>=1;i--){
      env[i] = Math.max(0, env[i] - env[i-1]);
    }
    env[0]=0;

    // autocorr BPM range
    const minBpm = 70, maxBpm = 220;
    const minLag = Math.floor((60/envSR) * envSR / (maxBpm/60)); // fix? vamos direto:
    const lagMin = Math.floor(envSR * 60 / maxBpm);
    const lagMax = Math.floor(envSR * 60 / minBpm);

    let bestLag = -1;
    let best = -1;

    for(let lag=lagMin; lag<=lagMax; lag++){
      let sum = 0;
      for(let i=0; i<envLen-lag; i++){
        sum += env[i] * env[i+lag];
      }
      if(sum > best){
        best = sum;
        bestLag = lag;
      }
    }

    if(bestLag <= 0) return null;
    let bpm = (60 * envSR) / bestLag;

    // ajusta pra ficar em faixa “humana” (dobro/metade)
    while(bpm < 85) bpm *= 2;
    while(bpm > 210) bpm /= 2;

    return bpm;
  }

  async function autoDetectBpm(){
    if(!state.buffer) return;
    autoBpmOut.textContent = "analisando…";

    // pega 3 janelas (começo/meio/fim) e usa mediana
    const dur = state.buffer.duration;
    const windows = [
      [Math.min(2, dur*0.05), Math.min(dur, 18)],
      [Math.max(0, dur*0.45), Math.min(dur, dur*0.45 + 18)],
      [Math.max(0, dur-20), dur],
    ];

    const bpms = [];
    for(const [a,b] of windows){
      const bpm = estimateBpmSegment(a,b);
      if(bpm) bpms.push(bpm);
      await new Promise(r=>requestAnimationFrame(r));
    }
    bpms.sort((x,y)=>x-y);
    const bpm = bpms.length ? bpms[Math.floor(bpms.length/2)] : null;

    if(!bpm){
      autoBpmOut.textContent = "não consegui estimar (tenta outra música / silêncio no início?)";
      return;
    }

    autoBpmOut.innerHTML = `BPM estimado: <b class="mono">${bpm.toFixed(3)}</b> — <span class="mono">clique p/ aplicar</span>`;
    autoBpmOut.style.cursor = "pointer";

    const onClick = () => {
      pushUndo();
      state.timing = [{ id: uid(), t:0, bpm:bpm, meter:4 }];
      renderTPList();
      autoBpmOut.textContent = `aplicado: ${bpm.toFixed(3)} BPM em 0ms`;
      autoBpmOut.style.cursor = "default";
      autoBpmOut.removeEventListener("click", onClick);
    };
    autoBpmOut.addEventListener("click", onClick);
  }

  /* ===== UI wiring ===== */
  tools.forEach(b => b.addEventListener("click", ()=> setTool(b.getAttribute("data-tool"))));

  rtToggle.addEventListener("change", ()=>{
    state.realtimePreview = !!rtToggle.checked;
    // reset hits quando trocar modo
    for(const n of state.notes) n._hit = false;
    state.combo = 0;
    updateComboOverlay();
  });
  autoplayToggle.addEventListener("change", ()=>{
    state.autoplay = !!autoplayToggle.checked;
    for(const n of state.notes) n._hit = false;
    state.combo = 0;
    updateComboOverlay();
  });

  snapOnToggle.addEventListener("change", ()=> state.snapOn = !!snapOnToggle.checked);

  recToggle.addEventListener("change", ()=> state.rec.on = !!recToggle.checked);
  recQuantToggle.addEventListener("change", ()=> state.rec.quantize = !!recQuantToggle.checked);

  audioFile.addEventListener("change", async ()=>{
    const f = audioFile.files[0];
    if(!f) return;
    await loadAudio(f);
  });

  keysSel.addEventListener("change", ()=> setKeys(parseInt(keysSel.value,10)));

  scrollIn.addEventListener("change", ()=>{
    pushUndo();
    state.scrollPxPerSec = clamp(parseInt(scrollIn.value,10)||1700, 250, 9000);
  });

  tlWinIn.addEventListener("change", ()=>{
    pushUndo();
    state.tlWinSec = clamp(parseInt(tlWinIn.value,10)||8, 3, 30);
    tlWinLbl.textContent = String(state.tlWinSec);
  });

  audioOffsetIn.addEventListener("change", ()=>{
    pushUndo();
    state.audioOffsetMs = parseInt(audioOffsetIn.value,10)||0;
    hudOffset.textContent = String(state.audioOffsetMs);
    // se estiver tocando, reinicia pra aplicar offset
    if(state.isPlaying){ pause(); play(); }
  });

  snapRange.addEventListener("input", ()=>{
    const idx = parseInt(snapRange.value,10);
    setSnapByIndex(idx);
  });

  exportBtn.addEventListener("click", exportOsu);
  undoBtn.addEventListener("click", doUndo);
  deleteBtn.addEventListener("click", deleteSelection);
  clearNotesBtn.addEventListener("click", clearNotes);

  tpAdd.addEventListener("click", ()=>{
    pushUndo();
    const ms = Math.round(state.timeMs);
    const cur = activeTP(ms);
    state.timing.push({ id: uid(), t: ms, bpm: cur.bpm, meter: cur.meter||4 });
    normalizeTiming();
    renderTPList();
  });
  tpSort.addEventListener("click", ()=>{
    pushUndo();
    normalizeTiming();
    renderTPList();
  });
  tpReset.addEventListener("click", ()=>{
    pushUndo();
    state.timing = [{ id: uid(), t:0, bpm:180, meter:4 }];
    renderTPList();
  });

  autoBpmBtn.addEventListener("click", autoDetectBpm);

  playBtn.addEventListener("click", ()=> { if(state.isPlaying) pause(); else play(); });
  stopBtn.addEventListener("click", stop);
  volRange.addEventListener("input", ()=>{ if(state.gain) state.gain.gain.value = parseFloat(volRange.value)||1; });

  exitBtn.addEventListener("click", ()=>{
    // “exit” simples: recarrega
    location.reload();
  });

  optionsBtn.addEventListener("click", ()=>{
    rightPanel.classList.toggle("collapsed");
  });

  bookmarkBtn.addEventListener("click", addBookmark);

  tlZoomIn.addEventListener("click", ()=>{
    pushUndo();
    state.tlWinSec = clamp(state.tlWinSec - 1, 3, 30);
    tlWinIn.value = String(state.tlWinSec);
    tlWinLbl.textContent = String(state.tlWinSec);
  });
  tlZoomOut.addEventListener("click", ()=>{
    pushUndo();
    state.tlWinSec = clamp(state.tlWinSec + 1, 3, 30);
    tlWinIn.value = String(state.tlWinSec);
    tlWinLbl.textContent = String(state.tlWinSec);
  });

  /* ===== HUD update ===== */
  function renderHUD(){
    chipTime.textContent = String(Math.round(state.timeMs));
    chipKeys.textContent = String(state.keys);
    chipSnap.textContent = `1/${state.snap}`;
    hudOffset.textContent = String(state.audioOffsetMs);
    hudNotes.textContent = String(state.notes.length);
  }

  /* ===== Main loop (throttles p/ reduzir lag) ===== */
  let lastTL = 0, lastMini = 0, lastWf = 0;
  function loop(ts){
    updateTimeFromAudio();

    if(state.realtimePreview) runAutoplay();
    else updateComboOverlay();

    renderHUD();

    // editor: sempre (mais “responsivo”)
    drawEditor();

    // timeline: ~30fps
    if(ts - lastTL > 33){
      drawTimeline();
      lastTL = ts;
    }

    // minimap: ~20fps
    if(ts - lastMini > 50){
      drawMinimap();
      lastMini = ts;
    }

    requestAnimationFrame(loop);
  }

  /* ===== init ===== */
  function init(){
    // defaults
    setTool("select");
    keysSel.value = "4";
    setSnapByIndex(SNAP_OPTS.indexOf(4));
    snapRange.value = String(SNAP_OPTS.indexOf(4));

    state.realtimePreview = true;
    state.autoplay = true;
    state.snapOn = true;

    tlWinLbl.textContent = String(state.tlWinSec);
    hudOffset.textContent = String(state.audioOffsetMs);

    // disable until audio loaded
    exportBtn.disabled = true;
    undoBtn.disabled = true;
    deleteBtn.disabled = true;
    clearNotesBtn.disabled = true;
    tpAdd.disabled = true;
    tpSort.disabled = true;
    tpReset.disabled = true;
    autoBpmBtn.disabled = true;
    bookmarkBtn.disabled = true;

    renderTPList();
    renderBookmarks();
    updateComboOverlay();

    requestAnimationFrame(loop);
  }

  init();
})();
</script>
</body>
</html>

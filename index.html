<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Mania Editor V3 — osu-like (4K–7K)</title>
  <style>
    :root{
      --bg:#0b0c0f;
      --panel:#11141a;
      --panel2:#0e1117;
      --fg:#eaeef6;
      --muted:#9aa4b2;
      --border:rgba(255,255,255,.10);
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --danger:#fb7185;
      --ok:#86efac;
      --r:12px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg); font-family:var(--font);
      display:flex; flex-direction:column;
    }
    header{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .group{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background:var(--panel); border:1px solid var(--border);
      padding:10px; border-radius:var(--r);
    }
    label{
      font-size:12px; color:var(--muted);
      display:flex; flex-direction:column; gap:6px;
    }
    input[type="number"], select, button, input[type="text"]{
      background:var(--panel2); color:var(--fg);
      border:1px solid var(--border);
      border-radius:10px; padding:8px 10px;
      font-size:14px; outline:none;
    }
    input[type="file"]{color:var(--muted); font-size:13px}
    button{cursor:pointer; user-select:none}
    button.primary{border-color:rgba(125,211,252,.45)}
    button.ok{border-color:rgba(134,239,172,.5); color:#d1fae5}
    button.danger{border-color:rgba(251,113,133,.5); color:#ffd7df}
    button:disabled{opacity:.55; cursor:not-allowed}

    .tabs{
      display:flex; gap:8px; align-items:center;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px;
    }
    .tab{
      border-radius:999px;
      padding:8px 12px;
      border:1px solid transparent;
      background:transparent;
      color:var(--muted);
      font-size:13px;
    }
    .tab.active{
      background:rgba(125,211,252,.12);
      border-color:rgba(125,211,252,.30);
      color:var(--fg);
    }

    main{
      flex:1;
      display:grid;
      grid-template-columns: 240px 1fr 360px;
      gap:12px;
      padding:12px;
      min-height:0;
    }

    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:12px;
      min-height:0;
    }
    .panel h3{
      margin:0 0 10px 0;
      font-size:14px;
      color:#dbe5f5;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .small{font-size:12px; color:var(--muted); line-height:1.45}
    .kbd{
      font-family:var(--mono); font-size:12px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      padding:2px 6px; border-radius:8px; color:#dbe5f5;
    }

    /* Left tools */
    .toolGrid{display:grid; grid-template-columns:1fr; gap:8px}
    .toolBtn{
      display:flex; justify-content:space-between; align-items:center; gap:8px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid var(--border);
      background:var(--panel2);
      color:var(--fg);
      font-size:13px;
    }
    .toolBtn.active{
      border-color:rgba(125,211,252,.45);
      background:rgba(125,211,252,.10);
    }

    /* Center area: compose view with playfield + timeline */
    .center{
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    .canvasWrap{
      position:relative;
      flex:1;
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      background:#07090d;
      min-height:0;
    }
    canvas{display:block; width:100%; height:100%}
    .timelineWrap{
      height:140px;
      border:1px solid var(--border);
      border-radius:16px;
      overflow:hidden;
      background:#07090d;
      position:relative;
    }
    .overlayBar{
      position:absolute; top:10px; left:10px;
      display:flex; gap:8px; flex-wrap:wrap;
      z-index:5;
    }
    .badge{
      font-size:11px;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      background:rgba(255,255,255,.03);
    }

    /* Right panel lists */
    .row{
      display:flex; justify-content:space-between; gap:10px;
      padding:9px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px; color:var(--muted);
    }
    .row b{color:var(--fg); font-weight:600}
    .row:last-child{border-bottom:none}
    .list{
      border:1px solid var(--border);
      border-radius:12px;
      background:var(--panel2);
      overflow:auto;
      max-height:26vh;
    }
    .item{
      padding:9px 10px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px; color:var(--muted);
      display:flex; justify-content:space-between; gap:10px;
      cursor:pointer;
      user-select:none;
    }
    .item:last-child{border-bottom:none}
    .item.sel{background:rgba(125,211,252,.10)}
    .item b{color:var(--fg)}

    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
    .grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px}

    .hint{
      margin-top:10px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:14px;
      color:var(--muted);
      background:rgba(255,255,255,.03);
      font-size:13px;
      line-height:1.45;
    }
    .hidden{display:none !important;}
  </style>
</head>

<body>
<header>
  <div class="tabs" role="tablist" aria-label="Editor Tabs">
    <button class="tab active" id="tabCompose" data-tab="compose">Compose</button>
    <button class="tab" id="tabTiming" data-tab="timing">Timing</button>
    <button class="tab" id="tabSong" data-tab="song">Song setup</button>
  </div>

  <div class="group">
    <label>Áudio
      <input id="audioFile" type="file" accept="audio/*">
    </label>
    <button id="playBtn" class="primary" disabled>Play</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="exportBtn" class="primary" disabled>Exportar .osu</button>
  </div>

  <div class="group">
    <label>Keys
      <select id="keys">
        <option>4</option><option>5</option><option>6</option><option>7</option>
      </select>
    </label>
    <label>Beat snap (divisor)
      <select id="snap">
        <option value="1">1/1</option>
        <option value="2">1/2</option>
        <option value="3">1/3</option>
        <option value="4" selected>1/4</option>
        <option value="6">1/6</option>
        <option value="8">1/8</option>
        <option value="12">1/12</option>
        <option value="16">1/16</option>
      </select>
    </label>
    <label>Snap
      <select id="snapOn">
        <option value="on" selected>On</option>
        <option value="off">Off</option>
      </select>
    </label>
    <label>Scroll speed (px/s)
      <input id="zoom" type="number" min="200" max="9000" step="50" value="1700">
    </label>
  </div>

  <div class="group">
    <label>Playback rate
      <input id="rate" type="number" min="0.25" max="2" step="0.05" value="1">
    </label>
    <label>Metronome
      <select id="metronome" disabled>
        <option value="off" selected>Off</option>
        <option value="on">On</option>
      </select>
    </label>
    <button id="undoBtn" disabled>Undo</button>
    <button id="delBtn" class="danger" disabled>Delete</button>
  </div>
</header>

<main>
  <!-- LEFT: Tools -->
  <section class="panel" id="leftPanel">
    <h3>Ferramentas <span class="small">Compose</span></h3>
    <div class="toolGrid">
      <button class="toolBtn active" data-tool="select" id="toolSelect">
        <span><b>Select</b></span><span class="kbd">1</span>
      </button>
      <button class="toolBtn" data-tool="tap" id="toolTap">
        <span><b>Tap</b></span><span class="kbd">2</span>
      </button>
      <button class="toolBtn" data-tool="hold" id="toolHold">
        <span><b>Hold</b></span><span class="kbd">3</span>
      </button>
      <button class="toolBtn" data-tool="erase" id="toolErase">
        <span><b>Erase</b></span><span class="kbd">4</span>
      </button>
    </div>

    <div class="hint">
      Layout inspirado no fluxo do editor do osu!: <span class="kbd">Compose</span> pra criar objetos,
      <span class="kbd">Timing</span> pra timing sections e (no osu) hitsounds, e <span class="kbd">Song setup</span> pra metadata. :contentReference[oaicite:1]{index=1}
    </div>
  </section>

  <!-- CENTER: Playfield + Timeline -->
  <section class="center">
    <div class="canvasWrap" id="playWrap">
      <div class="overlayBar">
        <span class="badge">Tempo: <span id="lblTime">0</span> ms</span>
        <span class="badge">Notas: <span id="lblCount">0</span></span>
        <span class="badge">TP: <span id="lblTP">—</span></span>
        <span class="badge">Tool: <span id="lblTool">select</span></span>
      </div>
      <canvas id="playCanvas"></canvas>
    </div>

    <div class="timelineWrap" id="timeWrap">
      <div class="overlayBar">
        <span class="badge">Timeline window: <span id="lblWin">8</span>s</span>
        <span class="badge">Waveform: <span id="lblWF">—</span></span>
      </div>
      <canvas id="timeCanvas"></canvas>
    </div>
  </section>

  <!-- RIGHT: Tabbed panel -->
  <section class="panel" id="rightPanel">
    <!-- Compose properties -->
    <div id="rightCompose">
      <h3>Propriedades</h3>
      <div class="row"><span>Seleção</span><b id="selInfo">—</b></div>
      <div class="grid2" style="margin-top:10px">
        <label>Time (ms)
          <input id="propTime" type="number" step="1" disabled>
        </label>
        <label>Lane (1..K)
          <input id="propLane" type="number" step="1" min="1" max="7" disabled>
        </label>
        <label>Type
          <select id="propType" disabled>
            <option value="tap">tap</option>
            <option value="hold">hold</option>
          </select>
        </label>
        <label>End (ms) (hold)
          <input id="propEnd" type="number" step="1" disabled>
        </label>
      </div>

      <h3 style="margin-top:14px">Hitsound (simples)</h3>
      <div class="grid2">
        <label>Flags
          <select id="hsFlags" disabled>
            <option value="0">Normal (0)</option>
            <option value="2">Whistle (2)</option>
            <option value="4">Finish (4)</option>
            <option value="8">Clap (8)</option>
          </select>
        </label>
        <label>Volume (0..100)
          <input id="hsVol" type="number" min="0" max="100" step="5" value="0" disabled>
        </label>
      </div>

      <h3 style="margin-top:14px">Notas (recentes)</h3>
      <div class="list" id="noteList"></div>

      <div class="hint">
        <div><b>Dicas</b>:</div>
        <div>• Clique na <b>timeline</b> pra navegar rápido.</div>
        <div>• Se o snap estiver te “lutando”, coloca <b>Snap Off</b> e posiciona livre.</div>
        <div>• Wheel no playfield = “andar” pelo áudio sem dor.</div>
      </div>
    </div>

    <!-- Timing -->
    <div id="rightTiming" class="hidden">
      <h3>Timing Points</h3>
      <div class="grid3" style="margin-bottom:10px">
        <button id="addTP" class="ok" disabled>Add TP @ tempo</button>
        <button id="sortTP" disabled>Ordenar</button>
        <button id="resetTP" class="danger" disabled>Reset</button>
      </div>
      <div class="list" id="tpList" style="max-height:42vh"></div>

      <div class="hint">
        No osu, a aba Timing gerencia timing sections e controle de hitsounds; aqui você controla os BPM changes (timing points). :contentReference[oaicite:2]{index=2}
      </div>
    </div>

    <!-- Song setup -->
    <div id="rightSong" class="hidden">
      <h3>Song setup</h3>
      <div class="grid2">
        <label>Title <input id="metaTitle" type="text" value="WebManiaEditor"/></label>
        <label>Artist <input id="metaArtist" type="text" value="Unknown"/></label>
        <label>Creator <input id="metaCreator" type="text" value="reze"/></label>
        <label>Version <input id="metaVersion" type="text" value="Easy"/></label>
      </div>
      <div class="hint">
        Metadata e coisas “universais” do beatmap ficam aqui (igual a ideia do Song setup no osu). :contentReference[oaicite:3]{index=3}
      </div>
    </div>
  </section>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // Elements
  const audioFile = $("audioFile");
  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const exportBtn = $("exportBtn");
  const undoBtn = $("undoBtn");
  const delBtn = $("delBtn");

  const keysSel = $("keys");
  const snapSel = $("snap");
  const snapOnSel = $("snapOn");
  const zoomIn = $("zoom");
  const rateIn = $("rate");
  const metronomeSel = $("metronome");

  const tabCompose = $("tabCompose");
  const tabTiming = $("tabTiming");
  const tabSong = $("tabSong");
  const rightCompose = $("rightCompose");
  const rightTiming = $("rightTiming");
  const rightSong = $("rightSong");

  const toolButtons = Array.from(document.querySelectorAll(".toolBtn"));
  const lblTime = $("lblTime");
  const lblCount = $("lblCount");
  const lblTP = $("lblTP");
  const lblTool = $("lblTool");
  const lblWin = $("lblWin");
  const lblWF = $("lblWF");

  const playWrap = $("playWrap");
  const playCanvas = $("playCanvas");
  const pctx = playCanvas.getContext("2d");

  const timeWrap = $("timeWrap");
  const timeCanvas = $("timeCanvas");
  const tctx = timeCanvas.getContext("2d");

  const selInfo = $("selInfo");
  const noteList = $("noteList");

  const propTime = $("propTime");
  const propLane = $("propLane");
  const propType = $("propType");
  const propEnd = $("propEnd");
  const hsFlags = $("hsFlags");
  const hsVol = $("hsVol");

  const addTPBtn = $("addTP");
  const sortTPBtn = $("sortTP");
  const resetTPBtn = $("resetTP");
  const tpList = $("tpList");

  const metaTitle = $("metaTitle");
  const metaArtist = $("metaArtist");
  const metaCreator = $("metaCreator");
  const metaVersion = $("metaVersion");

  // State
  const state = {
    keys: 4,
    snap: 4,
    snapOn: true,
    scrollPxPerSec: 1700,
    rate: 1,
    timelineWindowSec: 8,

    // audio
    ac: null,
    buffer: null,
    source: null,
    startedAt: 0,
    startOffsetSec: 0,
    isPlaying: false,
    timeMs: 0,

    // waveform peaks
    wf: {
      ready: false,
      peaks: null, // Float32Array
      blockSize: 2048,
      blockSec: 0,
      max: 1,
      progress: 0
    },

    // timing points: {id, t, bpm, meter}
    timing: [{ id: uid(), t: 0, bpm: 180, meter: 4 }],

    // notes: {id, lane, t, type, end, hs, vol}
    notes: [],
    selected: new Set(),
    undo: [],

    tool: "select",

    drag: {
      down: false,
      mode: "none", // none | holdCreate | move | box
      startX: 0, startY: 0,
      box: null,
      moveSnap: null, // Map id -> base note
      holdId: null
    },

    timelineDrag: false,

    metronome: { on: false, lastBeatIndex: null }
  };

  function uid(){
    return Math.random().toString(36).slice(2,10);
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  // Geometry
  function resizeCanvas(canvas, wrap){
    const r = wrap.getBoundingClientRect();
    canvas.width = Math.floor(r.width * devicePixelRatio);
    canvas.height = Math.floor(r.height * devicePixelRatio);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  const playRO = new ResizeObserver(()=> resizeCanvas(playCanvas, playWrap));
  const timeRO = new ResizeObserver(()=> resizeCanvas(timeCanvas, timeWrap));
  playRO.observe(playWrap);
  timeRO.observe(timeWrap);
  resizeCanvas(playCanvas, playWrap);
  resizeCanvas(timeCanvas, timeWrap);

  function PW(){ return playCanvas.width / devicePixelRatio; }
  function PH(){ return playCanvas.height / devicePixelRatio; }
  function TW(){ return timeCanvas.width / devicePixelRatio; }
  function TH(){ return timeCanvas.height / devicePixelRatio; }

  function centerY(){ return Math.floor(PH() * 0.55); }
  function pxPerMs(){ return state.scrollPxPerSec / 1000; }
  function laneW(){ return PW() / state.keys; }

  function xFromLane(l){ return l * laneW(); }
  function laneFromX(x){ return clamp(Math.floor(x / laneW()), 0, state.keys - 1); }

  function yFromTime(tMs){
    return centerY() - (tMs - state.timeMs) * pxPerMs();
  }
  function timeFromY(y){
    return state.timeMs + (centerY() - y) / pxPerMs();
  }

  // Timing helpers
  function normalizeTiming(){
    state.timing.sort((a,b)=>a.t-b.t);
    const out = [];
    for(const tp of state.timing){
      if(out.length && out[out.length-1].t === tp.t) out[out.length-1] = tp;
      else out.push(tp);
    }
    state.timing = out;
  }
  function activeTP(ms){
    normalizeTiming();
    let best = state.timing[0];
    for(const tp of state.timing){
      if(tp.t <= ms) best = tp;
      else break;
    }
    return best;
  }
  function beatLenMsAt(ms){
    const tp = activeTP(ms);
    return 60000 / tp.bpm;
  }
  function snapMsAt(ms){
    return beatLenMsAt(ms) / state.snap;
  }
  function quantizeAt(ms){
    if(!state.snapOn) return ms;
    const tp = activeTP(ms);
    const step = (60000 / tp.bpm) / state.snap;
    const base = tp.t;
    const n = Math.round((ms - base) / step);
    return base + n * step;
  }

  // Undo
  function pushUndo(){
    state.undo.push(JSON.stringify({
      notes: state.notes,
      timing: state.timing,
      keys: state.keys,
      snap: state.snap,
      snapOn: state.snapOn,
      scroll: state.scrollPxPerSec,
      rate: state.rate,
      meta: getMeta()
    }));
    if(state.undo.length > 200) state.undo.shift();
    undoBtn.disabled = state.undo.length === 0;
  }
  function doUndo(){
    const raw = state.undo.pop();
    if(!raw) return;
    const s = JSON.parse(raw);
    state.notes = s.notes || [];
    state.timing = s.timing || state.timing;
    state.keys = s.keys ?? state.keys;
    state.snap = s.snap ?? state.snap;
    state.snapOn = s.snapOn ?? state.snapOn;
    state.scrollPxPerSec = s.scroll ?? state.scrollPxPerSec;
    state.rate = s.rate ?? state.rate;
    if(s.meta) setMeta(s.meta);

    keysSel.value = String(state.keys);
    snapSel.value = String(state.snap);
    snapOnSel.value = state.snapOn ? "on" : "off";
    zoomIn.value = String(state.scrollPxPerSec);
    rateIn.value = String(state.rate);

    state.selected.clear();
    updateSelectionUI();
    renderTimingUI();
    renderNoteList();
    undoBtn.disabled = state.undo.length === 0;
  }

  // Audio
  async function ensureAC(){
    if(state.ac) return state.ac;
    state.ac = new (window.AudioContext || window.webkitAudioContext)();
    return state.ac;
  }
  function cleanupSource(){
    try{ if(state.source) state.source.stop(); } catch(e){}
    state.source = null;
  }
  async function loadAudio(file){
    const ac = await ensureAC();
    const arr = await file.arrayBuffer();
    state.buffer = await ac.decodeAudioData(arr);

    state.timeMs = 0;
    state.startOffsetSec = 0;
    state.isPlaying = false;
    cleanupSource();

    playBtn.disabled = false;
    stopBtn.disabled = false;
    exportBtn.disabled = false;

    addTPBtn.disabled = false;
    sortTPBtn.disabled = false;
    resetTPBtn.disabled = false;
    metronomeSel.disabled = false;

    // build waveform
    state.wf.ready = false;
    state.wf.peaks = null;
    lblWF.textContent = "gerando…";
    buildPeaks();

    renderTimingUI();
  }

  function play(){
    if(!state.buffer) return;
    ensureAC().then(async ac => {
      if(ac.state === "suspended") await ac.resume();
      cleanupSource();
      const src = ac.createBufferSource();
      src.buffer = state.buffer;
      src.playbackRate.value = state.rate;
      src.connect(ac.destination);

      state.startedAt = ac.currentTime;
      src.start(0, state.startOffsetSec);

      state.source = src;
      state.isPlaying = true;
      playBtn.textContent = "Pause";

      state.metronome.lastBeatIndex = null;

      src.onended = () => {
        if(state.isPlaying){
          state.isPlaying = false;
          playBtn.textContent = "Play";
        }
      };
    });
  }

  function pause(){
    if(!state.ac) return;
    const ac = state.ac;

    const playedSec = (ac.currentTime - state.startedAt) * state.rate;
    state.startOffsetSec += playedSec;

    cleanupSource();
    state.isPlaying = false;
    playBtn.textContent = "Play";
  }

  function stop(){
    pause();
    state.startOffsetSec = 0;
    state.timeMs = 0;
  }

  function seekMs(ms){
    if(!state.buffer) return;
    const max = state.buffer.duration * 1000;
    state.timeMs = clamp(ms, 0, max);
    state.startOffsetSec = state.timeMs / 1000;

    if(state.isPlaying){
      pause();
      play();
    }
  }

  function updateTimeFromAudio(){
    if(!state.isPlaying || !state.ac) return;
    const ac = state.ac;

    const playedSec = (ac.currentTime - state.startedAt) * state.rate;
    const tSec = state.startOffsetSec + playedSec;
    const ms = tSec * 1000;
    state.timeMs = clamp(ms, 0, state.buffer.duration * 1000);
  }

  // Metronome (simple tick)
  function metronomeTick(){
    if(!state.metronome.on) return;
    if(!state.isPlaying) return;
    if(!state.ac) return;

    const tp = activeTP(state.timeMs);
    const beatLen = 60000 / tp.bpm;
    const base = tp.t;

    const beatIndex = Math.floor((state.timeMs - base) / beatLen);
    if(state.metronome.lastBeatIndex === beatIndex) return;
    state.metronome.lastBeatIndex = beatIndex;

    // short beep
    try{
      const ac = state.ac;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      osc.type = "square";
      osc.frequency.value = 880;
      gain.gain.value = 0.03;

      osc.connect(gain);
      gain.connect(ac.destination);

      const now = ac.currentTime;
      osc.start(now);
      osc.stop(now + 0.03);
    } catch(e){}
  }

  // Waveform peaks for timeline
  function buildPeaks(){
    const buf = state.buffer;
    if(!buf) return;

    const wf = state.wf;
    const dur = buf.duration;
    wf.blockSize = dur > 240 ? 4096 : (dur > 120 ? 2048 : 1024);

    const channels = buf.numberOfChannels;
    const len = buf.length;
    const block = wf.blockSize;
    const blocks = Math.ceil(len / block);

    wf.peaks = new Float32Array(blocks);
    wf.blockSec = block / buf.sampleRate;

    const ch = [];
    for(let c=0;c<channels;c++) ch.push(buf.getChannelData(c));

    let i=0, max=0;

    function step(){
      const t0 = performance.now();
      const budget = 12;

      while(i < blocks && performance.now() - t0 < budget){
        const start = i * block;
        const end = Math.min(len, start + block);
        let peak=0;

        for(let s=start; s<end; s++){
          let v=0;
          for(let c=0;c<channels;c++) v += ch[c][s];
          v /= channels;
          const a = Math.abs(v);
          if(a > peak) peak = a;
        }
        wf.peaks[i] = peak;
        if(peak > max) max = peak;
        i++;
      }

      wf.progress = i / blocks;
      lblWF.textContent = wf.progress >= 1 ? "ok" : Math.round(wf.progress*100) + "%";

      if(i < blocks){
        requestAnimationFrame(step);
      } else {
        wf.max = max || 1;
        wf.ready = true;
        lblWF.textContent = "ok";
      }
    }

    requestAnimationFrame(step);
  }

  function ampAtMs(ms){
    const wf = state.wf;
    if(!wf.ready || !wf.peaks) return 0;
    const sec = ms / 1000;
    const idx = Math.floor(sec / wf.blockSec);
    if(idx < 0 || idx >= wf.peaks.length) return 0;
    return wf.peaks[idx] / wf.max;
  }

  // Notes
  function sortNotes(){
    state.notes.sort((a,b)=>a.t-b.t || a.lane-b.lane);
  }

  function addNote(note){
    pushUndo();
    state.notes.push(note);
    sortNotes();
    state.selected.clear();
    state.selected.add(note.id);
    updateSelectionUI();
    renderNoteList();
  }

  function deleteSelection(){
    if(state.selected.size === 0) return;
    pushUndo();
    state.notes = state.notes.filter(n => !state.selected.has(n.id));
    state.selected.clear();
    updateSelectionUI();
    renderNoteList();
  }

  function getSelectedNotes(){
    const ids = state.selected;
    return state.notes.filter(n => ids.has(n.id));
  }

  function updateSelectionUI(){
    if(state.selected.size === 0){
      selInfo.textContent = "—";
      delBtn.disabled = true;
      setPropsDisabled(true);
      return;
    }
    delBtn.disabled = false;

    if(state.selected.size === 1){
      const n = getSelectedNotes()[0];
      selInfo.textContent = `lane ${n.lane+1} @ ${Math.round(n.t)}ms`;
      setPropsDisabled(false);
      fillPropsFromNote(n);
    } else {
      selInfo.textContent = `${state.selected.size} notas`;
      setPropsDisabled(true);
    }
  }

  function setPropsDisabled(dis){
    propTime.disabled = dis;
    propLane.disabled = dis;
    propType.disabled = dis;
    propEnd.disabled = dis;
    hsFlags.disabled = dis;
    hsVol.disabled = dis;
  }

  function fillPropsFromNote(n){
    propTime.value = Math.round(n.t);
    propLane.value = n.lane + 1;
    propType.value = n.type;
    propEnd.value = Math.round(n.end ?? n.t);
    hsFlags.value = String(n.hs ?? 0);
    hsVol.value = String(n.vol ?? 0);
  }

  function applyPropsToSelected(){
    if(state.selected.size !== 1) return;
    const n = getSelectedNotes()[0];
    if(!n) return;

    pushUndo();

    const t = Number(propTime.value)||0;
    const lane = clamp((Number(propLane.value)||1) - 1, 0, state.keys - 1);
    const type = propType.value === "hold" ? "hold" : "tap";
    let end = Number(propEnd.value)||t;
    const hs = Number(hsFlags.value)||0;
    const vol = clamp(Number(hsVol.value)||0, 0, 100);

    n.lane = lane;
    n.t = state.snapOn ? quantizeAt(t) : t;

    if(type === "tap"){
      n.type = "tap";
      n.end = n.t;
    } else {
      n.type = "hold";
      end = Math.max(n.t + 1, state.snapOn ? quantizeAt(end) : end);
      n.end = end;
    }
    n.hs = hs;
    n.vol = vol;

    sortNotes();
    renderNoteList();
    updateSelectionUI();
  }

  // Hit-testing
  function findNoteAt(mx, my){
    const lw = laneW();
    const lane = laneFromX(mx);
    const x0 = xFromLane(lane);

    for(let i=state.notes.length-1;i>=0;i--){
      const n = state.notes[i];
      if(n.lane !== lane) continue;

      const y = yFromTime(n.t);
      const pad = 7;
      const rectW = lw - pad*2;
      const rectH = 12;

      // head
      const rx = x0 + pad, ry = y - rectH/2, rw = rectW, rh = rectH;
      if(mx >= rx && mx <= rx+rw && my >= ry && my <= ry+rh) return n;

      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);
        const barX = x0 + lw/2 - 3;
        if(mx >= barX-7 && mx <= barX+13 && my >= top-7 && my <= bot+7) return n;
      }
    }
    return null;
  }

  // Rendering
  function drawPlayfield(){
    const w = PW(), h = PH();
    pctx.clearRect(0,0,w,h);
    pctx.fillStyle = "#07090d";
    pctx.fillRect(0,0,w,h);

    // lanes
    const lw = laneW();
    for(let i=0;i<state.keys;i++){
      pctx.fillStyle = "rgba(255,255,255,.04)";
      pctx.fillRect(i*lw, 0, lw-1, h);
      pctx.fillStyle = "rgba(255,255,255,.08)";
      pctx.fillRect(i*lw, 0, 1, h);
    }
    pctx.fillStyle = "rgba(255,255,255,.10)";
    pctx.fillRect(w-1,0,1,h);

    // faint waveform in background (optional)
    if(state.wf.ready){
      pctx.globalAlpha = 0.12;
      pctx.strokeStyle = "rgba(125,211,252,.9)";
      pctx.lineWidth = 1;
      pctx.beginPath();
      const mid = w*0.5;
      const maxX = w*0.48;
      for(let y=0; y<=h; y+=3){
        const t = timeFromY(y);
        const a = ampAtMs(t);
        const x = mid + (a*maxX);
        if(y===0) pctx.moveTo(x,y); else pctx.lineTo(x,y);
      }
      pctx.stroke();
      pctx.globalAlpha = 1;
    }

    // grid lines (snap)
    const viewMs = h / pxPerMs();
    const tMin = state.timeMs - viewMs*0.65;
    const tMax = state.timeMs + viewMs*0.45;

    // draw per segment (timing points)
    normalizeTiming();
    const tps = state.timing.slice();
    for(let i=0;i<tps.length;i++){
      const tp = tps[i];
      const next = tps[i+1];
      const segStart = Math.max(tMin, tp.t);
      const segEnd = Math.min(tMax, next ? next.t : Infinity);
      if(segEnd <= segStart) continue;

      const beatLen = 60000 / tp.bpm;
      const meter = tp.meter || 4;
      const step = beatLen / state.snap;

      const base = tp.t;
      const n0 = Math.ceil((segStart - base) / step);
      for(let t = base + n0*step; t <= segEnd; t += step){
        const y = yFromTime(t);
        if(y < -50 || y > h+50) continue;

        const rel = t - base;
        const beatIndex = Math.round(rel / beatLen);
        const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
        const isBar = isBeat && (beatIndex % meter === 0);

        pctx.strokeStyle = isBar ? "rgba(255,255,255,.18)"
                      : isBeat ? "rgba(255,255,255,.13)"
                               : "rgba(255,255,255,.07)";
        pctx.lineWidth = isBar ? 1.7 : (isBeat ? 1.2 : 1);
        pctx.beginPath();
        pctx.moveTo(0,y);
        pctx.lineTo(w,y);
        pctx.stroke();
      }
    }

    // playhead
    pctx.strokeStyle = "rgba(125,211,252,.85)";
    pctx.lineWidth = 2;
    pctx.beginPath();
    pctx.moveTo(0, centerY());
    pctx.lineTo(w, centerY());
    pctx.stroke();

    // notes
    for(const n of state.notes){
      const y = yFromTime(n.t);
      if(y < -140 || y > h+140) continue;

      const x0 = xFromLane(n.lane);
      const pad = 7;
      const rectW = lw - pad*2;
      const rectH = 12;

      const isSel = state.selected.has(n.id);

      if(n.type === "hold"){
        const y2 = yFromTime(n.end);
        const top = Math.min(y,y2);
        const bot = Math.max(y,y2);

        pctx.fillStyle = isSel ? "rgba(167,139,250,.40)" : "rgba(255,255,255,.16)";
        pctx.fillRect(x0 + lw/2 - 3, top, 6, bot-top);

        pctx.fillStyle = isSel ? "rgba(167,139,250,.90)" : "rgba(255,255,255,.70)";
        pctx.fillRect(x0 + pad, y2 - rectH/2, rectW, rectH);
      }

      pctx.fillStyle = isSel ? "rgba(125,211,252,.92)" : "rgba(255,255,255,.70)";
      pctx.fillRect(x0 + pad, y - rectH/2, rectW, rectH);

      if(isSel){
        pctx.strokeStyle = "rgba(125,211,252,.95)";
        pctx.lineWidth = 1.2;
        pctx.strokeRect(x0 + pad, y - rectH/2, rectW, rectH);
      }
    }

    // box select
    if(state.drag.mode === "box" && state.drag.box){
      const b = rectNorm(state.drag.box);
      pctx.fillStyle = "rgba(125,211,252,.12)";
      pctx.strokeStyle = "rgba(125,211,252,.7)";
      pctx.lineWidth = 1.4;
      pctx.fillRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
      pctx.strokeRect(b.x0,b.y0,b.x1-b.x0,b.y1-b.y0);
    }
  }

  function rectNorm(b){
    return { x0: Math.min(b.x0,b.x1), y0: Math.min(b.y0,b.y1), x1: Math.max(b.x0,b.x1), y1: Math.max(b.y0,b.y1) };
  }

  // Timeline mapping (window around playhead)
  function timelineRange(){
    const half = (state.timelineWindowSec * 1000) / 2;
    const start = state.timeMs - half;
    const end = state.timeMs + half;
    return { start, end };
  }
  function xFromTime(ms){
    const {start,end} = timelineRange();
    const w = TW();
    const t = (ms - start) / (end - start);
    return t * w;
  }
  function timeFromX(x){
    const {start,end} = timelineRange();
    const w = TW();
    const t = x / w;
    return start + t * (end - start);
  }

  function drawTimeline(){
    const w = TW(), h = TH();
    tctx.clearRect(0,0,w,h);
    tctx.fillStyle = "#07090d";
    tctx.fillRect(0,0,w,h);

    const {start,end} = timelineRange();

    // waveform
    if(state.wf.ready){
      tctx.globalAlpha = 0.35;
      tctx.strokeStyle = "rgba(125,211,252,.85)";
      tctx.lineWidth = 1;
      tctx.beginPath();
      for(let x=0; x<=w; x+=2){
        const ms = timeFromX(x);
        const a = ampAtMs(ms);
        const y = h*0.5;
        const amp = a * (h*0.42);
        tctx.moveTo(x, y-amp);
        tctx.lineTo(x, y+amp);
      }
      tctx.stroke();
      tctx.globalAlpha = 1;
    }

    // beat lines
    normalizeTiming();
    const tp = activeTP(state.timeMs);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const base = tp.t;

    const n0 = Math.ceil((start - base) / step);
    for(let t = base + n0*step; t <= end; t += step){
      const x = xFromTime(t);
      const rel = t - base;
      const beatIndex = Math.round(rel / beatLen);
      const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
      const isBar = isBeat && (beatIndex % (tp.meter||4) === 0);

      tctx.strokeStyle = isBar ? "rgba(255,255,255,.20)"
                    : isBeat ? "rgba(255,255,255,.13)"
                             : "rgba(255,255,255,.07)";
      tctx.lineWidth = isBar ? 1.6 : (isBeat ? 1.1 : 1);
      tctx.beginPath();
      tctx.moveTo(x, 0);
      tctx.lineTo(x, h);
      tctx.stroke();
    }

    // notes markers (per lane)
    const laneH = h / state.keys;
    for(const n of state.notes){
      if(n.t < start || n.t > end) continue;
      const x = xFromTime(n.t);
      const y = (n.lane + 0.5) * laneH;
      tctx.fillStyle = state.selected.has(n.id) ? "rgba(167,139,250,.90)" : "rgba(255,255,255,.75)";
      tctx.fillRect(x-2, y-6, 4, 12);
      if(n.type === "hold"){
        const x2 = xFromTime(n.end);
        tctx.fillStyle = state.selected.has(n.id) ? "rgba(167,139,250,.35)" : "rgba(255,255,255,.18)";
        tctx.fillRect(Math.min(x,x2), y-2, Math.abs(x2-x), 4);
      }
    }

    // playhead in timeline
    const xPH = xFromTime(state.timeMs);
    tctx.strokeStyle = "rgba(125,211,252,.9)";
    tctx.lineWidth = 2;
    tctx.beginPath();
    tctx.moveTo(xPH, 0);
    tctx.lineTo(xPH, h);
    tctx.stroke();

    // window label
    lblWin.textContent = String(state.timelineWindowSec);
  }

  function renderLoop(){
    updateTimeFromAudio();
    metronomeTick();

    const tp = activeTP(state.timeMs);
    lblTime.textContent = String(Math.round(state.timeMs));
    lblCount.textContent = String(state.notes.length);
    lblTP.textContent = `${tp.bpm.toFixed(3)} BPM @ ${Math.round(tp.t)}ms`;
    lblTool.textContent = state.tool;

    drawPlayfield();
    drawTimeline();

    requestAnimationFrame(renderLoop);
  }

  // Note list UI
  function renderNoteList(){
    const items = state.notes.slice().sort((a,b)=>b.t-a.t).slice(0,120);
    noteList.innerHTML = items.map(n => {
      const sel = state.selected.has(n.id);
      const t = Math.round(n.t);
      const extra = n.type === "hold" ? ` → ${Math.round(n.end)}ms` : "";
      return `<div class="item ${sel ? "sel":""}" data-id="${n.id}">
        <span><b>${n.type.toUpperCase()}</b> lane ${n.lane+1}</span>
        <span>${t}ms${extra}</span>
      </div>`;
    }).join("") || `<div class="row"><span>—</span><span>Sem notas ainda</span></div>`;

    noteList.querySelectorAll(".item").forEach(el => {
      el.addEventListener("click", (e) => {
        const id = el.getAttribute("data-id");
        if(e.ctrlKey || e.metaKey){
          if(state.selected.has(id)) state.selected.delete(id);
          else state.selected.add(id);
        } else {
          state.selected.clear();
          state.selected.add(id);
        }
        updateSelectionUI();
        renderNoteList();
      });
    });
  }

  // Timing UI
  function renderTimingUI(){
    normalizeTiming();
    tpList.innerHTML = state.timing.map(tp => {
      return `
        <div class="item" style="cursor:default" data-tpid="${tp.id}">
          <span>
            <b>${Math.round(tp.t)}ms</b> • ${tp.bpm.toFixed(3)} BPM • ${tp.meter||4}/4
          </span>
          <span style="display:flex; gap:8px; align-items:center;">
            <input data-k="t" type="number" step="1" value="${Math.round(tp.t)}" style="width:110px">
            <input data-k="bpm" type="number" step="0.001" value="${tp.bpm}" style="width:110px">
            <button class="danger" data-act="del">X</button>
          </span>
        </div>
      `;
    }).join("");

    tpList.querySelectorAll(".item").forEach(row => {
      const id = row.getAttribute("data-tpid");
      const tp = state.timing.find(x => x.id === id);
      if(!tp) return;

      const tIn = row.querySelector('input[data-k="t"]');
      const bpmIn = row.querySelector('input[data-k="bpm"]');
      const del = row.querySelector('button[data-act="del"]');

      tIn.addEventListener("change", () => {
        pushUndo();
        tp.t = Math.max(0, Math.round(Number(tIn.value)||0));
        normalizeTiming();
        renderTimingUI();
      });
      bpmIn.addEventListener("change", () => {
        pushUndo();
        tp.bpm = clamp(Number(bpmIn.value)||180, 30, 400);
        normalizeTiming();
        renderTimingUI();
      });
      del.addEventListener("click", () => {
        if(state.timing.length <= 1) return;
        pushUndo();
        state.timing = state.timing.filter(x => x.id !== id);
        normalizeTiming();
        renderTimingUI();
      });
    });
  }

  // Export (.osu mania)
  function laneToOsuX(lane){
    const x = Math.floor((lane + 0.5) * 512 / state.keys);
    return clamp(x, 0, 511);
  }

  function getMeta(){
    return {
      title: metaTitle?.value ?? "WebManiaEditor",
      artist: metaArtist?.value ?? "Unknown",
      creator: metaCreator?.value ?? "reze",
      version: metaVersion?.value ?? "Easy"
    };
  }
  function setMeta(m){
    if(metaTitle) metaTitle.value = m.title ?? metaTitle.value;
    if(metaArtist) metaArtist.value = m.artist ?? metaArtist.value;
    if(metaCreator) metaCreator.value = m.creator ?? metaCreator.value;
    if(metaVersion) metaVersion.value = m.version ?? metaVersion.value;
  }

  function exportOsu(){
    const meta = getMeta();
    const audioName = (audioFile.files[0]?.name || "audio.mp3").replaceAll("\\","/");
    const keys = state.keys;

    normalizeTiming();
    sortNotes();

    const header =
`osu file format v14

[General]
AudioFilename: ${audioName}
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
SpecialStyle: 0
WidescreenStoryboard: 0

[Editor]
DistanceSpacing: 1.0
BeatDivisor: ${state.snap}
GridSize: 4
TimelineZoom: 1.0

[Metadata]
Title:${meta.title}
Artist:${meta.artist}
Creator:${meta.creator}
Version:${keys}K ${meta.version}
Source:
Tags:

[Difficulty]
HPDrainRate:5
CircleSize:${keys}
OverallDifficulty:8
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events
//Break Periods
//Storyboard Layer 0 (Background)
//Storyboard Layer 1 (Fail)
//Storyboard Layer 2 (Pass)
//Storyboard Layer 3 (Foreground)
//Storyboard Layer 4 (Overlay)
//Storyboard Sound Samples

[TimingPoints]
`;

    const tps = state.timing.map(tp => {
      const beatLen = (60000 / tp.bpm);
      return `${Math.round(tp.t)},${beatLen.toFixed(15)},${tp.meter||4},2,0,100,1,0`;
    }).join("\n");

    const hitHeader = `

[HitObjects]
`;

    const hitLines = state.notes.map(n => {
      const x = laneToOsuX(n.lane);
      const y = 192;
      const t = Math.round(n.t);
      const hs = n.hs ?? 0;

      // hitSample: normalSet:additionSet:index:volume:filename
      const vol = clamp(n.vol ?? 0, 0, 100);
      const sample = `0:0:0:${vol}:`;

      if(n.type === "tap"){
        return `${x},${y},${t},1,${hs},${sample}`;
      } else {
        const end = Math.max(t+1, Math.round(n.end));
        return `${x},${y},${t},128,${hs},${end}:${sample}`;
      }
    }).join("\n");

    const out = header + tps + hitHeader + hitLines + "\n";
    const blob = new Blob([out], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${meta.title} - ${meta.artist} (${meta.creator}) [${keys}K ${meta.version}].osu`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Tool switching
  function setTool(tool){
    state.tool = tool;
    toolButtons.forEach(b => b.classList.toggle("active", b.getAttribute("data-tool") === tool));
  }

  // Tabs
  function setTab(name){
    [tabCompose, tabTiming, tabSong].forEach(t => t.classList.remove("active"));
    if(name === "compose") tabCompose.classList.add("active");
    if(name === "timing") tabTiming.classList.add("active");
    if(name === "song") tabSong.classList.add("active");

    rightCompose.classList.toggle("hidden", name !== "compose");
    rightTiming.classList.toggle("hidden", name !== "timing");
    rightSong.classList.toggle("hidden", name !== "song");
  }

  // Input wiring
  audioFile.addEventListener("change", async () => {
    const f = audioFile.files[0];
    if(!f) return;
    await loadAudio(f);
  });

  playBtn.addEventListener("click", async () => {
    if(!state.buffer) return;
    if(!state.ac) await ensureAC();
    if(state.isPlaying) pause(); else play();
  });
  stopBtn.addEventListener("click", stop);
  exportBtn.addEventListener("click", exportOsu);

  undoBtn.addEventListener("click", doUndo);
  delBtn.addEventListener("click", deleteSelection);

  keysSel.addEventListener("change", () => {
    pushUndo();
    state.keys = parseInt(keysSel.value,10);
    // clamp lanes
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);
    // clamp selection props
    updateSelectionUI();
    renderNoteList();
  });

  snapSel.addEventListener("change", () => state.snap = parseInt(snapSel.value,10));
  snapOnSel.addEventListener("change", () => state.snapOn = (snapOnSel.value === "on"));
  zoomIn.addEventListener("change", () => state.scrollPxPerSec = parseInt(zoomIn.value,10));

  rateIn.addEventListener("change", () => {
    state.rate = clamp(parseFloat(rateIn.value)||1, 0.25, 2);
    if(state.isPlaying){
      pause();
      play();
    }
  });

  metronomeSel.addEventListener("change", () => {
    state.metronome.on = (metronomeSel.value === "on");
  });

  tabCompose.addEventListener("click", () => setTab("compose"));
  tabTiming.addEventListener("click", () => setTab("timing"));
  tabSong.addEventListener("click", () => setTab("song"));

  toolButtons.forEach(btn => {
    btn.addEventListener("click", () => setTool(btn.getAttribute("data-tool")));
  });

  // Timing buttons
  addTPBtn.addEventListener("click", () => {
    pushUndo();
    const ms = Math.round(state.timeMs);
    const cur = activeTP(ms);
    state.timing.push({ id: uid(), t: ms, bpm: cur.bpm, meter: cur.meter||4 });
    normalizeTiming();
    renderTimingUI();
  });
  sortTPBtn.addEventListener("click", () => {
    pushUndo();
    normalizeTiming();
    renderTimingUI();
  });
  resetTPBtn.addEventListener("click", () => {
    pushUndo();
    state.timing = [{ id: uid(), t: 0, bpm: 180, meter: 4 }];
    renderTimingUI();
  });

  // Props change
  [propTime, propLane, propType, propEnd, hsFlags, hsVol].forEach(el => {
    el.addEventListener("change", applyPropsToSelected);
  });

  // Mouse helpers
  function mousePos(e, wrap){
    const r = wrap.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  // Playfield wheel => scroll time
  playWrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    if(!state.buffer) return;
    const delta = e.deltaY;
    const ms = state.timeMs + delta * 2.2;
    seekMs(ms);
  }, {passive:false});

  // Timeline interactions (seek)
  function timelineSeekAtX(x){
    const t = timeFromX(x);
    seekMs(t);
  }

  timeWrap.addEventListener("mousedown", (e) => {
    if(!state.buffer) return;
    state.timelineDrag = true;
    const m = mousePos(e, timeWrap);
    timelineSeekAtX(m.x);
  });

  window.addEventListener("mousemove", (e) => {
    if(!state.timelineDrag) return;
    const m = mousePos(e, timeWrap);
    timelineSeekAtX(m.x);
  });

  window.addEventListener("mouseup", () => {
    state.timelineDrag = false;
  });

  // Box select helper
  function selectByBox(box){
    const b = rectNorm(box);
    const tMin = Math.min(quantizeAt(timeFromY(b.y1)), quantizeAt(timeFromY(b.y0)));
    const tMax = Math.max(quantizeAt(timeFromY(b.y1)), quantizeAt(timeFromY(b.y0)));

    const laneMin = laneFromX(b.x0);
    const laneMax = laneFromX(b.x1);

    state.selected.clear();
    for(const n of state.notes){
      if(n.lane < laneMin || n.lane > laneMax) continue;
      if(n.type === "tap"){
        if(n.t >= tMin && n.t <= tMax) state.selected.add(n.id);
      } else {
        // overlap
        if(!(n.end < tMin || n.t > tMax)) state.selected.add(n.id);
      }
    }
    updateSelectionUI();
    renderNoteList();
  }

  // Move selection snapshot
  function beginMove(){
    const snap = new Map();
    for(const n of state.notes){
      if(state.selected.has(n.id)) snap.set(n.id, { t:n.t, end:n.end, lane:n.lane });
    }
    state.drag.moveSnap = snap;
  }
  function applyMove(deltaLane, deltaMs){
    const snap = state.drag.moveSnap;
    if(!snap) return;
    for(const n of state.notes){
      if(!state.selected.has(n.id)) continue;
      const base = snap.get(n.id);
      if(!base) continue;

      const lane = clamp(base.lane + deltaLane, 0, state.keys - 1);
      let t = base.t + deltaMs;
      t = state.snapOn ? quantizeAt(t) : t;

      n.lane = lane;
      n.t = t;

      if(n.type === "hold"){
        let end = base.end + deltaMs;
        end = state.snapOn ? quantizeAt(end) : end;
        n.end = Math.max(n.t + 1, end);
      } else {
        n.end = n.t;
      }
    }
    sortNotes();
  }

  // Playfield mouse (tools)
  playWrap.addEventListener("mousedown", (e) => {
    if(!state.buffer) return;
    state.drag.down = true;
    const m = mousePos(e, playWrap);
    state.drag.startX = m.x; state.drag.startY = m.y;

    const hit = findNoteAt(m.x, m.y);

    if(state.tool === "select"){
      if(hit){
        if(e.ctrlKey || e.metaKey){
          if(state.selected.has(hit.id)) state.selected.delete(hit.id);
          else state.selected.add(hit.id);
        } else {
          if(!state.selected.has(hit.id)){
            state.selected.clear();
            state.selected.add(hit.id);
          }
        }
        updateSelectionUI();
        renderNoteList();

        // drag move selection
        state.drag.mode = "move";
        beginMove();
      } else {
        // start box
        state.drag.mode = "box";
        state.drag.box = { x0:m.x, y0:m.y, x1:m.x, y1:m.y };
      }
      return;
    }

    if(state.tool === "erase"){
      if(hit){
        pushUndo();
        state.notes = state.notes.filter(n => n.id !== hit.id);
        state.selected.delete(hit.id);
        updateSelectionUI();
        renderNoteList();
      }
      return;
    }

    if(state.tool === "tap"){
      const lane = laneFromX(m.x);
      const tRaw = timeFromY(m.y);
      const t = quantizeAt(tRaw);
      addNote({ id: uid(), lane, t, type:"tap", end:t, hs:0, vol:0 });
      return;
    }

    if(state.tool === "hold"){
      const lane = laneFromX(m.x);
      const t0 = quantizeAt(timeFromY(m.y));
      const id = uid();
      addNote({ id, lane, t: t0, type:"hold", end: t0 + snapMsAt(t0), hs:0, vol:0 });
      state.drag.mode = "holdCreate";
      state.drag.holdId = id;
      return;
    }
  });

  playWrap.addEventListener("mousemove", (e) => {
    if(!state.drag.down) return;
    const m = mousePos(e, playWrap);

    if(state.tool === "select" && state.drag.mode === "box" && state.drag.box){
      state.drag.box.x1 = m.x;
      state.drag.box.y1 = m.y;
      // live preview
      selectByBox(state.drag.box);
      return;
    }

    if(state.tool === "select" && state.drag.mode === "move"){
      const dxLane = laneFromX(m.x) - laneFromX(state.drag.startX);
      const dMs = quantizeAt(timeFromY(m.y)) - quantizeAt(timeFromY(state.drag.startY));
      applyMove(dxLane, dMs);
      renderNoteList();
      return;
    }

    if(state.tool === "hold" && state.drag.mode === "holdCreate"){
      const id = state.drag.holdId;
      const n = state.notes.find(x => x.id === id);
      if(!n) return;
      const end = quantizeAt(timeFromY(m.y));
      n.end = Math.max(n.t + 1, end);
      renderNoteList();
      return;
    }
  });

  window.addEventListener("mouseup", () => {
    if(state.drag.down){
      if(state.drag.mode === "move" || state.drag.mode === "holdCreate" || state.drag.mode === "box"){
        // commit undo after drag operations
        pushUndo();
      }
    }
    state.drag.down = false;
    state.drag.mode = "none";
    state.drag.box = null;
    state.drag.moveSnap = null;
    state.drag.holdId = null;
  });

  // Keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.code === "Space"){
      e.preventDefault();
      playBtn.click();
      return;
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z"){
      e.preventDefault();
      doUndo();
      return;
    }
    if(e.code === "Delete"){
      deleteSelection();
      return;
    }
    if(e.key === "1") setTool("select");
    if(e.key === "2") setTool("tap");
    if(e.key === "3") setTool("hold");
    if(e.key === "4") setTool("erase");

    // timeline window +/- (como zoom no “timeline feel”)
    if(e.key === "-" || e.key === "_"){
      state.timelineWindowSec = clamp(state.timelineWindowSec + 1, 3, 30);
    }
    if(e.key === "=" || e.key === "+"){
      state.timelineWindowSec = clamp(state.timelineWindowSec - 1, 3, 30);
    }
  });

  // Tab init
  setTab("compose");

  // Tool init
  setTool("select");

  // Metronome init
  metronomeSel.value = "off";
  state.metronome.on = false;

  // UI init
  keysSel.value = String(state.keys);
  snapSel.value = String(state.snap);
  snapOnSel.value = "on";
  zoomIn.value = String(state.scrollPxPerSec);
  rateIn.value = "1";

  // Enable metronome toggle after audio loads
  metronomeSel.disabled = true;

  // Render timing and notes
  renderTimingUI();
  renderNoteList();
  updateSelectionUI();

  // Start render loop
  requestAnimationFrame(renderLoop);

})();
</script>
</body>
</html>

<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>WebMania Editor ‚Äî osu-like layout + realtime preview</title>
  <style>
    :root{
      --bg:#0a0c10;
      --panel:rgba(20,22,28,.86);
      --panel2:rgba(28,31,40,.82);
      --stroke:rgba(255,255,255,.10);
      --stroke2:rgba(255,255,255,.06);
      --text:#e8edf7;
      --muted:#aab3c2;

      --cyan:#26d3ff;
      --cyan2:#7dd3fc;
      --yellow:#facc15;
      --red:#ef4444;
      --blue:#3b82f6;

      --r:10px;
      --shadow: 0 10px 24px rgba(0,0,0,.40);

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;

      --menuH:34px;
      --bottomH:52px;
      --leftW:330px;
      --rightW:330px;
      --waveW:300px;
      --previewW:330px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:var(--bg);
      overflow:hidden;
    }

    /* BG image layer */
    #bgLayer{
      position:fixed; inset:0;
      background:#000;
      z-index:-3;
    }
    #bgLayer::before{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(1000px 700px at 40% 35%, rgba(255,255,255,.06), transparent 55%),
                  radial-gradient(900px 700px at 70% 55%, rgba(38,211,255,.06), transparent 52%),
                  linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.65));
      z-index:1;
      pointer-events:none;
    }
    #bgImg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      filter: blur(0px);
      opacity:.35;
      z-index:0;
      pointer-events:none;
    }

    /* Top menubar */
    .menubar{
      height:var(--menuH);
      display:flex;
      align-items:center;
      gap:18px;
      padding:0 14px;
      background:rgba(18,20,26,.92);
      border-bottom:1px solid var(--stroke2);
      user-select:none;
      font-size:13px;
    }
    .menubar .item{
      color:rgba(255,255,255,.86);
      opacity:.92;
      cursor:default;
    }

    /* Main layout */
    .main{
      height: calc(100% - var(--menuH) - var(--bottomH));
      display:grid;
      grid-template-columns: var(--leftW) 1fr var(--rightW);
      gap:14px;
      padding:14px;
      min-height:0;
    }

    .col{
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    /* Panels */
    .panel{
      background:var(--panel);
      border:1px solid var(--stroke);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .panel .hd{
      padding:12px 14px;
      border-bottom:1px solid var(--stroke2);
      font-weight:700;
      letter-spacing:.6px;
      font-size:14px;
      color:rgba(255,255,255,.92);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      text-transform:uppercase;
    }
    .panel .bd{
      padding:14px;
      min-height:0;
    }

    .detailsGrid{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px 14px;
      font-size:14px;
      align-items:center;
    }
    .detailsGrid .k{ color:rgba(255,255,255,.88); }
    .detailsGrid .v{
      font-family:var(--mono);
      color:rgba(255,255,255,.92);
      opacity:.95;
    }
    .detailsGrid .v.accent{ color: var(--cyan2); }
    .detailsGrid .v.yellow{ color: var(--yellow); }

    /* Tools */
    .toolBtn{
      width:100%;
      display:flex;
      align-items:center;
      gap:12px;
      padding:12px 12px;
      border:none;
      border-radius:8px;
      background:transparent;
      color:rgba(255,255,255,.88);
      cursor:pointer;
      font-size:14px;
      text-align:left;
      user-select:none;
    }
    .toolBtn:hover{ background: rgba(255,255,255,.05); }
    .toolBtn.active{
      background: rgba(38,211,255,.14);
      outline: 1px solid rgba(38,211,255,.32);
    }
    .toolIcon{
      width:16px; height:16px;
      display:inline-block;
      flex:0 0 16px;
      opacity:.95;
    }
    .toolIcon svg{width:16px;height:16px; fill: currentColor;}
    .toolLabel{ font-weight:600; }
    .toolHint{
      margin-left:auto;
      font-family:var(--mono);
      font-size:12px;
      opacity:.70;
    }

    /* Center workspace (waveform + editor + preview) */
    .workspace{
      position:relative;
      min-height:0;
      flex:1;
      display:grid;
      grid-template-columns: var(--waveW) 1fr;
      gap:14px;
      align-items:stretch;
    }

    .wavePanel{
      position:relative;
      min-height:0;
      border-radius:10px;
      overflow:hidden;
      background: rgba(0,0,0,.35);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
    }

    .waveInner{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: 56px 1fr;
      gap:0;
      min-height:0;
    }
    .ampStrip{
      background: rgba(0,0,0,.20);
      border-right:1px solid rgba(255,255,255,.10);
      min-height:0;
      position:relative;
    }
    .ampStrip .snapBadge{
      position:absolute;
      top:8px; right:8px;
      width:30px; height:30px;
      border-radius:6px;
      background: rgba(59,130,246,.35);
      border:1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:center;
      font-family:var(--mono);
      font-weight:700;
    }
    .waveMain{
      position:relative;
      min-height:0;
      background: rgba(0,0,0,.20);
    }

    canvas{ display:block; width:100%; height:100%; }

    .zoomBtns{
      position:absolute;
      right:10px; top:62px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index:5;
      user-select:none;
    }
    .zoomBtn{
      width:34px; height:34px;
      border-radius:999px;
      background: rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.14);
      color:rgba(255,255,255,.92);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      font-weight:800;
    }
    .zoomBtn:hover{ background: rgba(0,0,0,.60); }

    .editorPanel{
      position:relative;
      min-height:0;
      border-radius:10px;
      overflow:hidden;
      background: rgba(0,0,0,.28);
      border:1px solid var(--stroke);
      box-shadow:var(--shadow);
    }

    .editorGrid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      min-height:0;
      padding:0;
    }

    /* When preview is enabled, we split the editor area */
    .editorSplit{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: 1fr; /* becomes 1fr var(--previewW) when enabled */
      gap:14px;
      padding:0;
      min-height:0;
    }
    .editorSplit.previewOn{
      grid-template-columns: 1fr var(--previewW);
    }

    .editWrap, .previewWrap{
      position:relative;
      border-radius:10px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      min-height:0;
    }

    .hudTop{
      position:absolute;
      left:10px; top:10px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      z-index:7;
      pointer-events:none;
    }
    .badge{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.86);
      backdrop-filter: blur(6px);
      white-space:nowrap;
    }
    .badge b{ font-family:var(--mono); color:#fff; font-weight:800; }

    .previewLabel{
      position:absolute;
      left:10px; top:10px;
      z-index:7;
      pointer-events:none;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      color: rgba(255,255,255,.86);
      backdrop-filter: blur(6px);
    }

    /* Right panels */
    .layerRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-radius:8px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      font-size:14px;
    }
    .layerRow .left{
      display:flex; gap:10px; align-items:center;
    }
    .check{
      width:18px; height:18px;
      border-radius:4px;
      border:1px solid rgba(255,255,255,.20);
      background: rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;
      font-size:14px; line-height:1;
    }
    .layerActions{
      display:flex; gap:10px; align-items:center;
    }
    .iconCircle{
      width:26px; height:26px;
      border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
    }
    .iconCircle.green{ color:#22c55e; }
    .iconCircle.red{ color:#ef4444; }

    .hsBtn{
      width:100%;
      display:flex;
      align-items:center;
      gap:10px;
      padding:12px 12px;
      border:none;
      border-radius:8px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-size:14px;
      cursor:pointer;
      user-select:none;
    }
    .hsBtn:hover{ background: rgba(255,255,255,.06); }
    .hsBtn.active{
      background: rgba(250,204,21,.12);
      border-color: rgba(250,204,21,.22);
    }
    .hsBtn .ico{
      width:18px; height:18px;
      display:flex; align-items:center; justify-content:center;
      opacity:.92;
    }
    .hsBtn .ico svg{width:18px;height:18px; fill: currentColor;}
    .hsVolRow{
      margin-top:12px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      align-items:center;
      color:rgba(255,255,255,.86);
      font-size:13px;
    }
    input[type="range"]{ width:100%; }

    /* Bottom bar */
    .bottom{
      height:var(--bottomH);
      display:grid;
      grid-template-columns: var(--leftW) 1fr var(--rightW);
      gap:14px;
      padding:8px 14px;
      background: rgba(18,20,26,.92);
      border-top:1px solid var(--stroke2);
      align-items:center;
      user-select:none;
    }
    .bottom .left, .bottom .right{
      display:flex; align-items:center; gap:16px;
    }
    .bottom .mid{
      display:flex; align-items:center; justify-content:center; gap:14px;
    }
    .bBtn{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25);
      color: rgba(255,255,255,.88);
      cursor:pointer;
      font-size:13px;
    }
    .bBtn:hover{ background: rgba(0,0,0,.35); }
    .bBtn.primary{
      border-color: rgba(38,211,255,.30);
      background: rgba(38,211,255,.12);
    }
    .bBtn.danger{
      border-color: rgba(239,68,68,.26);
      background: rgba(239,68,68,.10);
    }
    .bBtn .plus{ font-weight:900; font-size:16px; color: var(--cyan2); }
    .transport{
      display:flex; gap:10px; align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
    }
    .tBtn{
      width:30px; height:30px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
    }
    .tBtn svg{ width:16px; height:16px; fill: rgba(255,255,255,.92); }
    .tBtn:hover{ background: rgba(0,0,0,.55); }

    .chip{
      display:flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.28);
      color: rgba(255,255,255,.86);
      font-size:13px;
    }
    .chip b{ font-family:var(--mono); color:#fff; }
    .chip .sep{ opacity:.35; margin:0 4px; }
    .chip .link{
      opacity:.92;
      text-transform:uppercase;
      letter-spacing:.4px;
      font-size:12px;
    }

    /* Modal */
    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
      padding:18px;
    }
    .modalBackdrop.show{ display:flex; }

    .modal{
      width:min(980px, 96vw);
      max-height: 92vh;
      overflow:auto;
      background: rgba(18,20,26,.96);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
    }
    .modalHd{
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .modalHd b{ letter-spacing:.6px; text-transform:uppercase; }
    .modalBd{ padding:16px; }
    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
    .grid3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:14px; }
    .field{
      display:flex; flex-direction:column; gap:8px;
      color: rgba(255,255,255,.86);
      font-size:13px;
    }
    .field input[type="text"],
    .field input[type="number"],
    .field select{
      padding:10px 10px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      color:#fff;
      outline:none;
      font-size:14px;
    }
    .field input[type="file"]{
      color: rgba(255,255,255,.78);
      font-size:13px;
    }
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.86);
      font-size:13px;
    }
    .row input[type="checkbox"]{ transform: scale(1.1); }
    .hint{
      padding:12px;
      border-radius:12px;
      background: rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      color: rgba(255,255,255,.72);
      font-size:13px;
      line-height:1.55;
    }

    /* Responsive */
    @media (max-width: 1200px){
      :root{ --leftW: 300px; --rightW: 300px; --waveW: 280px; }
    }
    @media (max-width: 980px){
      .main{ grid-template-columns: 1fr; }
      .bottom{ grid-template-columns: 1fr; height:auto; gap:10px; }
      .bottom .left, .bottom .mid, .bottom .right{ justify-content:center; flex-wrap:wrap; }
      .col.rightCol{ display:none; }
      .col.leftCol{ order:2; }
      .workspace{ grid-template-columns: 1fr; }
    }
  </style>
</head>

<body>
  <div id="bgLayer">
    <img id="bgImg" alt="" />
  </div>

  <div class="menubar">
    <div class="item">File</div>
    <div class="item">Edit</div>
    <div class="item">View</div>
    <div class="item">Audio</div>
    <div class="item">Web</div>
    <div class="item">Tools</div>
    <div class="item">Plugins</div>
    <div class="item">Help</div>
    <div style="flex:1"></div>
    <div class="item" style="opacity:.75;font-family:var(--mono)" id="topStatus">‚Äî</div>
  </div>

  <div class="main">
    <!-- LEFT -->
    <section class="col leftCol">
      <div class="panel">
        <div class="hd">DETAILS</div>
        <div class="bd">
          <div class="detailsGrid">
            <div class="k">Object Count</div><div class="v" id="dCount">0</div>
            <div class="k">Playback Speed</div><div class="v" id="dSpeed">100%</div>
            <div class="k">BPM</div><div class="v" id="dBpm">‚Äî</div>
            <div class="k">Beat Snap</div><div class="v accent" id="dSnap">1/4th</div>
            <div class="k">Difficulty Rating</div><div class="v yellow" id="dDiff">‚Äî</div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="hd">COMPOSITION TOOLS</div>
        <div class="bd" style="padding:10px">
          <button class="toolBtn active" data-tool="select">
            <span class="toolIcon">
              <svg viewBox="0 0 24 24"><path d="M4 4l7 17 2-7 7-2L4 4z"/></svg>
            </span>
            <span class="toolLabel">Select</span>
            <span class="toolHint">1</span>
          </button>
          <button class="toolBtn" data-tool="note">
            <span class="toolIcon">
              <svg viewBox="0 0 24 24"><path d="M6 4h12v4H6zM6 10h12v10H6z"/></svg>
            </span>
            <span class="toolLabel">Note</span>
            <span class="toolHint">2</span>
          </button>
          <button class="toolBtn" data-tool="ln">
            <span class="toolIcon">
              <svg viewBox="0 0 24 24"><path d="M7 4h10v16H7zM11 7h2v10h-2z"/></svg>
            </span>
            <span class="toolLabel">Long Note</span>
            <span class="toolHint">3</span>
          </button>
          <button class="toolBtn" data-tool="erase">
            <span class="toolIcon">
              <svg viewBox="0 0 24 24"><path d="M20 20H8l-4-4L14 6l6 6-8 8M13 7l6 6" /></svg>
            </span>
            <span class="toolLabel">Erase</span>
            <span class="toolHint">4</span>
          </button>
        </div>
      </div>

      <div class="panel" style="flex:1; min-height:0">
        <div class="bd">
          <div class="hint">
            <b>Atalhos</b><br>
            ‚Ä¢ <span style="font-family:var(--mono)">Space</span> play/pause<br>
            ‚Ä¢ <span style="font-family:var(--mono)">Wheel</span> rola o tempo<br>
            ‚Ä¢ <span style="font-family:var(--mono)">Alt + arrastar</span> scrub (voltar/avan√ßar com o mouse)<br>
            ‚Ä¢ <span style="font-family:var(--mono)">Ctrl+Z</span> undo ‚Ä¢ <span style="font-family:var(--mono)">Delete</span> apagar sele√ß√£o<br>
            ‚Ä¢ <span style="font-family:var(--mono)">Ctrl+B</span> add bookmark
          </div>
          <div class="hint" style="margin-top:12px">
            <b>Bookmarks</b> (clique para ir, bot√£o direito para deletar)
            <div id="bmList" style="margin-top:10px; display:flex; flex-direction:column; gap:8px; max-height: 28vh; overflow:auto;"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- CENTER -->
    <section class="col">
      <div class="workspace">
        <!-- Waveform -->
        <div class="wavePanel" id="wavePanel">
          <div class="waveInner">
            <div class="ampStrip" id="ampWrap">
              <div class="snapBadge" id="snapBadge">4</div>
              <canvas id="ampCanvas"></canvas>
            </div>
            <div class="waveMain" id="waveWrap">
              <div class="zoomBtns">
                <div class="zoomBtn" id="zoomIn">+</div>
                <div class="zoomBtn" id="zoomOut">‚àí</div>
              </div>
              <canvas id="waveCanvas"></canvas>
            </div>
          </div>
        </div>

        <!-- Editor + optional realtime preview -->
        <div class="editorPanel" id="editorPanel">
          <div class="editorSplit" id="editorSplit">
            <div class="editWrap" id="editWrap">
              <div class="hudTop">
                <span class="badge">Time: <b id="hudTime">0</b> ms</span>
                <span class="badge">Keys: <b id="hudKeys">4</b></span>
                <span class="badge">Snap: <b id="hudSnap">1/4</b></span>
                <span class="badge">Tool: <b id="hudTool">Select</b></span>
              </div>
              <canvas id="editCanvas"></canvas>
            </div>

            <div class="previewWrap" id="previewWrap" style="display:none">
              <div class="previewLabel">Realtime preview</div>
              <canvas id="previewCanvas"></canvas>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="col rightCol">
      <div class="panel">
        <div class="hd">
          LAYERS
          <div style="display:flex; gap:10px; align-items:center">
            <div class="iconCircle" title="Visibility">üëÅ</div>
            <div class="iconCircle green" id="layerAdd" title="Add layer">+</div>
            <div class="iconCircle red" id="layerDel" title="Remove layer">‚àí</div>
          </div>
        </div>
        <div class="bd">
          <div class="layerRow">
            <div class="left">
              <div class="check">‚úì</div>
              <div>Default Layer</div>
            </div>
            <div class="layerActions">
              <div class="iconCircle" title="Rename">‚úé</div>
            </div>
          </div>
          <div class="hint" style="margin-top:12px">
            (Layers aqui √© ‚Äúvisual‚Äù por enquanto ‚Äî mas j√° deixei o esqueleto certinho pro layout.)
          </div>
        </div>
      </div>

      <div class="panel" style="flex:1; min-height:0">
        <div class="hd">HITSOUNDS</div>
        <div class="bd" style="min-height:0; display:flex; flex-direction:column; gap:10px">
          <button class="hsBtn" id="hsWhistle">
            <span class="ico">
              <svg viewBox="0 0 24 24"><path d="M3 12h10l4-4v8l-4-4H3z"/></svg>
            </span>
            Whistle
          </button>
          <button class="hsBtn" id="hsFinish">
            <span class="ico">
              <svg viewBox="0 0 24 24"><path d="M12 2l3 7h7l-5.5 4 2 7-6.5-4.5L5.5 20l2-7L2 9h7z"/></svg>
            </span>
            Finish
          </button>
          <button class="hsBtn" id="hsClap">
            <span class="ico">
              <svg viewBox="0 0 24 24"><path d="M7 11l1-5 3 1 1 6-5-2zM12 8l3-1 2 6-5 0zM6 14l7 3 5-2-2 5-8 2-3-3z"/></svg>
            </span>
            Clap
          </button>

          <div class="hsVolRow">
            <div>Volume</div>
            <div style="font-family:var(--mono)" id="hsVolVal">0</div>
          </div>
          <input id="hsVol" type="range" min="0" max="100" step="5" value="0"/>

          <div class="hint" style="margin-top:8px">
            Seleciona 1 nota (Select) e aplica hitsound/volume nela.
          </div>

          <div class="hint">
            <b>Export</b> escreve hitsounds no formato osu!mania (hs flags + sample volume).
          </div>
        </div>
      </div>
    </section>
  </div>

  <!-- Bottom bar -->
  <div class="bottom">
    <div class="left">
      <div class="bBtn" id="exitBtn">‚üµ EXIT</div>
      <div class="bBtn" id="optionsBtn">‚öô OPTIONS</div>
      <div class="bBtn primary" id="addBmBtn"><span class="plus">+</span> ADD BOOKMARK</div>
    </div>

    <div class="mid">
      <div class="transport" title="Transport">
        <div class="tBtn" id="prevBtn" title="Seek -1 beat">
          <svg viewBox="0 0 24 24"><path d="M11 18V6h2v12h-2zM21 18L12 12l9-6v12z"/></svg>
        </div>
        <div class="tBtn" id="playBtn" title="Play/Pause (Space)">
          <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
        </div>
        <div class="tBtn" id="stopBtn" title="Stop">
          <svg viewBox="0 0 24 24"><path d="M7 7h10v10H7z"/></svg>
        </div>
        <div class="tBtn" id="nextBtn" title="Seek +1 beat">
          <svg viewBox="0 0 24 24"><path d="M11 18V6h2v12h-2zM3 18V6l9 6-9 6z"/></svg>
        </div>
      </div>

      <div class="chip">
        <span class="link">Playback Speed</span>
        <span class="sep">‚Ä¢</span>
        <b id="chipRate">100%</b>
      </div>

      <div class="chip">
        <span class="link">Beat Snap</span>
        <span class="sep">‚Ä¢</span>
        <b id="chipSnap">1/4</b>
      </div>
    </div>

    <div class="right">
      <div class="bBtn" id="testPlayBtn">‚ñ∂ TEST PLAY</div>
      <div class="chip" style="gap:10px">
        <span style="opacity:.85">Time</span>
        <b id="timeStr">00:00:000</b>
      </div>
    </div>
  </div>

  <!-- OPTIONS MODAL -->
  <div class="modalBackdrop" id="modalBackdrop">
    <div class="modal">
      <div class="modalHd">
        <b>OPTIONS</b>
        <div style="display:flex; gap:10px; align-items:center">
          <button class="bBtn" id="exportBtn">Export .osu</button>
          <button class="bBtn" id="closeModal">Fechar</button>
        </div>
      </div>

      <div class="modalBd">
        <div class="grid2">
          <div class="field">
            <div>√Åudio</div>
            <input id="audioFile" type="file" accept="audio/*"/>
            <div class="hint">
              O navegador n√£o pode ‚Äúabrir pelo nome do .osu‚Äù. Ent√£o: importe o .osu (se quiser), e carregue o √°udio manualmente aqui.
            </div>
          </div>

          <div class="field">
            <div>Background (opcional)</div>
            <input id="bgFile" type="file" accept="image/*"/>
            <div class="grid2" style="margin-top:10px">
              <div class="field">
                <div>BG Opacity (0..1)</div>
                <input id="bgOpacity" type="number" min="0" max="1" step="0.05" value="0.35"/>
              </div>
              <div class="field">
                <div>BG Blur (px)</div>
                <input id="bgBlur" type="number" min="0" max="20" step="1" value="0"/>
              </div>
            </div>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="grid3">
          <div class="field">
            <div>Title</div>
            <input id="mTitle" type="text" value="WebManiaEditor"/>
          </div>
          <div class="field">
            <div>Artist</div>
            <input id="mArtist" type="text" value="Unknown"/>
          </div>
          <div class="field">
            <div>Creator</div>
            <input id="mCreator" type="text" value="reze"/>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="grid3">
          <div class="field">
            <div>Version</div>
            <input id="mVersion" type="text" value="Easy"/>
          </div>

          <div class="field">
            <div>Keys</div>
            <select id="keysSel">
              <option>4</option><option>5</option><option>6</option><option>7</option>
            </select>
          </div>

          <div class="field">
            <div>Beat Snap</div>
            <select id="snapSel">
              <option value="1">1/1</option>
              <option value="2">1/2</option>
              <option value="3">1/3</option>
              <option value="4" selected>1/4</option>
              <option value="6">1/6</option>
              <option value="8">1/8</option>
              <option value="12">1/12</option>
              <option value="16">1/16</option>
            </select>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="grid3">
          <div class="field">
            <div>BPM</div>
            <input id="bpmIn" type="number" min="30" max="400" step="0.001" value="180"/>
          </div>
          <div class="field">
            <div>Offset (ms)</div>
            <input id="offIn" type="number" min="0" step="1" value="0"/>
          </div>
          <div class="field">
            <div>Playback Speed</div>
            <select id="rateSel">
              <option value="0.25">25%</option>
              <option value="0.50">50%</option>
              <option value="0.75">75%</option>
              <option value="1.00" selected>100%</option>
            </select>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="grid2">
          <div class="row">
            <div>
              <b>Realtime Preview</b><br>
              <span style="opacity:.75">Mostra o ‚Äúin-game‚Äù ao lado (c√≠rculos + LNs) e s√≥ o combo.</span>
            </div>
            <input id="previewToggle" type="checkbox"/>
          </div>

          <div class="row">
            <div>
              <b>Quantize/Snap</b><br>
              <span style="opacity:.75">Quando ligado, notas colocadas/movidas s√£o quantizadas no grid.</span>
            </div>
            <input id="snapOnToggle" type="checkbox" checked/>
          </div>
        </div>

        <div style="height:14px"></div>

        <div class="grid2">
          <div class="field">
            <div>Import .osu (mania)</div>
            <input id="osuIn" type="file" accept=".osu"/>
            <div class="hint">
              Importa notas/timing/metadados. Se o √°udio n√£o existir aqui no navegador, voc√™ carrega manualmente em ‚Äú√Åudio‚Äù.
            </div>
          </div>

          <div class="field">
            <div>A√ß√µes</div>
            <div style="display:flex; gap:10px; flex-wrap:wrap">
              <button class="bBtn danger" id="clearBtn">Clear notes</button>
              <button class="bBtn" id="undoBtn">Undo</button>
            </div>
            <div class="hint" style="margin-top:10px">
              Dica: timeline/waveform e editor aceitam drag pra seek. Use <span style="font-family:var(--mono)">Alt</span>+drag no editor pra scrub.
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const uid = ()=> Math.random().toString(36).slice(2,10);

  /* UI */
  const topStatus = $("topStatus");

  const dCount = $("dCount");
  const dSpeed = $("dSpeed");
  const dBpm = $("dBpm");
  const dSnap = $("dSnap");
  const dDiff = $("dDiff");

  const toolBtns = Array.from(document.querySelectorAll(".toolBtn"));

  const wavePanel = $("wavePanel");
  const ampWrap = $("ampWrap");
  const waveWrap = $("waveWrap");
  const ampCanvas = $("ampCanvas");
  const waveCanvas = $("waveCanvas");

  const editorPanel = $("editorPanel");
  const editorSplit = $("editorSplit");
  const editWrap = $("editWrap");
  const editCanvas = $("editCanvas");

  const previewWrap = $("previewWrap");
  const previewCanvas = $("previewCanvas");

  const zoomIn = $("zoomIn");
  const zoomOut = $("zoomOut");

  const hudTime = $("hudTime");
  const hudKeys = $("hudKeys");
  const hudSnap = $("hudSnap");
  const hudTool = $("hudTool");

  const bmList = $("bmList");
  const addBmBtn = $("addBmBtn");

  const hsWhistle = $("hsWhistle");
  const hsFinish = $("hsFinish");
  const hsClap = $("hsClap");
  const hsVol = $("hsVol");
  const hsVolVal = $("hsVolVal");

  const exitBtn = $("exitBtn");
  const optionsBtn = $("optionsBtn");

  const prevBtn = $("prevBtn");
  const playBtn = $("playBtn");
  const stopBtn = $("stopBtn");
  const nextBtn = $("nextBtn");
  const playIcon = $("playIcon");

  const chipRate = $("chipRate");
  const chipSnap = $("chipSnap");
  const timeStr = $("timeStr");
  const testPlayBtn = $("testPlayBtn");

  /* Modal */
  const modalBackdrop = $("modalBackdrop");
  const closeModal = $("closeModal");
  const exportBtn = $("exportBtn");
  const audioFile = $("audioFile");
  const bgFile = $("bgFile");
  const bgOpacity = $("bgOpacity");
  const bgBlur = $("bgBlur");
  const bgImg = $("bgImg");

  const mTitle = $("mTitle");
  const mArtist = $("mArtist");
  const mCreator = $("mCreator");
  const mVersion = $("mVersion");

  const keysSel = $("keysSel");
  const snapSel = $("snapSel");
  const bpmIn = $("bpmIn");
  const offIn = $("offIn");
  const rateSel = $("rateSel");

  const previewToggle = $("previewToggle");
  const snapOnToggle = $("snapOnToggle");

  const osuIn = $("osuIn");
  const clearBtn = $("clearBtn");
  const undoBtn = $("undoBtn");

  const snapBadge = $("snapBadge");

  /* Canvas contexts */
  const actx = ampCanvas.getContext("2d");
  const wctx = waveCanvas.getContext("2d");
  const ectx = editCanvas.getContext("2d");
  const prctx = previewCanvas.getContext("2d");

  function fitCanvas(canvas){
    const r = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  const ro = new ResizeObserver(() => {
    fitCanvas(ampCanvas);
    fitCanvas(waveCanvas);
    fitCanvas(editCanvas);
    if(state.preview.enabled) fitCanvas(previewCanvas);
  });
  ro.observe(wavePanel);
  ro.observe(editorPanel);

  /* State */
  const state = {
    tool: "select",

    keys: 4,
    snap: 4,
    snapOn: true,

    // view scaling (px per ms)
    view: {
      pxPerMs: 0.40, // default zoom
      min: 0.12,
      max: 1.40,
      zoomStep: 1.18,
    },

    timing: [{ id: uid(), t: 0, bpm: 180, meter: 4 }],

    notes: [],
    bookmarks: [],
    selected: new Set(),
    undo: [],

    // audio
    ac: null,
    buffer: null,
    gain: null,
    source: null,
    startedAt: 0,
    startOffsetSec: 0,
    timeMs: 0,
    isPlaying: false,
    rate: 1,
    playRateAtStart: 1, // critical fix

    // waveform
    wf: { ready:false, peaks:null, blockSec:0, max:1, progress:0 },

    // background
    bg: { opacity: 0.35, blur: 0 },

    // editor drag
    drag: { down:false, mode:"none", x0:0, y0:0, holdId:null, moveSnap:null },

    // scrub (Alt+drag)
    scrub: { on:false, wasPlaying:false },

    // preview
    preview: {
      enabled: false,
      speedFactor: 0.85,   // how fast notes fall in preview vs editor scroll
      lookAheadMs: 2300,
      hitLinePad: 92,
    },
    previewRuntime: {
      dirty: true,
      sorted: [],
      idx: 0,
      combo: 0,
      lastMs: 0,
    }
  };

  /* ===== Timing / Snap ===== */
  function normalizeTiming(){
    state.timing.sort((a,b)=>a.t-b.t);
    const out=[];
    for(const tp of state.timing){
      if(out.length && out[out.length-1].t === tp.t) out[out.length-1]=tp;
      else out.push(tp);
    }
    state.timing = out;
  }
  function activeTP(ms){
    normalizeTiming();
    let best = state.timing[0];
    for(const tp of state.timing){
      if(tp.t <= ms) best = tp;
      else break;
    }
    return best;
  }
  function snapStepMsAt(ms){
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    return beatLen / state.snap;
  }
  function quantizeAt(ms){
    if(!state.snapOn) return ms;
    const tp = activeTP(ms);
    const beatLen = 60000 / tp.bpm;
    const step = beatLen / state.snap;
    const base = tp.t;
    const n = Math.round((ms - base) / step);
    return base + n*step;
  }

  /* ===== Audio (FIXED) ===== */
  async function ensureAC(){
    if(state.ac) return state.ac;
    state.ac = new (window.AudioContext || window.webkitAudioContext)();
    state.gain = state.ac.createGain();
    state.gain.gain.value = 1;
    state.gain.connect(state.ac.destination);
    return state.ac;
  }

  function cleanupSource(){
    const src = state.source;
    if(!src) return;
    try{ src.onended = null; }catch(e){}
    try{ src.stop(0); }catch(e){}
    try{ src.disconnect(); }catch(e){}
    state.source = null;
  }

  async function play(){
    if(!state.buffer) return;
    const ac = await ensureAC();
    if(ac.state === "suspended") await ac.resume();

    if(state.isPlaying) pause();

    state.startOffsetSec = clamp(state.startOffsetSec, 0, state.buffer.duration || 0);
    if(state.startOffsetSec >= (state.buffer.duration || 0)) state.startOffsetSec = 0;

    cleanupSource();

    const src = ac.createBufferSource();
    src.buffer = state.buffer;
    src.playbackRate.value = state.rate;
    src.connect(state.gain);

    state.playRateAtStart = state.rate; // FIX
    state.startedAt = ac.currentTime;
    state.isPlaying = true;

    src.onended = () => {
      if(state.source === src){
        state.isPlaying = false;
        state.source = null;
      }
    };

    state.source = src;
    src.start(0, state.startOffsetSec);

    updatePlayIcon();
  }

  function pause(){
    if(!state.ac || !state.isPlaying) return;

    const ac = state.ac;
    const elapsedReal = ac.currentTime - state.startedAt;
    const playedSec = elapsedReal * state.playRateAtStart; // FIX

    state.startOffsetSec = clamp(state.startOffsetSec + playedSec, 0, state.buffer?.duration || 0);
    state.timeMs = Math.round(state.startOffsetSec * 1000);

    state.isPlaying = false;
    cleanupSource();

    updatePlayIcon();
  }

  function stop(){
    pause();
    state.startOffsetSec = 0;
    state.timeMs = 0;
    resetPreviewRuntime();
    updatePlayIcon();
  }

  function updateTimeFromAudio(){
    if(!state.isPlaying || !state.ac) return;
    const ac = state.ac;

    const elapsedReal = ac.currentTime - state.startedAt;
    const playedSec = elapsedReal * state.playRateAtStart; // FIX
    const tSec = state.startOffsetSec + playedSec;

    const dur = (state.buffer?.duration || 0);
    const clamped = clamp(tSec, 0, dur);

    state.timeMs = Math.round(clamped * 1000);

    if(dur > 0 && clamped >= dur - 0.0005){
      state.isPlaying = false;
      cleanupSource();
      updatePlayIcon();
    }
  }

  function seekMs(ms){
    if(!state.buffer) return;
    ms = Math.round(ms);
    const max = state.buffer.duration * 1000;
    state.timeMs = clamp(ms, 0, max);
    state.startOffsetSec = state.timeMs / 1000;

    resetPreviewRuntime();

    if(state.isPlaying){
      pause();
      play();
    }
  }

  async function loadAudio(file){
    const ac = await ensureAC();
    const arr = await file.arrayBuffer();
    state.buffer = await ac.decodeAudioData(arr);

    state.timeMs = 0;
    state.startOffsetSec = 0;
    state.isPlaying = false;
    cleanupSource();

    state.wf.ready = false;
    state.wf.peaks = null;
    state.wf.progress = 0;

    resetPreviewRuntime();
    buildPeaks();

    topStatus.textContent = `${file.name} ‚Ä¢ ${Math.round(state.buffer.duration)}s`;
  }

  function updatePlayIcon(){
    if(state.isPlaying){
      playIcon.innerHTML = `<path d="M7 6h4v12H7zM13 6h4v12h-4z"/>`;
    } else {
      playIcon.innerHTML = `<path d="M8 5v14l11-7z"/>`;
    }
  }

  /* ===== Waveform peaks (vertical time) ===== */
  function buildPeaks(){
    const buf = state.buffer;
    if(!buf) return;

    const wf = state.wf;
    const dur = buf.duration;
    const sr = buf.sampleRate;

    // choose block size
    const block = dur > 240 ? 4096 : (dur > 120 ? 2048 : 1024);
    const len = buf.length;
    const blocks = Math.ceil(len / block);

    wf.peaks = new Float32Array(blocks);
    wf.blockSec = block / sr;

    const chN = buf.numberOfChannels;
    const ch = [];
    for(let c=0;c<chN;c++) ch.push(buf.getChannelData(c));

    let i = 0;
    let max = 0;

    function step(){
      const t0 = performance.now();
      const budget = 12;

      while(i < blocks && performance.now() - t0 < budget){
        const start = i * block;
        const end = Math.min(len, start + block);

        let peak = 0;
        for(let s=start; s<end; s++){
          let v = 0;
          for(let c=0;c<chN;c++) v += ch[c][s];
          v /= chN;
          const a = Math.abs(v);
          if(a > peak) peak = a;
        }
        wf.peaks[i] = peak;
        if(peak > max) max = peak;
        i++;
      }

      wf.progress = i / blocks;

      if(i < blocks){
        requestAnimationFrame(step);
      } else {
        wf.max = max || 1;
        wf.ready = true;
      }
    }
    requestAnimationFrame(step);
  }

  function ampAtMs(ms){
    const wf = state.wf;
    if(!wf.ready || !wf.peaks) return 0;
    const sec = ms / 1000;
    const idx = Math.floor(sec / wf.blockSec);
    if(idx < 0 || idx >= wf.peaks.length) return 0;
    return wf.peaks[idx] / wf.max;
  }

  /* ===== Editor geometry ===== */
  const EW = ()=> editCanvas.width / (window.devicePixelRatio||1);
  const EH = ()=> editCanvas.height / (window.devicePixelRatio||1);
  const WW = ()=> waveCanvas.width / (window.devicePixelRatio||1);
  const WH = ()=> waveCanvas.height / (window.devicePixelRatio||1);
  const AW = ()=> ampCanvas.width / (window.devicePixelRatio||1);
  const AH = ()=> ampCanvas.height / (window.devicePixelRatio||1);
  const PW = ()=> previewCanvas.width / (window.devicePixelRatio||1);
  const PH = ()=> previewCanvas.height / (window.devicePixelRatio||1);

  function centerYEditor(){ return Math.floor(EH() * 0.50); }
  function centerYWave(){ return Math.floor(WH() * 0.50); }

  function laneW(){ return EW() / state.keys; }
  function laneFromX(x){ return clamp(Math.floor(x / laneW()), 0, state.keys-1); }
  function xFromLane(l){ return l * laneW(); }

  function yFromTimeEditor(ms){
    return centerYEditor() - (ms - state.timeMs) * state.view.pxPerMs;
  }
  function timeFromYEditor(y){
    return state.timeMs + (centerYEditor() - y) / state.view.pxPerMs;
  }

  function yFromTimeWave(ms){
    return centerYWave() - (ms - state.timeMs) * state.view.pxPerMs;
  }
  function timeFromYWave(y){
    return state.timeMs + (centerYWave() - y) / state.view.pxPerMs;
  }

  /* ===== Notes + selection ===== */
  function sortNotes(){ state.notes.sort((a,b)=>a.t-b.t || a.lane-b.lane); }
  function markPreviewDirty(){ state.previewRuntime.dirty = true; }

  function pushUndo(){
    state.undo.push(JSON.stringify({
      keys: state.keys,
      snap: state.snap,
      snapOn: state.snapOn,
      view: state.view,
      timing: state.timing,
      notes: state.notes,
      bookmarks: state.bookmarks,
      meta: getMeta(),
      rate: state.rate,
      bg: state.bg,
      preview: state.preview,
    }));
    if(state.undo.length > 250) state.undo.shift();
    undoBtn.textContent = `Undo (${state.undo.length})`;
  }

  function doUndo(){
    const raw = state.undo.pop();
    if(!raw) return;
    const s = JSON.parse(raw);

    state.keys = s.keys ?? state.keys;
    state.snap = s.snap ?? state.snap;
    state.snapOn = s.snapOn ?? state.snapOn;
    state.view = s.view ?? state.view;
    state.timing = s.timing ?? state.timing;
    state.notes = s.notes ?? state.notes;
    state.bookmarks = s.bookmarks ?? state.bookmarks;
    if(s.meta) setMeta(s.meta);
    state.rate = s.rate ?? state.rate;
    state.bg = s.bg ?? state.bg;
    state.preview = s.preview ?? state.preview;

    // sync UI
    keysSel.value = String(state.keys);
    snapSel.value = String(state.snap);
    snapOnToggle.checked = !!state.snapOn;

    const tp0 = state.timing[0] || {bpm:180,t:0};
    bpmIn.value = String(tp0.bpm);
    offIn.value = String(tp0.t);

    rateSel.value = String(state.rate);
    chipRate.textContent = `${Math.round(state.rate*100)}%`;

    bgOpacity.value = String(state.bg.opacity);
    bgBlur.value = String(state.bg.blur);
    bgImg.style.opacity = String(state.bg.opacity);
    bgImg.style.filter = `blur(${state.bg.blur}px)`;

    previewToggle.checked = !!state.preview.enabled;
    applyPreviewLayout();

    // clamp lanes
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);

    state.selected.clear();
    markPreviewDirty();
    resetPreviewRuntime();
    renderBookmarks();
  }

  function clearNotes(){
    pushUndo();
    state.notes = [];
    state.selected.clear();
    markPreviewDirty();
    resetPreviewRuntime();
  }

  function addNote(note){
    pushUndo();
    state.notes.push(note);
    sortNotes();
    state.selected.clear();
    state.selected.add(note.id);
    markPreviewDirty();
    resetPreviewRuntime();
  }

  function deleteSelection(){
    if(state.selected.size === 0) return;
    pushUndo();
    state.notes = state.notes.filter(n => !state.selected.has(n.id));
    state.selected.clear();
    markPreviewDirty();
    resetPreviewRuntime();
  }

  function getSelectedOne(){
    if(state.selected.size !== 1) return null;
    const id = [...state.selected][0];
    return state.notes.find(n => n.id === id) || null;
  }

  function toggleHs(bit){
    const n = getSelectedOne();
    if(!n) return;
    pushUndo();
    n.hs = (n.hs ?? 0) ^ bit;
    syncHitsoundUI();
  }

  function setHsVol(v){
    const n = getSelectedOne();
    if(!n) return;
    pushUndo();
    n.vol = clamp(v, 0, 100);
    syncHitsoundUI();
  }

  function syncHitsoundUI(){
    const n = getSelectedOne();
    const hs = n?.hs ?? 0;
    hsWhistle.classList.toggle("active", (hs & 2) !== 0);
    hsFinish.classList.toggle("active", (hs & 4) !== 0);
    hsClap.classList.toggle("active", (hs & 8) !== 0);
    const vol = n?.vol ?? 0;
    hsVol.value = String(vol);
    hsVolVal.textContent = String(vol);
  }

  function findNoteAt(x,y){
    const l = laneFromX(x);
    const lw = laneW();
    const x0 = xFromLane(l);

    for(let i=state.notes.length-1; i>=0; i--){
      const n = state.notes[i];
      if(n.lane !== l) continue;

      const yHead = yFromTimeEditor(n.t);
      const pad = 8;
      const rw = lw - pad*2;
      const rh = 12;

      // head rect
      const rx = x0 + pad;
      const ry = yHead - rh/2;

      if(x>=rx && x<=rx+rw && y>=ry && y<=ry+rh) return n;

      if(n.type === "hold"){
        const yTail = yFromTimeEditor(n.end);
        const top = Math.min(yHead, yTail);
        const bot = Math.max(yHead, yTail);
        const cx = x0 + lw/2;
        if(x>=cx-10 && x<=cx+10 && y>=top-8 && y<=bot+8) return n;
      }
    }
    return null;
  }

  function beginMoveSelection(){
    const snap = new Map();
    for(const n of state.notes){
      if(state.selected.has(n.id)){
        snap.set(n.id, { t:n.t, end:n.end, lane:n.lane });
      }
    }
    state.drag.moveSnap = snap;
  }

  function applyMoveSelection(deltaLane, deltaMs){
    const snap = state.drag.moveSnap;
    if(!snap) return;

    for(const n of state.notes){
      if(!state.selected.has(n.id)) continue;
      const base = snap.get(n.id);
      if(!base) continue;

      let lane = clamp(base.lane + deltaLane, 0, state.keys-1);
      let t = base.t + deltaMs;
      t = state.snapOn ? quantizeAt(t) : t;

      n.lane = lane;
      n.t = t;

      if(n.type === "hold"){
        let end = base.end + deltaMs;
        end = state.snapOn ? quantizeAt(end) : end;
        n.end = Math.max(n.t + 1, end);
      } else {
        n.end = n.t;
      }
    }
    sortNotes();
    markPreviewDirty();
    resetPreviewRuntime();
  }

  /* ===== Bookmarks ===== */
  function addBookmark(){
    pushUndo();
    state.bookmarks.push({ id: uid(), t: Math.round(state.timeMs), label: `BM @ ${fmtTime(state.timeMs)}` });
    state.bookmarks.sort((a,b)=>a.t-b.t);
    renderBookmarks();
  }

  function renderBookmarks(){
    bmList.innerHTML = "";
    if(state.bookmarks.length === 0){
      const div = document.createElement("div");
      div.style.opacity = ".72";
      div.style.fontFamily = "var(--mono)";
      div.textContent = "‚Äî";
      bmList.appendChild(div);
      return;
    }
    for(const bm of state.bookmarks){
      const row = document.createElement("div");
      row.className = "row";
      row.style.cursor = "pointer";
      row.innerHTML = `
        <div style="display:flex; flex-direction:column; gap:2px">
          <b style="font-family:var(--mono)">${fmtTime(bm.t)}</b>
          <span style="opacity:.72; font-size:12px">${bm.label}</span>
        </div>
        <div style="opacity:.7; font-family:var(--mono)">${bm.t}ms</div>
      `;
      row.addEventListener("click", () => seekMs(bm.t));
      row.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        pushUndo();
        state.bookmarks = state.bookmarks.filter(x => x.id !== bm.id);
        renderBookmarks();
      });
      bmList.appendChild(row);
    }
  }

  /* ===== Preview runtime ===== */
  function rebuildPreviewSorted(){
    state.previewRuntime.sorted = state.notes
      .slice()
      .map(n => ({ id:n.id, t:n.t, lane:n.lane, type:n.type, end:n.end }))
      .sort((a,b)=>a.t-b.t || a.lane-b.lane);
    state.previewRuntime.dirty = false;
  }

  function resetPreviewRuntime(){
    state.previewRuntime.idx = 0;
    state.previewRuntime.combo = 0;
    state.previewRuntime.lastMs = state.timeMs;
    state.previewRuntime.dirty = true;
  }

  function syncPreviewRuntimeToTime(){
    if(state.previewRuntime.dirty) rebuildPreviewSorted();
    // recompute combo deterministically up to current time
    let combo = 0;
    let idx = 0;
    const arr = state.previewRuntime.sorted;
    while(idx < arr.length && arr[idx].t <= state.timeMs){
      combo++;
      idx++;
    }
    state.previewRuntime.combo = combo;
    state.previewRuntime.idx = idx;
    state.previewRuntime.lastMs = state.timeMs;
  }

  /* ===== Drawing ===== */
  function crispY(y){ return Math.round(y) + 0.5; }

  function drawAmpStrip(){
    const w = AW(), h = AH();
    actx.clearRect(0,0,w,h);
    actx.fillStyle = "rgba(0,0,0,.15)";
    actx.fillRect(0,0,w,h);

    // colored bars from waveform amplitude
    const stepY = 3;
    for(let y=0; y<h; y+=stepY){
      const ms = timeFromYWave(y);
      const a = ampAtMs(ms);
      // map amplitude to a heat color
      const t = clamp(a,0,1);
      const r = Math.round(60 + 180*t);
      const g = Math.round(120 + 80*(1-t));
      const b = Math.round(220 - 120*t);
      actx.fillStyle = `rgba(${r},${g},${b},0.85)`;
      const barW = 8 + t*(w-12);
      actx.fillRect(w - barW, y, barW, stepY-1);
    }

    // playhead
    const yph = crispY(yFromTimeWave(state.timeMs));
    actx.strokeStyle = "rgba(255,255,255,.55)";
    actx.lineWidth = 1;
    actx.beginPath();
    actx.moveTo(0, yph);
    actx.lineTo(w, yph);
    actx.stroke();
  }

  function drawWaveform(){
    const w = WW(), h = WH();
    wctx.clearRect(0,0,w,h);

    // background
    wctx.fillStyle = "rgba(0,0,0,.22)";
    wctx.fillRect(0,0,w,h);

    // grid lines (snap + measures) with timing segments
    normalizeTiming();
    const startMs = timeFromYWave(h);
    const endMs = timeFromYWave(0);
    const tps = state.timing.slice();

    for(let i=0;i<tps.length;i++){
      const tp = tps[i];
      const next = tps[i+1];
      const segStart = Math.max(startMs, tp.t);
      const segEnd = Math.min(endMs, next ? next.t : Infinity);
      if(segEnd <= segStart) continue;

      const beatLen = 60000 / tp.bpm;
      const meter = tp.meter || 4;
      const step = beatLen / state.snap;
      const base = tp.t;

      const n0 = Math.ceil((segStart - base) / step);
      for(let t = base + n0*step; t <= segEnd; t += step){
        const y = crispY(yFromTimeWave(t));
        const rel = t - base;
        const beatIndex = Math.round(rel / beatLen);
        const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
        const isBar = isBeat && (beatIndex % meter === 0);

        const a = isBar ? 0.22 : isBeat ? 0.14 : 0.08;
        wctx.strokeStyle = `rgba(255,255,255,${a})`;
        wctx.lineWidth = isBar ? 1.6 : isBeat ? 1.1 : 1;

        wctx.beginPath();
        wctx.moveTo(0,y);
        wctx.lineTo(w,y);
        wctx.stroke();
      }
    }

    // waveform
    if(state.wf.ready){
      wctx.globalAlpha = 0.92;
      wctx.strokeStyle = "rgba(38,211,255,.75)";
      wctx.lineWidth = 1;
      const mid = w*0.55;
      const stepY = 2;
      for(let y=0; y<h; y+=stepY){
        const ms = timeFromYWave(y);
        const a = ampAtMs(ms);
        const amp = a*(w*0.42);
        wctx.beginPath();
        wctx.moveTo(mid-amp, y);
        wctx.lineTo(mid+amp, y);
        wctx.stroke();
      }
      wctx.globalAlpha = 1;
    } else if(state.buffer){
      wctx.fillStyle = "rgba(255,255,255,.10)";
      wctx.fillText("gerando waveform‚Ä¶", 12, 18);
    }

    // notes as blocks in waveform (like screenshot)
    const laneWv = w / Math.max(1,state.keys);
    for(const n of state.notes){
      const y = yFromTimeWave(n.t);
      if(y < -80 || y > h+80) continue;
      const x = (n.lane + 0.15) * laneWv;
      const bw = laneWv * 0.72;
      const bh = 12;

      wctx.fillStyle = "rgba(38,211,255,.85)";
      wctx.fillRect(x, y - bh/2, bw, bh);

      if(n.type === "hold"){
        const y2 = yFromTimeWave(n.end);
        const top = Math.min(y, y2);
        const bot = Math.max(y, y2);
        wctx.fillStyle = "rgba(38,211,255,.35)";
        wctx.fillRect(x + bw*0.42, top, bw*0.16, bot-top);
      }
    }

    // bookmarks ticks
    for(const bm of state.bookmarks){
      const y = crispY(yFromTimeWave(bm.t));
      if(y < -20 || y > h+20) continue;
      wctx.strokeStyle = "rgba(255,255,255,.85)";
      wctx.lineWidth = 2;
      wctx.beginPath();
      wctx.moveTo(0, y);
      wctx.lineTo(w, y);
      wctx.stroke();
    }

    // playhead
    const yph = crispY(yFromTimeWave(state.timeMs));
    wctx.strokeStyle = "rgba(239,68,68,.85)"; // red-ish like osu
    wctx.lineWidth = 2;
    wctx.beginPath();
    wctx.moveTo(0, yph);
    wctx.lineTo(w, yph);
    wctx.stroke();
  }

  function drawEditor(){
    const w = EW(), h = EH();
    ectx.clearRect(0,0,w,h);

    // bg
    ectx.fillStyle = "rgba(0,0,0,.18)";
    ectx.fillRect(0,0,w,h);

    // lanes shading
    const lw = laneW();
    for(let i=0;i<state.keys;i++){
      ectx.fillStyle = "rgba(255,255,255,.03)";
      ectx.fillRect(i*lw, 0, lw-1, h);
      ectx.fillStyle = "rgba(255,255,255,.08)";
      ectx.fillRect(i*lw, 0, 1, h);
    }
    ectx.fillStyle = "rgba(255,255,255,.12)";
    ectx.fillRect(w-1,0,1,h);

    // grid lines
    normalizeTiming();
    const startMs = timeFromYEditor(h);
    const endMs = timeFromYEditor(0);
    const tps = state.timing.slice();

    for(let i=0;i<tps.length;i++){
      const tp = tps[i];
      const next = tps[i+1];
      const segStart = Math.max(startMs, tp.t);
      const segEnd = Math.min(endMs, next ? next.t : Infinity);
      if(segEnd <= segStart) continue;

      const beatLen = 60000 / tp.bpm;
      const meter = tp.meter || 4;
      const step = beatLen / state.snap;
      const base = tp.t;

      const n0 = Math.ceil((segStart - base) / step);
      for(let t = base + n0*step; t <= segEnd; t += step){
        const y = crispY(yFromTimeEditor(t));
        const rel = t - base;
        const beatIndex = Math.round(rel / beatLen);
        const isBeat = Math.abs(rel - beatIndex*beatLen) < 0.001;
        const isBar = isBeat && (beatIndex % meter === 0);

        const a = isBar ? 0.22 : isBeat ? 0.14 : 0.08;
        ectx.strokeStyle = `rgba(255,255,255,${a})`;
        ectx.lineWidth = isBar ? 1.6 : isBeat ? 1.1 : 1;

        ectx.beginPath();
        ectx.moveTo(0,y);
        ectx.lineTo(w,y);
        ectx.stroke();
      }
    }

    // playhead
    const yph = crispY(centerYEditor());
    ectx.strokeStyle = "rgba(239,68,68,.85)";
    ectx.lineWidth = 2;
    ectx.beginPath();
    ectx.moveTo(0, yph);
    ectx.lineTo(w, yph);
    ectx.stroke();

    // notes (editor rectangles)
    for(const n of state.notes){
      const y = yFromTimeEditor(n.t);
      if(y < -140 || y > h+140) continue;

      const x0 = xFromLane(n.lane);
      const pad = 10;
      const rw = lw - pad*2;
      const rh = 12;

      const sel = state.selected.has(n.id);

      if(n.type === "hold"){
        const y2 = yFromTimeEditor(n.end);
        const top = Math.min(y, y2);
        const bot = Math.max(y, y2);

        ectx.fillStyle = sel ? "rgba(167,139,250,.42)" : "rgba(255,255,255,.14)";
        ectx.fillRect(x0 + lw/2 - 3, top, 6, bot-top);

        ectx.fillStyle = sel ? "rgba(167,139,250,.92)" : "rgba(255,255,255,.70)";
        ectx.fillRect(x0 + pad, y2 - rh/2, rw, rh);
      }

      ectx.fillStyle = sel ? "rgba(38,211,255,.95)" : "rgba(255,255,255,.78)";
      ectx.fillRect(x0 + pad, y - rh/2, rw, rh);

      if(sel){
        ectx.strokeStyle = "rgba(38,211,255,.95)";
        ectx.lineWidth = 1.3;
        ectx.strokeRect(x0 + pad, y - rh/2, rw, rh);
      }
    }
  }

  function drawPreview(){
    if(!state.preview.enabled) return;

    // keep runtime synced (combo)
    syncPreviewRuntimeToTime();

    const w = PW(), h = PH();
    prctx.clearRect(0,0,w,h);

    prctx.fillStyle = "#000";
    prctx.fillRect(0,0,w,h);

    const padX = 34;
    const keys = state.keys;
    const playW = w - padX*2;
    const lw = playW / keys;

    const receptorY = h - state.preview.hitLinePad;

    // circle size osu-like
    const r = Math.min(lw * 0.42, 46);
    const strokeW = 3;

    function circle(cx, cy, rad, fill, stroke){
      prctx.beginPath();
      prctx.arc(cx, cy, rad, 0, Math.PI*2);
      if(fill){
        prctx.fillStyle = fill;
        prctx.fill();
      }
      if(stroke){
        prctx.lineWidth = strokeW;
        prctx.strokeStyle = stroke;
        prctx.stroke();
      }
    }

    // receptors (empty circles)
    for(let lane=0; lane<keys; lane++){
      const cx = padX + (lane+0.5)*lw;
      circle(cx, receptorY, r, null, "rgba(255,255,255,0.92)");
    }

    const pxPerMsPrev = state.view.pxPerMs * state.preview.speedFactor;
    const t0 = state.timeMs - 250;
    const t1 = state.timeMs + state.preview.lookAheadMs;

    // holds body behind
    for(const n of state.notes){
      if(n.type !== "hold") continue;
      if(n.t > t1 || n.end < t0) continue;

      const cx = padX + (n.lane+0.5)*lw;
      const headY = receptorY - (n.t - state.timeMs) * pxPerMsPrev;
      const tailY = receptorY - (n.end - state.timeMs) * pxPerMsPrev;

      prctx.lineCap = "round";
      prctx.lineWidth = Math.max(10, r*0.46);
      prctx.strokeStyle = "rgba(185,205,255,0.30)";
      prctx.beginPath();
      prctx.moveTo(cx, headY);
      prctx.lineTo(cx, tailY);
      prctx.stroke();

      // tail circle (soft)
      circle(cx, tailY, r, "rgba(185,205,255,0.70)", "rgba(255,255,255,0.92)");
    }

    // heads / taps
    for(const n of state.notes){
      if(n.t > t1 || (n.type === "hold" ? n.end < t0 : n.t < t0)) continue;

      const cx = padX + (n.lane+0.5)*lw;
      const y  = receptorY - (n.t - state.timeMs) * pxPerMsPrev;

      circle(cx, y, r, "rgba(185,205,255,0.85)", "rgba(255,255,255,0.92)");
    }

    // combo only (no other HUD)
    prctx.fillStyle = "rgba(255,255,255,0.95)";
    prctx.font = "800 44px " + getComputedStyle(document.body).fontFamily;
    prctx.textAlign = "right";
    prctx.textBaseline = "top";
    prctx.fillText(String(state.previewRuntime.combo), w - 18, 14);

    // subtle vignette
    const grd = prctx.createLinearGradient(0, 0, 0, h);
    grd.addColorStop(0, "rgba(0,0,0,.70)");
    grd.addColorStop(0.18, "rgba(0,0,0,.00)");
    grd.addColorStop(0.86, "rgba(0,0,0,.10)");
    grd.addColorStop(1, "rgba(0,0,0,.75)");
    prctx.fillStyle = grd;
    prctx.fillRect(0,0,w,h);
  }

  /* ===== UI refresh ===== */
  function fmtTime(ms){
    ms = Math.max(0, Math.floor(ms));
    const m = Math.floor(ms / 60000);
    const s = Math.floor((ms % 60000) / 1000);
    const t = ms % 1000;
    return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}:${String(t).padStart(3,"0")}`;
  }

  function getMeta(){
    return {
      title: mTitle.value || "WebManiaEditor",
      artist: mArtist.value || "Unknown",
      creator: mCreator.value || "reze",
      version: mVersion.value || "Easy",
    };
  }
  function setMeta(meta){
    mTitle.value = meta.title ?? mTitle.value;
    mArtist.value = meta.artist ?? mArtist.value;
    mCreator.value = meta.creator ?? mCreator.value;
    mVersion.value = meta.version ?? mVersion.value;
  }

  function refreshHUD(){
    const tp = activeTP(state.timeMs);

    hudTime.textContent = String(Math.round(state.timeMs));
    hudKeys.textContent = String(state.keys);
    hudSnap.textContent = `1/${state.snap}`;
    hudTool.textContent = state.tool[0].toUpperCase() + state.tool.slice(1);

    dCount.textContent = String(state.notes.length);
    dSpeed.textContent = `${Math.round(state.rate*100)}%`;
    dBpm.textContent = tp ? tp.bpm.toFixed(5) : "‚Äî";
    dSnap.textContent = `1/${state.snap}th`;

    // simple "difficulty-ish" estimator
    const dur = state.buffer ? state.buffer.duration : 0;
    let diff = "‚Äî";
    if(dur > 0){
      const nps = state.notes.length / dur;
      const est = (nps * 7.4) + (state.keys - 3) * 0.9; // heuristic
      diff = est.toFixed(2);
    }
    dDiff.textContent = diff;

    chipRate.textContent = `${Math.round(state.rate*100)}%`;
    chipSnap.textContent = `1/${state.snap}`;
    timeStr.textContent = fmtTime(state.timeMs);

    snapBadge.textContent = String(state.snap);
    topStatus.textContent = state.buffer ? `time ${fmtTime(state.timeMs)} ‚Ä¢ ${state.notes.length} objs` : "carregue um √°udio em OPTIONS";
  }

  function setTool(tool){
    state.tool = tool;
    toolBtns.forEach(b => b.classList.toggle("active", b.getAttribute("data-tool") === tool));
    refreshHUD();
  }

  function applyPreviewLayout(){
    if(state.preview.enabled){
      previewWrap.style.display = "";
      editorSplit.classList.add("previewOn");
      fitCanvas(previewCanvas);
    } else {
      previewWrap.style.display = "none";
      editorSplit.classList.remove("previewOn");
    }
  }

  /* ===== Interaction helpers ===== */
  function mousePos(e, wrap){
    const r = wrap.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  /* ===== Editor interactions ===== */
  editWrap.addEventListener("contextmenu", (e)=> e.preventDefault());

  editWrap.addEventListener("wheel", (e)=>{
    e.preventDefault();
    if(!state.buffer) return;
    // scroll time with wheel; scale by zoom
    const delta = e.deltaY;
    const ms = delta * (2.2 / state.view.pxPerMs);
    seekMs(state.timeMs + ms);
  }, {passive:false});

  // Alt+drag scrub
  editWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    if(!e.altKey) return;
    e.preventDefault();

    state.scrub.on = true;
    state.scrub.wasPlaying = state.isPlaying;
    if(state.isPlaying) pause();

    const m = mousePos(e, editWrap);
    const ms = timeFromYEditor(m.y);
    seekMs(state.snapOn ? quantizeAt(ms) : ms);
  });

  window.addEventListener("mousemove", (e)=>{
    if(!state.scrub.on) return;
    const m = mousePos(e, editWrap);
    const ms = timeFromYEditor(m.y);
    seekMs(state.snapOn ? quantizeAt(ms) : ms);
  });

  window.addEventListener("mouseup", ()=>{
    if(!state.scrub.on) return;
    state.scrub.on = false;
    if(state.scrub.wasPlaying) play();
  });

  editWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    if(e.altKey) return; // scrub handles

    const m = mousePos(e, editWrap);
    state.drag.down = true;
    state.drag.x0 = m.x;
    state.drag.y0 = m.y;

    const hit = findNoteAt(m.x, m.y);

    if(state.tool === "select"){
      const additive = e.ctrlKey || e.metaKey;

      if(hit){
        if(additive){
          if(state.selected.has(hit.id)) state.selected.delete(hit.id);
          else state.selected.add(hit.id);
        } else {
          if(!state.selected.has(hit.id)){
            state.selected.clear();
            state.selected.add(hit.id);
          }
        }
        syncHitsoundUI();

        state.drag.mode = "move";
        beginMoveSelection();
      } else {
        if(!additive) state.selected.clear();
        syncHitsoundUI();
        state.drag.mode = "none";
      }
      return;
    }

    if(state.tool === "erase"){
      if(hit){
        pushUndo();
        state.notes = state.notes.filter(n => n.id !== hit.id);
        state.selected.delete(hit.id);
        markPreviewDirty();
        resetPreviewRuntime();
      }
      return;
    }

    if(state.tool === "note"){
      const lane = laneFromX(m.x);
      const tRaw = timeFromYEditor(m.y);
      const t = state.snapOn ? quantizeAt(tRaw) : tRaw;
      addNote({ id: uid(), lane, t, type:"tap", end:t, hs:0, vol:0 });
      syncHitsoundUI();
      return;
    }

    if(state.tool === "ln"){
      const lane = laneFromX(m.x);
      const t0Raw = timeFromYEditor(m.y);
      const t0 = state.snapOn ? quantizeAt(t0Raw) : t0Raw;
      const id = uid();
      addNote({ id, lane, t:t0, type:"hold", end: t0 + snapStepMsAt(t0), hs:0, vol:0 });
      state.drag.mode = "lnCreate";
      state.drag.holdId = id;
      syncHitsoundUI();
      return;
    }
  });

  editWrap.addEventListener("mousemove", (e)=>{
    if(!state.drag.down) return;
    if(state.tool === "select" && state.drag.mode === "move"){
      const m = mousePos(e, editWrap);
      const dl = laneFromX(m.x) - laneFromX(state.drag.x0);
      const ms0 = state.snapOn ? quantizeAt(timeFromYEditor(state.drag.y0)) : timeFromYEditor(state.drag.y0);
      const ms1 = state.snapOn ? quantizeAt(timeFromYEditor(m.y)) : timeFromYEditor(m.y);
      const dt = ms1 - ms0;
      applyMoveSelection(dl, dt);
      return;
    }

    if(state.tool === "ln" && state.drag.mode === "lnCreate"){
      const m = mousePos(e, editWrap);
      const id = state.drag.holdId;
      const n = state.notes.find(x => x.id === id);
      if(!n) return;
      const endRaw = timeFromYEditor(m.y);
      const end = state.snapOn ? quantizeAt(endRaw) : endRaw;
      n.end = Math.max(n.t + 1, end);
      sortNotes();
      markPreviewDirty();
      resetPreviewRuntime();
      return;
    }
  });

  window.addEventListener("mouseup", ()=>{
    if(!state.drag.down) return;
    state.drag.down = false;
    state.drag.mode = "none";
    state.drag.holdId = null;
    state.drag.moveSnap = null;
  });

  /* ===== Wave interactions (seek + bookmarks) ===== */
  waveWrap.addEventListener("wheel", (e)=>{
    e.preventDefault();
    if(!state.buffer) return;
    const delta = e.deltaY;
    const ms = delta * (2.2 / state.view.pxPerMs);
    seekMs(state.timeMs + ms);
  }, {passive:false});

  waveWrap.addEventListener("mousedown", (e)=>{
    if(!state.buffer) return;
    const m = mousePos(e, waveWrap);
    const ms = timeFromYWave(m.y);
    seekMs(state.snapOn ? quantizeAt(ms) : ms);

    const onMove = (ev)=>{
      const mm = mousePos(ev, waveWrap);
      const t = timeFromYWave(mm.y);
      seekMs(state.snapOn ? quantizeAt(t) : t);
    };
    const onUp = ()=>{
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("mouseup", onUp);
    };
    window.addEventListener("mousemove", onMove);
    window.addEventListener("mouseup", onUp);
  });

  /* ===== Zoom ===== */
  function zoom(mult){
    const z = clamp(state.view.pxPerMs * mult, state.view.min, state.view.max);
    state.view.pxPerMs = z;
  }
  zoomIn.addEventListener("click", ()=> zoom(state.view.zoomStep));
  zoomOut.addEventListener("click", ()=> zoom(1/state.view.zoomStep));

  /* ===== Tools ===== */
  toolBtns.forEach(btn => {
    btn.addEventListener("click", ()=> setTool(btn.getAttribute("data-tool")));
  });

  /* ===== Hitsounds ===== */
  hsWhistle.addEventListener("click", ()=> toggleHs(2));
  hsFinish.addEventListener("click", ()=> toggleHs(4));
  hsClap.addEventListener("click", ()=> toggleHs(8));
  hsVol.addEventListener("input", ()=> setHsVol(parseInt(hsVol.value,10) || 0));

  /* ===== Bottom controls ===== */
  function beatLenMsAtNow(){
    const tp = activeTP(state.timeMs);
    return 60000 / (tp?.bpm || 180);
  }

  prevBtn.addEventListener("click", ()=>{
    if(!state.buffer) return;
    seekMs(state.timeMs - beatLenMsAtNow());
  });
  nextBtn.addEventListener("click", ()=>{
    if(!state.buffer) return;
    seekMs(state.timeMs + beatLenMsAtNow());
  });

  playBtn.addEventListener("click", ()=> state.isPlaying ? pause() : play());
  stopBtn.addEventListener("click", stop);

  testPlayBtn.addEventListener("click", ()=>{
    if(!state.buffer) return;
    if(!state.preview.enabled){
      // liga preview automaticamente pra "test play"
      pushUndo();
      state.preview.enabled = true;
      previewToggle.checked = true;
      applyPreviewLayout();
    }
    if(state.isPlaying) pause(); else play();
  });

  exitBtn.addEventListener("click", ()=> alert("EXIT (placeholder) ‚Äî aqui voc√™ pode redirecionar para a home do seu site."));

  addBmBtn.addEventListener("click", addBookmark);

  /* ===== Modal open/close ===== */
  optionsBtn.addEventListener("click", ()=>{
    modalBackdrop.classList.add("show");
  });
  closeModal.addEventListener("click", ()=>{
    modalBackdrop.classList.remove("show");
  });
  modalBackdrop.addEventListener("mousedown", (e)=>{
    if(e.target === modalBackdrop) modalBackdrop.classList.remove("show");
  });

  /* ===== Options wiring ===== */
  audioFile.addEventListener("change", async ()=>{
    const f = audioFile.files[0];
    if(!f) return;
    await loadAudio(f);
  });

  bgFile.addEventListener("change", async ()=>{
    const f = bgFile.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    bgImg.onload = ()=> URL.revokeObjectURL(url);
    bgImg.src = url;
  });

  bgOpacity.addEventListener("input", ()=>{
    state.bg.opacity = clamp(parseFloat(bgOpacity.value)||0.35, 0, 1);
    bgImg.style.opacity = String(state.bg.opacity);
  });
  bgBlur.addEventListener("input", ()=>{
    state.bg.blur = clamp(parseInt(bgBlur.value,10)||0, 0, 20);
    bgImg.style.filter = `blur(${state.bg.blur}px)`;
  });

  keysSel.addEventListener("change", ()=>{
    pushUndo();
    state.keys = clamp(parseInt(keysSel.value,10), 4, 7);
    for(const n of state.notes) n.lane = clamp(n.lane, 0, state.keys-1);
    markPreviewDirty();
    resetPreviewRuntime();
    syncHitsoundUI();
  });

  snapSel.addEventListener("change", ()=>{
    pushUndo();
    state.snap = clamp(parseInt(snapSel.value,10), 1, 16);
  });

  snapOnToggle.addEventListener("change", ()=>{
    pushUndo();
    state.snapOn = !!snapOnToggle.checked;
  });

  bpmIn.addEventListener("change", ()=>{
    pushUndo();
    const bpm = clamp(parseFloat(bpmIn.value)||180, 30, 400);
    state.timing[0].bpm = bpm;
  });
  offIn.addEventListener("change", ()=>{
    pushUndo();
    const off = Math.max(0, Math.round(parseFloat(offIn.value)||0));
    state.timing[0].t = off;
    normalizeTiming();
  });

  rateSel.addEventListener("change", ()=>{
    pushUndo();
    state.rate = parseFloat(rateSel.value) || 1;
    if(state.isPlaying){
      pause();
      play();
    }
  });

  previewToggle.addEventListener("change", ()=>{
    pushUndo();
    state.preview.enabled = !!previewToggle.checked;
    applyPreviewLayout();
  });

  clearBtn.addEventListener("click", clearNotes);
  undoBtn.addEventListener("click", doUndo);

  /* ===== Keyboard ===== */
  window.addEventListener("keydown", (e)=>{
    if(e.code === "Space"){
      e.preventDefault();
      if(state.isPlaying) pause(); else play();
      return;
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="z"){
      e.preventDefault();
      doUndo();
      return;
    }
    if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="b"){
      e.preventDefault();
      addBookmark();
      return;
    }
    if(e.code === "Delete"){
      deleteSelection();
      return;
    }
    if(e.key === "1") setTool("select");
    if(e.key === "2") setTool("note");
    if(e.key === "3") setTool("ln");
    if(e.key === "4") setTool("erase");
  });

  /* ===== Export / Import ===== */
  function laneToOsuX(lane){
    const x = Math.floor((lane + 0.5) * 512 / state.keys);
    return clamp(x, 0, 511);
  }

  function exportOsu(){
    if(!state.buffer){
      alert("Carregue um √°udio antes de exportar (OPTIONS > √Åudio).");
      return;
    }

    normalizeTiming();
    sortNotes();

    const meta = getMeta();
    const audioName = (audioFile.files[0]?.name || "audio.mp3").replaceAll("\\","/");
    const keys = state.keys;

    const bgName = bgFile.files[0]?.name ? bgFile.files[0].name.replaceAll("\\","/") : "";

    const header =
`osu file format v14

[General]
AudioFilename: ${audioName}
AudioLeadIn: 0
PreviewTime: -1
Countdown: 0
SampleSet: Soft
StackLeniency: 0.7
Mode: 3
LetterboxInBreaks: 0
SpecialStyle: 0
WidescreenStoryboard: 0

[Editor]
BeatDivisor: ${state.snap}
GridSize: 4
TimelineZoom: 1.0

[Metadata]
Title:${meta.title}
Artist:${meta.artist}
Creator:${meta.creator}
Version:${keys}K ${meta.version}
Source:
Tags:

[Difficulty]
HPDrainRate:5
CircleSize:${keys}
OverallDifficulty:8
ApproachRate:5
SliderMultiplier:1.4
SliderTickRate:1

[Events]
//Background and Video events
`;

    const events = bgName ? `0,0,"${bgName}",0,0\n` : "";

    const timingHeader = `
[TimingPoints]
`;
    const tps = state.timing
      .slice()
      .sort((a,b)=>a.t-b.t)
      .map(tp => {
        const beatLen = (60000 / tp.bpm);
        return `${Math.round(tp.t)},${beatLen.toFixed(15)},${tp.meter||4},2,0,100,1,0`;
      }).join("\n");

    const hitHeader = `
[HitObjects]
`;

    const hitLines = state.notes.map(n => {
      const x = laneToOsuX(n.lane);
      const y = 192;
      const t = Math.round(n.t);
      const hs = n.hs ?? 0;
      const vol = clamp(n.vol ?? 0, 0, 100);
      const sample = `0:0:0:${vol}:`;

      if(n.type === "tap"){
        return `${x},${y},${t},1,${hs},${sample}`;
      } else {
        const end = Math.max(t+1, Math.round(n.end));
        return `${x},${y},${t},128,${hs},${end}:${sample}`;
      }
    }).join("\n");

    const out = header + events + timingHeader + tps + "\n" + hitHeader + hitLines + "\n";

    const blob = new Blob([out], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${meta.title} - ${meta.artist} (${meta.creator}) [${keys}K ${meta.version}].osu`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  exportBtn.addEventListener("click", exportOsu);

  function parseOsu(text){
    const lines = text.replace(/\r/g,"").split("\n");
    let section = "";
    const meta = {};
    let keys = 4;
    const timing = [];
    const notes = [];

    function parseKV(line){
      const i = line.indexOf(":");
      if(i<0) return null;
      return [line.slice(0,i).trim(), line.slice(i+1).trim()];
    }

    for(const raw of lines){
      const line = raw.trim();
      if(!line || line.startsWith("//")) continue;
      if(line.startsWith("[") && line.endsWith("]")){
        section = line.slice(1,-1);
        continue;
      }

      if(section === "Metadata"){
        const kv = parseKV(line);
        if(kv){
          const [k,v] = kv;
          if(k==="Title") meta.title=v;
          if(k==="Artist") meta.artist=v;
          if(k==="Creator") meta.creator=v;
          if(k==="Version"){
            // might be "4K X"
            meta.version = v.replace(/^\d+K\s*/,"");
          }
        }
      }

      if(section === "Difficulty"){
        const kv = parseKV(line);
        if(kv && kv[0]==="CircleSize"){
          keys = clamp(parseInt(kv[1],10)||4, 4, 7);
        }
      }

      if(section === "TimingPoints"){
        const parts = line.split(",");
        if(parts.length >= 2){
          const t = Math.max(0, Math.round(parseFloat(parts[0])||0));
          const beatLen = parseFloat(parts[1]);
          if(beatLen > 0){
            const bpm = clamp(60000/beatLen, 30, 400);
            timing.push({ id: uid(), t, bpm, meter:4 });
          }
        }
      }

      if(section === "HitObjects"){
        const p = line.split(",");
        if(p.length < 6) continue;
        const x = parseInt(p[0],10)||0;
        const t = Math.round(parseFloat(p[2])||0);
        const type = parseInt(p[3],10)||1;
        const hs = parseInt(p[4],10)||0;

        const lane = clamp(Math.floor((x/512)*keys), 0, keys-1);

        if((type & 128) !== 0){
          // hold: p[5] like "end:sample"
          const extra = p[5] || "";
          const endStr = extra.split(":")[0];
          const end = Math.max(t+1, Math.round(parseFloat(endStr)||t+1));
          notes.push({ id: uid(), lane, t, type:"hold", end, hs, vol:0 });
        } else {
          notes.push({ id: uid(), lane, t, type:"tap", end:t, hs, vol:0 });
        }
      }
    }

    if(timing.length === 0) timing.push({ id: uid(), t:0, bpm:180, meter:4 });
    timing.sort((a,b)=>a.t-b.t);

    return { meta, keys, timing, notes };
  }

  osuIn.addEventListener("change", async ()=>{
    const f = osuIn.files[0];
    if(!f) return;
    const text = await f.text();
    const parsed = parseOsu(text);

    pushUndo();

    if(parsed.meta) setMeta(parsed.meta);
    state.keys = parsed.keys;
    state.timing = parsed.timing;
    state.notes = parsed.notes;
    sortNotes();
    normalizeTiming();

    keysSel.value = String(state.keys);
    const tp0 = state.timing[0];
    bpmIn.value = String(tp0.bpm);
    offIn.value = String(tp0.t);

    markPreviewDirty();
    resetPreviewRuntime();
    renderBookmarks();
    syncHitsoundUI();

    alert("Import OK. Agora carregue o √°udio em OPTIONS > √Åudio.");
  });

  /* ===== Bookmarks add (bottom + keybind) ===== */
  addBmBtn.addEventListener("click", addBookmark);

  /* ===== Timeline zoom controls ===== */
  // already wired

  /* ===== Global init ===== */
  function initDefaults(){
    setTool("select");
    keysSel.value = "4";
    snapSel.value = "4";
    bpmIn.value = "180";
    offIn.value = "0";
    rateSel.value = "1";
    snapOnToggle.checked = true;

    bgImg.style.opacity = "0.35";
    bgImg.style.filter = "blur(0px)";

    renderBookmarks();
    updatePlayIcon();
    refreshHUD();
  }

  /* ===== Main loop ===== */
  function loop(){
    updateTimeFromAudio();
    refreshHUD();

    drawAmpStrip();
    drawWaveform();
    drawEditor();
    drawPreview();

    requestAnimationFrame(loop);
  }

  /* ===== Buttons ===== */
  addBmBtn.addEventListener("click", addBookmark);

  /* ===== Set initial timing from inputs ===== */
  function applyTimingFromUI(){
    state.timing = [{ id: uid(), t: Math.max(0, Math.round(parseFloat(offIn.value)||0)), bpm: clamp(parseFloat(bpmIn.value)||180, 30, 400), meter:4 }];
    normalizeTiming();
  }
  applyTimingFromUI();

  /* ===== Preview toggle layout ===== */
  function setPreviewEnabled(on){
    state.preview.enabled = !!on;
    previewToggle.checked = !!on;
    applyPreviewLayout();
  }

  /* ===== Click bookmark on waveform area: right-click add BM ===== */
  waveWrap.addEventListener("contextmenu", (e)=>{
    e.preventDefault();
    addBookmark();
  });

  /* ===== Options open loads correct UI ===== */
  optionsBtn.addEventListener("click", ()=>{
    // sync UI fields with current state
    keysSel.value = String(state.keys);
    snapSel.value = String(state.snap);
    snapOnToggle.checked = !!state.snapOn;

    const tp0 = state.timing[0] || {t:0,bpm:180};
    bpmIn.value = String(tp0.bpm);
    offIn.value = String(tp0.t);

    rateSel.value = String(state.rate);

    previewToggle.checked = !!state.preview.enabled;

    bgOpacity.value = String(state.bg.opacity);
    bgBlur.value = String(state.bg.blur);

    modalBackdrop.classList.add("show");
  });

  /* ===== Volume global (use hsVol only for note; master uses browser) ===== */
  // (se voc√™ quiser master volume global depois, eu adiciono no layout igual o osu)

  initDefaults();
  fitCanvas(ampCanvas);
  fitCanvas(waveCanvas);
  fitCanvas(editCanvas);
  applyPreviewLayout();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
